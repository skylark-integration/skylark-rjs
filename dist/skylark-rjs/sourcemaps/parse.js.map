{"version":3,"sources":["parse.js"],"names":["define","esprima","lang","arrayToString","ary","output","forEach","item","i","jsEscape","argPropName","emptyScope","mixin","hasProp","traverse","object","visitor","child","call","keys","Object","length","traverseBroad","key","getValidDeps","node","deps","type","elements","some","elem","push","value","undefined","isFnExpression","parse","moduleName","fileName","fileContents","options","moduleCall","depString","moduleDeps","result","moduleList","needsDefine","astRoot","recurse","callName","config","name","factoryIdentifier","fnExpScope","concat","findNestedDependencies","insertNeedsDefine","onMatch","params","param","tempObject","hasHas","has","test","this","consequent","alternate","parseNode","expression","callee","argument","definesRequire","foundDefine","foundDefineAmd","body","bodyNode","decls","declarations","declNode","id","hasDefineAmd","getAnonDeps","defFunc","findAnonDefineFactory","getAnonDepsFromNode","findRequireDepNames","funcArgLength","isDefineNodeWithArgs","match","arg0","arg1","findConfig","jsConfig","foundConfig","stringData","foundRange","quote","quoteMatch","quoteRegExp","loc","arg","requireType","hasRequire","getRequireObjectLiteral","nodeToString","range","exec","eval","init","renameNamespace","ns","lines","locs","split","reverse","startIndex","start","column","lineIndex","line","substring","join","findDependencies","dependencies","findCjsDependencies","hasDefDefine","left","property","refsDefineAmd","c","hasDefine","getNamedDefine","getAllNamedDefines","excludeMap","names","hasOwnProperty","usesAmdOrRequireJs","uses","usesCommonJs","assignsExports","exp","factory","refsDefine","args","isUmd","cjsDeps","arguments","contents","preamble","slice","extracted","end","getLicenseComments","commentNode","refNode","subNode","j","ast","comment","existsMap","lineEnd","indexOf","comments"],"mappings":"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","file":"../parse.js","sourcesContent":["/*jslint plusplus: true */\n/*global define: false */\n\ndefine([\n    './esprima', \n    './lang'\n], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n"]}