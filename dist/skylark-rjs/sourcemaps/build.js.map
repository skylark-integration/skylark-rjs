{"version":3,"sources":["build.js"],"names":["define","require","lang","prim","logger","parse","optimize","pragma","transform","requirePatch","commonJs","sourceMap","build","SourceMapGenerator","hasProp","getOwn","falseProp","endsWithSemiColonRegExp","endsWithSlashRegExp","resourceIsModuleIdRegExp","deepCopyProps","layer","copyConfig","obj","deeplikeCopy","makeBuildBaseConfig","fs","appDir","pragmas","paths","optimizeCss","inlineText","isBuild","optimizeAllPluginResources","findNestedDependencies","preserveLicenseComments","writeBuildTxt","waitSeconds","dirExclusionRegExp","_buildPathToModuleIndex","addSemiColon","text","config","skipSemiColonInsertion","test","endsWithSlash","dirName","charAt","length","endsWithNewLine","makeWriteFile","namespace","writeFile","name","contents","trace","file","saveUtf8File","asModule","moduleName","fileName","toTransport","appendToFileContents","fileContents","singleContents","path","module","sourceMapGenerator","sourceMapPath","pluginId","sourceMapLineNumber","lineCount","i","refPath","out","baseUrl","_buildPath","parts","split","makeRelativeFilePath","shift","resourcePath","join","toUrl","addMapping","generated","line","column","original","source","setSourceContent","stringDotToObj","result","value","forEach","prop","mixConfig","target","skipArrays","targetValue","isArray","isFunction","isRegExp","concat","map","deepMix","mixin","logLevel","flattenWrapFile","keyName","absFilePath","wrap","keyFileName","keyMapName","env","absPath","makeAbsPath","fileText","readFile","push","cfg","undefined","Error","normalizeWrapConfig","start","end","__startMap","__endMap","wrapError","toString","nextTick","fn","_cacheReadAsync","encoding","d","_cachedRawText","resolve","promise","readFileAsync","then","args","buildFile","cmdConfig","errorMsg","errorStack","stackMatch","errorTree","j","errorMod","stackRegExp","error","indexOf","splice","convertArrayToObject","_run","e","err","moduleTree","exec","substring","index","stack","originalError","buildPaths","baseConfig","modules","srcPath","buildContext","destPath","moduleMap","parentModuleMap","context","resources","plugin","pluginProcessed","buildFileContents","pluginCollector","createConfig","dir","keepBuildDir","exists","deleteFile","cssIn","copyDir","replace","dirBaseUrl","isDirectory","copyFile","packagePaths","packages","s","contexts","_","_sourcePath","nameToUrl","create","rawText","allowSourceOverwrites","css","actions","normalize","traceDependencies","serial","exclude","excludeLayers","found","findBuildModule","excludeModule","excludeLayer","buildFileToModule","buildFilePaths","filePath","removeModulePath","excludeShallow","excludeShallowModule","buildPathMap","flattenModule","builtModule","finalText","_buildText","_buildSourceMap","pop","buildText","bundlesConfig","bundlesConfigOutFile","entryConfig","excludeMap","finalPath","renameFile","bundleContents","parsedIds","getAllNamedDefines","apply","removeCombined","isLayer","some","mod","relPath","onModuleBundleComplete","onCompleteData","modifyConfig","bundles","eachProp","deleteEmptyDirs","outOrigSourceMap","js","include","jsFile","getFilteredFileList","override","moduleIndex","skipDirOptimize","normalizeDirDefines","cjsTranslate","shim","convert","onBuildRead","onBuildWrite","createOverrideConfig","makeModuleMap","resource","plugins","prefix","id","defined","cssFile","info","objProps","pragmasOnSave","has","hasOnSave","uglify","uglify2","closure","throwWhen","hasDotPropMatch","dotProp","ary","separatorIndex","needArray","insertRequire","stubModules","deps","mainConfigFile","wrap.startFile","wrap.endFile","separatorI","ndex","backSlashRegExp","makeAbsObject","props","makeAbsConfig","originalBaseUrl","targetPath","dotLength","targetParts","refParts","hasEndSlash","dotParts","targetName","finalParts","slice","nestedMix","buildFileConfig","mainConfig","mainConfigPath","buildBaseConfig","parent","trim","eval","configFile","findConfig","configError","lastIndexOf","main","generateSourceMaps","cssPrefix","_byName","fileExclusionRegExp","exclusionRegExp","RegExp","_depsInclude","jQuery","enforceDefine","urlArgs","baseLoaderConfig","rawTextByIds","syncChecks","rhino","node","xpconnect","deferred","includeFinished","hasError","checkForErrors","reject","_buildReset","_layer","url","__requireJsBuild","idParts","errMessage","failedPluginMap","failedPluginIds","errIds","errUrlMap","errUrlConflicts","hasErrUrl","hasUndefined","registry","populateErrUrlMap","errUrl","skipNew","enabled","modulesWithNames","oride","sourceMapBase","currContents","fileForSourceMap","packageName","builder","writeApi","namespaceWithDot","stubModulesByName","onLayerEnds","onLayerEndAdded","pkgsMainMap","included","existingRequireUrl","reqIndex","unshift","pkgs","wrapFunction","hasPackageName","getNamedDefine","useSourceUrl","onLayerEnd","write","input","shortPath","skipModuleInsertion","shimDeps","wrapShim","makeJsArrayString","exportsFn","JSON","stringify","toJSON","item","jsEscape","options","needsId","foundId"],"mappings":";;;;;;;AAIAA,OAAO,CACH,QACA,SACA,SACA,WAEA,UACA,aACA,WACA,cACA,iBAEA,aACA,gBACF,SACEC,QACAC,KACAC,KACAC,OACAC,MACAC,SACAC,OACAC,UACAC,aACAC,SACAC,WAGA,aAEA,IAAIC,MAaAC,mBAAqBF,UAAUE,mBAC/BC,QAAUZ,KAAKY,QACfC,OAASb,KAAKa,OACdC,UAAYd,KAAKc,UACjBC,wBAA0B,QAC1BC,oBAAsB,UACtBC,yBAA2B,gBAC3BC,cAAgB,CACZC,MAAO,CAAA,CACX,EAIJ,SAASC,WAAWC,GAChB,OAAOrB,KAAKsB,aAAaD,EAAKH,aAAa,CAC/C,CA6BA,SAASK,oBAAoBC,GACzB,MAAO,CACHC,OAAQ,GACRC,QAAS,GACTC,MAAO,GACPvB,SAAU,SACVwB,YAAa,oCACbC,WAAY,CAAA,EACZC,QAAS,CAAA,EACTC,2BAA4B,CAAA,EAC5BC,uBAAwB,CAAA,EACxBC,wBAAyB,CAAA,EACzBC,cAAe,CAAA,EAEfC,YAAa,GAGbC,mBAAoBZ,EAAGY,mBACvBC,wBAAyB,EAC7B,CACJ,CAOA,SAASC,aAAaC,EAAMC,GACxB,OAAIA,EAAOC,wBAA0B1B,wBAAwB2B,KAAKH,CAAI,EAC3DA,EAEAA,EAAO,GAEtB,CAEA,SAASI,cAAcC,GAInB,MAH2C,MAAvCA,EAAQC,OAAOD,EAAQE,OAAS,CAAC,IACjCF,GAAW,KAERA,CACX,CAEA,SAASG,gBAAgBR,GAIrB,MAHqC,OAAjCA,EAAKM,OAAON,EAAKO,OAAS,CAAC,IAC3BP,GAAQ,MAELA,CACX,CAIA,SAASS,cAAcC,EAAW9B,GAC9B,SAAS+B,EAAUC,EAAMC,GACrBlD,OAAOmD,MAAM,iCAAmCF,CAAI,EACpDG,KAAKC,aAAaJ,EAAMC,CAAQ,CACpC,CAOA,OALAF,EAAUM,SAAW,SAAUC,EAAYC,EAAUN,GACjDF,EAAUQ,EACNhD,MAAMiD,YAAYV,EAAWQ,EAAYC,EAAUN,EAAUjC,CAAK,CAAC,CAC3E,EAEO+B,CACX,CAgBA,SAASU,qBAAqBC,EAAcC,EAAgBC,EAAMvB,EAAQwB,OAAQC,GAC9E,IAAaC,EAA6BC,EAAUC,EAAqBC,EAAkBC,EAC3F,GAAIL,EAAoB,CA6BpB,IA3BIM,EADA/B,EAAOgC,IACGhC,EAAOiC,QACVT,QAAUA,OAAOU,WACdV,OAAOU,WAEP,GAKVR,EAFiB,KADrBS,OAAQZ,EAAKa,MAAM,GAAG,GACZ9B,OAEUpC,MAAMmE,qBAAqBN,EAASR,CAAI,GAMxDI,EAAWQ,OAAMG,MAAM,EACvBC,OAAeJ,OAAMK,KAAK,GAAG,EACzB/D,yBAAyByB,KAAKqC,MAAY,EAC1BrE,MAAMmE,qBAAqBN,EAASxE,QAAQkF,MAAMF,MAAY,CAAC,EAC/D,IAAMZ,EAENJ,GAIxBK,EAAsBP,EAAae,MAAM,IAAI,EAAE9B,OAAS,EACxDuB,EAAYP,EAAec,MAAM,IAAI,EAAE9B,OAClCwB,EAAI,EAAGA,GAAKD,EAAWC,GAAK,EAC7BL,EAAmBiB,WAAW,CAC1BC,UAAW,CACPC,KAAMhB,EAAsBE,EAC5Be,OAAQ,CACZ,EACAC,SAAU,CACNF,KAAMd,EACNe,OAAQ,CACZ,EACAE,OAAQrB,CACZ,CAAC,EAOLD,EAAmBuB,iBAAiBtB,EAAeJ,CAAc,CACrE,CAEA,OADAD,GAAgBC,CAEpB,CAsoBA,SAAS2B,eAAeC,EAAQvC,EAAMwC,GAClC,IAAIhB,EAAQxB,EAAKyB,MAAM,GAAG,EAE1BD,EAAMiB,QAAQ,SAAUC,EAAMvB,GACtBA,IAAMK,EAAM7B,OAAS,EACrB4C,EAAOG,GAAQF,GAEX7E,UAAU4E,EAAQG,CAAI,IACtBH,EAAOG,GAAQ,IAEnBH,EAASA,EAAOG,GAGxB,CAAC,CACL,CA2MA,SAASC,UAAUC,EAAQR,EAAQS,GAC/B,IAAIH,EAAMF,EAAgBM,EAE1B,IAAKJ,KAAQN,EACL3E,QAAQ2E,EAAQM,CAAI,IAGpBF,EAAQJ,EAAOM,GACfK,EAAUlG,KAAKkG,QAAQP,CAAK,EACP,UAAjB,OAAOA,GAAsBA,CAAAA,GACxBO,GAAYlG,KAAKmG,WAAWR,CAAK,GACjC3F,KAAKoG,SAAST,CAAK,EAejBO,EACFF,IAGDC,EAAcF,EAAOF,GACjB7F,KAAKkG,QAAQD,CAAW,EACxBF,EAAOF,GAAQI,EAAYI,OAAOV,CAAK,EAEvCI,EAAOF,GAAQF,GAIvBI,EAAOF,GAAQF,EApBF,QAATE,GACKE,EAAOO,MACRP,EAAOO,IAAM,IAEjBtG,KAAKuG,QAAQR,EAAOO,IAAKf,EAAOe,GAAG,GAEnCP,EAAOF,GAAQ7F,KAAKwG,MAAM,GAAIT,EAAOF,GAAOF,EAAO,CAAA,CAAI,GAqBnE3F,KAAKY,QAAQmF,EAAQ,UAAU,GAC/B7F,OAAOuG,SAASV,EAAOU,QAAQ,CAEvC,CAMA,SAASC,gBAAgBlE,EAAQmE,EAASC,GACtC,IAAIC,EAAOrE,EAAOqE,KACdC,EAAcH,EAAU,OACxBI,EAAa,KAAOJ,EAAU,MAC9BnF,EAAKgB,EAAOwE,IAAIxF,GAEpB,GAA6B,UAAzB,OAAOqF,EAAKF,IAAyBE,EAAKC,GAC1CD,EAAKF,GAAW,GACiB,UAA7B,OAAOE,EAAKC,KACZD,EAAKC,GAAe,CAACD,EAAKC,KAE9BD,EAAKE,GAAc,GACnBF,EAAKC,GAAalB,QAAQ,SAAUlC,GAChC,IAAIuD,EAAUvG,MAAMwG,YAAYxD,EAAUkD,EAAYpF,CAAE,EACpD2F,EAAWpE,gBAAgBvB,EAAG4F,SAASH,CAAO,CAAC,EACnDJ,EAAKE,GAAYM,KAAK,SAAUxD,EAAcyD,EAAKrD,GAC/C,OAAOL,qBAAqBC,EAAcsD,EAAUF,EAASK,EAAK,KAAMrD,CAAkB,CAC9F,CAAC,EACD4C,EAAKF,IAAYQ,CACrB,CAAC,OACE,GAAsB,OAAlBN,EAAKF,IAAwCY,KAAAA,IAAlBV,EAAKF,GAEvCE,EAAKF,GAAW,OACb,CAAA,GAA6B,UAAzB,OAAOE,EAAKF,GASnB,MAAM,IAAIa,MAAM,QAAUb,EAAU,YAAcG,EAAc,YAAY,EAR5ED,EAAKF,GAAW5D,gBAAgB8D,EAAKF,EAAQ,EAC7CE,EAAKE,GAAc,CACf,SAAUlD,EAAcyD,EAAKrD,GACzB,IAAIgD,EAAUvG,MAAMwG,YAAY,eAAiBP,EAAU,cAAeC,EAAYpF,CAAE,EACxF,OAAOoC,qBAAqBC,EAAcgD,EAAKF,GAAUM,EAASK,EAAK,KAAMrD,CAAkB,CACnG,EAIR,CACJ,CAEA,SAASwD,oBAAoBjF,EAAQoE,GAEjC,IAAIpF,EAAKgB,EAAOwE,IAAIxF,GACpB,IACQgB,EAAOqE,OACa,CAAA,IAAhBrE,EAAOqE,KAEPrE,EAAOqE,KAAO,CACVa,MAAO,mBACPC,IAAK,QACLC,WAAY,CACR,SAAU/D,EAAcyD,EAAKrD,GACzB,OAAOL,qBAAqBC,EAAc,mBACdnD,MAAMwG,YAAY,+BACAN,EAAYpF,CAAE,EAAG8F,EAAK,KACxCrD,CAAkB,CAClD,GAEJ4D,SAAU,CACN,SAAUhE,EAAcyD,EAAKrD,GACzB,OAAOL,qBAAqBC,EAAc,QACdnD,MAAMwG,YAAY,6BAA8BN,EAAYpF,CAAE,EAC9D8F,EAAK,KAAMrD,CAAkB,CAC7D,EAER,GAEAyC,gBAAgBlE,EAAQ,QAASoE,CAAW,EAC5CF,gBAAgBlE,EAAQ,MAAOoE,CAAW,GAKtD,CAFE,MAAOkB,GACL,MAAM,IAAIN,MAAM,0BAA4BM,EAAUC,SAAS,CAAC,CACpE,CACJ,CAs/BA,OAhnEA9H,KAAK+H,SAAW,SAAUC,GACtBA,EAAG,CACP,EAUAlI,QAAQmI,gBAAkB,SAAUnE,EAAMoE,EAAS3G,GAC/C,IAAI4G,EAEJ,OAAIpI,KAAKY,QAAQb,QAAQsI,eAAgBtE,CAAI,IACzCqE,EAAInI,KAAK,GACPqI,QAAQvI,QAAQsI,eAAetE,EAAK,EAC/BqE,EAAEG,SAEF/G,EAAGgH,cAAczE,EAAMoE,CAAQ,EAAEM,KAAK,SAAUlG,GAEnD,OADAxC,QAAQsI,eAAetE,GAAQxB,CAEnC,CAAC,CAET,EAwJA7B,MAAQ,SAAUgI,GACd,IAAIC,EAAWC,EAAWC,EAAUC,EAAYC,EAAYC,EACxD1E,EAAG2E,EAAGC,EACNC,EAAc,mBAGlB,OAAOlJ,KAAK,EAAEyH,MAAM,WAChB,GAAI,CAACgB,GAAQ1I,KAAKkG,QAAQwC,CAAI,EAAG,CAC7B,GAAI,CAACA,GAAQA,EAAK5F,OAAS,EAGvB,OAFA5C,KAAAA,OAAOkJ,MAAM,6IAC4G,EAOhG,CAAC,IAA1BV,EAAK,GAAGW,QAAQ,GAAG,IACnBV,EAAYD,EAAK,GACjBA,EAAKY,OAAO,EAAG,CAAC,IAIpBV,EAAYlI,MAAM6I,qBAAqBb,CAAI,GACjCC,UAAYA,CAC1B,MACIC,EAAYF,EAGhB,OAAOhI,MAAM8I,KAAKZ,CAAS,CAC/B,CAAC,EAAEH,KAAK,KAAM,SAAUgB,GACpB,IAAIC,EAYJ,GAVAb,EAAWY,EAAE1B,SAAS,EACtBiB,EAAYS,EAAEE,YACdZ,EAAaI,EAAYS,KAAKf,CAAQ,KAGlCA,GAAYA,EAASgB,UAAU,EAAGd,EAAWe,MAAQf,EAAW,GAAGjG,OAAS,CAAC,GAK7EkG,GAAgC,EAAnBA,EAAUlG,OAAY,CAGnC,IAFA+F,GAAY,sBAEPvE,EAAI0E,EAAUlG,OAAS,EAAO,CAAC,EAALwB,EAAQA,CAAC,GAEpC,GADA4E,EAAWF,EAAU1E,GACP,CACV,IAAK2E,EAAID,EAAUlG,OAASwB,EAAO,CAAC,EAAL2E,EAAQA,CAAC,GACpCJ,GA9CC,KAgDLA,GAAYK,EAAW,IAC3B,CAGJhJ,OAAOkJ,MAAMP,CAAQ,CACzB,CAkBA,MAhBAC,EAAaW,EAAEM,MAEK,UAAhB,OAAOrB,GAAyD,CAAC,IAArCA,EAAKW,QAAQ,iBAAiB,EAC1DR,GAAY,KAAOC,EAEf,CAACC,GAAcD,IAEfC,EAAaI,EAAYS,KAAKd,CAAU,KAEpCD,GAAY,KAAOE,EAAW,IAAM,KAKhDW,EAAM,IAAIlC,MAAMqB,CAAQ,GACpBmB,cAAgBP,EACdC,CACV,CAAC,CACL,EAEAhJ,MAAM8I,KAAO,SAAUZ,GACnB,IAAIqB,EAAYvG,EACZ/B,EAAO2C,EACP4F,EAAY1H,EACZ2H,EAASC,EAASC,EAClBC,EAAUC,EAAWC,EAAiBC,EACtCC,EAAqBC,EAAQ9G,EAI7BrC,EAHAoJ,EAAkB,GAClBC,EAAoB,GACpBC,EAAkB,GAGtB,OAAO7K,KAAK,EAAEyH,MAAM,WAqBhB,GAbAlF,EAAS9B,MAAMqK,aAAanC,CAAS,EACrCjH,EAAQa,EAAOb,MACfH,EAAKgB,EAAOwE,IAAIxF,GAEhBjB,aAAaiC,CAAM,EAKfA,EAAOwI,KAAO,CAACxI,EAAOyI,cAAgBzJ,EAAG0J,OAAO1I,EAAOwI,GAAG,GAC1DxJ,EAAG2J,WAAW3I,EAAOwI,GAAG,EAGxB,CAACxI,EAAOgC,KAAO,CAAChC,EAAO4I,MASvB,GAJA5J,EAAG6J,QAAS7I,EAAOf,QAAUe,EAAOiC,QAAUjC,EAAOwI,IAAK,KAAM,CAAA,CAAI,EAGpEf,EAAa,GACTzH,EAAOf,OAGP,IAhCR,IAAIoE,KAgCiBlE,EACLf,QAAQe,EAAOkE,CAAI,IACnBoE,EAAWpE,GAAQlE,EAAMkE,GAAMyF,QAAQ9I,EAAOf,OAAQe,EAAOwI,GAAG,QAKxE,IAAKnF,KAAQlE,EACLf,QAAQe,EAAOkE,CAAI,IAGyB,IAAxClE,EAAMkE,GAAMwD,QAAQ7G,EAAOiC,OAAO,EAClCwF,EAAWpE,GAAQlE,EAAMkE,GAAMyF,QAAQ9I,EAAOiC,QAASjC,EAAO+I,UAAU,GAExEtB,EAAWpE,GAAwB,WAAhBlE,EAAMkE,GAAqB,SAAWA,EAK5B,KAD7BuE,EAAUzI,EAAMkE,IACJwD,QAAQ,GAAG,GAAoC,CAAC,IAA1Be,EAAQf,QAAQ,GAAG,IACjDe,EAAU5H,EAAOiC,QAAU2F,GAG/BE,EAAW9H,EAAO+I,WAAatB,EAAWpE,GAG1B,WAAZuE,IAEI5I,EAAG0J,OAAOd,CAAO,GAAK5I,EAAGgK,YAAYpB,CAAO,EAE5C5I,EAAG6J,QAAQjB,EAASE,EAAU,KAAM,CAAA,CAAI,GAGxCF,GAAW,MACXE,GAAY,MACZ9I,EAAGiK,SAASrB,EAASE,CAAQ,MAazDvK,QAAQ,CACJ0E,QAASjC,EAAOiC,QAChB9C,MAAOA,EACP+J,aAAclJ,EAAOkJ,aACrBC,SAAUnJ,EAAOmJ,QACrB,CAAC,EACDtB,EAAetK,QAAQ6L,EAAEC,SAASC,GAClC3B,EAAU3H,EAAO2H,UAGbA,EAAQvE,QAAQ,SAAU5B,QACtB,GAAIA,OAAOb,OACPa,OAAO+H,YAAc1B,EAAa2B,UAAUhI,OAAOb,IAAI,EAKnD,EAAC3B,EAAG0J,OAAOlH,OAAO+H,WAAW,GAAM/H,OAAOiI,QACT,CAAC,IAA9BjI,OAAOb,KAAKkG,QAAQ,GAAG,GACrB7G,EAAO0J,SAAYlM,KAAKY,QAAQ4B,EAAO0J,QAASlI,OAAOb,IAAI,IACjE,MAAM,IAAIqE,MAAM,sCACAxD,OAAO+H,YAAc,sBAAwB/H,OAAOb,KACpD,0BAA4B3B,EAAGyF,QAAQ,GAAG,CAAC,CAGvE,CAAC,EAGDzE,EAAOgC,KAEPzE,QAAQyC,CAAM,EACTA,EAAO4I,QACR5I,EAAO2H,QAAQ,GAAGzF,WAAmC,YAAtB,OAAOlC,EAAOgC,IACd,WAAahC,EAAOgC,MAE/ChC,EAAO4I,QAGflB,EAAa,CACTzF,QAASjC,EAAO+I,WAChB5J,MAAOsI,CACX,EAEAjK,KAAKwG,MAAM0D,EAAY1H,CAAM,EAC7BzC,QAAQmK,CAAU,EAEdC,GACAA,EAAQvE,QAAQ,SAAU5B,QACtB,GAAIA,OAAOb,KAAM,CAOb,GANAa,OAAOU,WAAa2F,EAAa2B,UAAUhI,OAAOb,KAAM,IAAI,EAMxDa,OAAOU,aAAeV,OAAO+H,aAC7B,CAACvJ,EAAO2J,sBACR,MAAM,IAAI3E,MAAM,cAAiBxD,OAAOb,KACxB,oDACAa,OAAO+H,YACP,kCAAkC,EAIjD/H,OAAOiI,QAAYzJ,EAAO0J,SAAYlM,KAAKY,QAAQ4B,EAAO0J,QAASlI,OAAOb,IAAI,GAC/E3B,EAAGiK,SAASzH,OAAO+H,YAAa/H,OAAOU,UAAU,CAEzD,CACJ,CAAC,GAOLlC,EAAOZ,aAAsC,SAAvBY,EAAOZ,aAA0BY,EAAOwI,MAC9DH,GAAqBzK,SAASgM,IAAI5J,EAAOwI,IAAKxI,CAAM,EAE5D,CAAC,EAAEiG,KAAK,WACJyB,EAAa9I,WAAWrB,QAAQ6L,EAAEC,SAASC,EAAEtJ,MAAM,CACvD,CAAC,EAAEiG,KAAK,WACJ,IAAI4D,EAEJ,GAAIlC,EAeA,OAdAkC,EAAUlC,EAAQ7D,IAAI,SAAUtC,OAAQM,GACpC,OAAO,WAMH,OAHA9B,EAAOH,wBAAwBb,EAAG8K,UAAUtI,OAAOU,UAAU,GAAKJ,EAG3D5D,MAAM6L,kBAAkBvI,OAAQxB,EAAQ0H,CAAU,EACpDzB,KAAK,SAAUtH,GACZ6C,OAAO7C,MAAQA,CACnB,CAAC,CACT,CACJ,CAAC,EAEMlB,KAAKuM,OAAOH,CAAO,CAElC,CAAC,EAAE5D,KAAK,WACJ,IAAI4D,EAEJ,GAAIlC,EA2BA,OAvBAkC,EAAUlC,EAAQ7D,IAAI,SAAUtC,QAC5B,OAAO,WACH,GAAIA,OAAOyI,QAEP,OADAzI,OAAO0I,cAAgB,GAChBzM,KAAKuM,OAAOxI,OAAOyI,QAAQnG,IAAI,SAAUmG,EAASnI,GACrD,OAAO,WAGH,IAAIqI,EAAQjM,MAAMkM,gBAAgBH,EAAStC,CAAO,EAClD,GAAIwC,CAAAA,EAGA,OAAOjM,MAAM6L,kBAAkB,CAACpJ,KAAMsJ,CAAO,EAAGjK,EAAQ0H,CAAU,EAC7DzB,KAAK,SAAUtH,GACZ6C,OAAO0I,cAAcpI,GAAK,CAAEnD,MAAOA,CAAM,CAC7C,CAAC,EALL6C,OAAO0I,cAAcpI,GAAKqI,CAOlC,CACJ,CAAC,CAAC,CAEV,CACJ,CAAC,EAEM1M,KAAKuM,OAAOH,CAAO,CAElC,CAAC,EAAE5D,KAAK,WACJ,GAAI0B,EACA,OAAOlK,KAAKuM,OAAOrC,EAAQ7D,IAAI,SAAUtC,QACrC,OAAO,WA0BH,OAzBIA,OAAOyI,SAIPzI,OAAOyI,QAAQ7G,QAAQ,SAAUiH,EAAevI,GAC5C,IAAIwI,EAAe9I,OAAO0I,cAAcpI,GAAGnD,MACvCmF,EAAMwG,EAAaC,kBACvBD,EAAaE,eAAepH,QAAQ,SAASqH,GACzCvM,MAAMwM,iBAAiB5G,EAAI2G,GAAWA,EAAUjJ,OAAO7C,KAAK,CAChE,CAAC,CACL,CAAC,EAED6C,OAAOmJ,gBAIPnJ,OAAOmJ,eAAevH,QAAQ,SAAUwH,GACpC,IAAIrJ,EAAOlD,OAAOmD,OAAO7C,MAAMkM,aAAcD,CAAoB,EAC7DrJ,GACArD,MAAMwM,iBAAiBE,EAAsBrJ,EAAMC,OAAO7C,KAAK,CAEvE,CAAC,EAIET,MAAM4M,cAActJ,OAAQA,OAAO7C,MAAOqB,CAAM,EAAEiG,KAAK,SAAU8E,GACpE,IAAIC,EAIsB,aAAtBxJ,OAAOU,YACPV,OAAOyJ,WAAaF,EAAYhL,KAChCyB,OAAO0J,gBAAkBH,EAAY9M,YAErC+M,EAAYD,EAAYhL,KACpBgL,EAAY9M,YAGZ+M,GAAa,0BAFFxJ,OAAOU,WAAWE,MAAM,GAAG,EAClB+I,IAAI,EAC4B,OACpDnM,EAAG+B,aAAaS,OAAOU,WAAa,OAAQ6I,EAAY9M,SAAS,GAErEe,EAAG+B,aAAaS,OAAOU,WAAa,QAAS8I,CAAS,GAG1D3C,GAAqB0C,EAAYK,SACrC,CAAC,CACL,CACJ,CAAC,CAAC,CAEV,CAAC,EAAEnF,KAAK,WACJ,IAAIhF,EA4DIlB,EA3DJsL,EAAgB,GAChBC,EAAuBtL,EAAOsL,qBAiFlC,GA/EI3D,IAEAA,EAAQvE,QAAQ,SAAU5B,QACtB,IAeQ+J,EAEIC,EAhBRC,EAAYjK,OAAOU,WAEL,aAAduJ,IACIzM,EAAG0J,OAAO+C,CAAS,GACnBzM,EAAG2J,WAAW8C,CAAS,EAE3BzM,EAAG0M,WAAWD,EAAY,QAASA,CAAS,EAOxCH,IACAC,EAAcF,EAAc7J,OAAOb,MAAQ,GACvCgL,EAAiB3M,EAAG4F,SAAS6G,CAAS,GACtCD,EAAa,IACNhK,OAAOb,MAAQ,CAAA,EACtBiL,EAAYjO,MAAMkO,mBAAmBF,EAAgBH,CAAU,EACnED,EAAY1G,KAAKiH,MAAMP,EAAaK,CAAS,GAM7C5L,EAAO+L,iBAAkB,CAAC/L,EAAOgC,KACjCR,OAAO7C,MAAM6L,eAAepH,QAAQ,SAAU7B,GAC1C,IAAIyK,EAAUrE,EAAQsE,KAAK,SAAUC,GAC7B,OAAOA,EAAIhK,aAAeX,CAC9B,CAAC,EACD4K,EAAUjO,MAAMmE,qBAAqBrC,EAAOwI,IAAKjH,CAAI,EAErDvC,EAAG0J,OAAOnH,CAAI,GAEd,CAACyK,GAEyB,IAA1BG,EAAQtF,QAAQ,IAAI,GACpB7H,EAAG2J,WAAWpH,CAAI,CAE1B,CAAC,EAKLvB,EAAOoM,wBACPpM,EAAOoM,uBAAuB5K,OAAO6K,cAAc,CAE3D,CAAC,EAGGf,KACIvL,EAAOf,EAAG4F,SAAS0G,CAAoB,EAC3CvL,EAAOjC,UAAUwO,aAAavM,EAAM,SAAUC,GAS1C,OARKA,EAAOuM,UACRvM,EAAOuM,QAAU,IAGrB/O,KAAKgP,SAASnB,EAAe,SAAUlI,EAAOE,GAC1CrD,EAAOuM,QAAQlJ,GAAQF,CAC3B,CAAC,EAEMnD,CACX,CAAC,EAEDhB,EAAG+B,aAAauK,EAAsBvL,CAAI,GAM9CC,EAAO+L,gBAAkB,CAAC/L,EAAOgC,KAAOhC,EAAOwI,KAC/CxJ,EAAGyN,gBAAgBzM,EAAOwI,GAAG,EAI7BxI,EAAOgC,KAAO,CAAChC,EAAO4I,MAGL,cADjB1H,EAAWlB,EAAO2H,QAAQ,GAAGzF,aAEzBwK,EAAmB1M,EAAO2H,QAAQ,GAAGuD,gBACrClL,EAAOkL,gBAAkBwB,EACzB1M,EAAO2H,QAAQ,GAAGsD,WAAarN,SAAS+O,IAAI3M,EAAO2H,QAAQ,GAAGhH,MAClBX,EAAO2H,QAAQ,GAAGiF,QAAQ,IAC1B1L,GAAY,YACblB,EAAO2H,QAAQ,GAAGsD,WAClB,KACAjL,CAAM,EAC7CA,EAAOkL,iBAAmBlL,EAAOkL,kBAAoBwB,IACrD1M,EAAO2H,QAAQ,GAAGuD,gBAAkBlL,EAAOkL,gBAC3ClL,EAAOkL,gBAAkB,OAG7BtN,SAASiP,OAAO3L,EAAU,KAAMA,EAAUlB,CAAM,OAEjD,GAAI,CAACA,EAAO4I,MAAO,CAiFtB,IAAK3H,KA7EOjC,EAAG8N,oBAAoB9M,EAAOwI,IAAK,QAAS,CAAA,CAAI,EAClDpF,QAAQ,SAAUlC,GACxB,IAAS6L,EAAUC,EAKnB/L,GAFAA,EAAaC,EAAS4H,QAAQ9I,EAAOwI,IAAK,EAAE,GAEpBnB,UAAU,EAAGpG,EAAWX,OAAS,CAAC,GAYxC,CAAC,GALnB0M,EAA8B,KAF9BA,EAAc3O,OAAO2B,EAAOH,wBAAyBqB,CAAQ,IAEZ,EAAd8L,EAAkBA,EAAc,CAAC,IAK5C,CAAChN,EAAOiN,iBACO,QAA/BjN,EAAOkN,qBACPlN,EAAOmN,gBAIX9L,EAAerC,EAAG4F,SAAS1D,CAAQ,EAM/BlB,CAAAA,EAAOmN,cACLnN,EAAOoN,MAAS5P,KAAKY,QAAQ4B,EAAOoN,KAAMnM,CAAU,IACtDI,EAAerD,SAASqP,QAAQnM,EAAUG,CAAY,GAGtC,CAAC,IAAjB2L,IACIhN,EAAOsN,cACPjM,EAAerB,EAAOsN,YAAYrM,EACAC,EACAG,CAAY,GAMf,QAA/BrB,EAAOkN,sBACP7L,EAAenD,MAAMiD,YAAYnB,EAAOS,UACX,KACAS,EACAG,CAAY,GAGzCrB,EAAOuN,gBACPlM,EAAerB,EAAOuN,aAAatM,EACAC,EACAG,CAAY,GAOnDyD,GAHJiI,EAAyB,CAAC,EAAfC,EACAhN,EAAO2H,QAAQqF,GAAaD,SAAW,MAExC7O,MAAMsP,qBAAqBxN,EAAQ+M,CAAQ,EAE3C/M,EAGQ,CAAC,EAAfgN,GAAoB,CAAChN,EAAOiN,kBAC5BrP,SAASiP,OAAO3L,EAAUG,EAAcH,EAAU4D,EAAKwD,CAAe,CAGlF,CAAC,EAGDL,EAAU1K,QAAQ6L,EAAEC,SAASC,EAEVhB,EACf,GAAIlK,QAAQkK,EAAiBrH,CAAU,EAGnC,IAFA+G,EAAkBC,EAAQwF,cAAcxM,CAAU,EAClDiH,EAAYI,EAAgBrH,GACvBa,EAAI,EAAGA,EAAIoG,EAAU5H,OAAQwB,CAAC,GAAI,CAGnC,GAFA4L,EAAWxF,EAAUpG,GACrBiG,EAAYE,EAAQwF,cAAcC,EAAU1F,CAAe,EACvD1J,UAAU2J,EAAQ0F,QAAS5F,EAAU6F,MAAM,EAAG,CAM9C,GAHA3F,EAAQ0F,QAAQ5F,EAAU6F,QAAU,CAAA,EAGhC,CAAC5O,EAAG0J,OAAOnL,QAAQkF,MAAMsF,EAAU6F,OAAS,KAAK,CAAC,EAClD,SAKJ3F,EAAQ1K,QAAQ,CAACwK,EAAU6F,OAAO,EAIlC7F,EAAYE,EAAQwF,cAAcC,EAAU1F,CAAe,CAC/D,CAKI1J,UAAU8J,EAAiBL,EAAU8F,EAAE,KAIvC1F,EAAS9J,OAAO4J,EAAQ6F,QAAS/F,EAAU6F,MAAM,IACnCzF,EAAOzH,WACjByH,EAAOzH,UACHqH,EAAU6F,OACV7F,EAAUpH,KACVpD,QACAiD,cACIR,EAAOS,SACX,EACAwH,EAAQjI,MACZ,EAGJoI,EAAgBL,EAAU8F,IAAM,CAAA,EAExC,CASJ7N,EAAON,eACPV,EAAG+B,aAAaf,EAAOwI,IAAM,YAAaH,CAAiB,CAEnE,CAYA,OATIrI,EAAO4I,QACPP,GAAqBzK,SAASmQ,QAAQ/N,EAAO4I,MAAO5I,EAAOgC,IAAKhC,CAAM,EAAEoL,WAGlD,YAAtB,OAAOpL,EAAOgC,KACdhC,EAAOgC,IAAIhC,EAAO2H,QAAQ,GAAGsD,WAAYjL,EAAO2H,QAAQ,GAAGuD,eAAe,EAI1E7C,GACA3K,OAAOsQ,KAAK3F,CAAiB,EACtBA,GAGJ,EACX,CAAC,CACL,EAwBAnK,MAAM+P,SAAW,CACb9O,MAAO,CAAA,EACPkF,KAAM,CAAA,EACNnF,QAAS,CAAA,EACTgP,cAAe,CAAA,EACfC,IAAK,CAAA,EACLC,UAAW,CAAA,EACXC,OAAQ,CAAA,EACRC,QAAS,CAAA,EACTC,QAAS,CAAA,EACTzK,IAAK,CAAA,EACL0K,UAAW,CAAA,EACX9E,QAAS,CAAA,CACb,EAEAxL,MAAMuQ,gBAAkB,SAAUpL,GAC9B,IACIiE,EAAQjE,EAAKwD,QAAQ,GAAG,EAE5B,MAAc,CAAC,IAAXS,IACAoH,EAAUrL,EAAKgE,UAAU,EAAGC,CAAK,EAC1BlJ,QAAQF,MAAM+P,SAAUS,CAAO,EAG9C,EAUAxQ,MAAM6I,qBAAuB,SAAU4H,GAcnC,IAbA,IAAoBC,EAAgBvL,EAAMF,EAAtCD,EAAS,GACT2L,EAAY,CACRjC,QAAW,CAAA,EACX3C,QAAW,CAAA,EACXU,eAAkB,CAAA,EAClBmE,cAAiB,CAAA,EACjBC,YAAe,CAAA,EACfC,KAAQ,CAAA,EACRC,eAAkB,CAAA,EAClBC,iBAAkB,CAAA,EAClBC,eAAgB,CAAA,CACpB,EAECrN,EAAI,EAAGA,EAAI6M,EAAIrO,OAAQwB,CAAC,GACzBsN,WAAWC,KAAOV,EAAI7M,GAAG+E,QAAQ,GAAG,EAMtB,UADd1D,EAAQwL,EAAI7M,GAAGuF,UAAUuH,IAAoBD,EAAI7M,GAAGxB,MAAM,GAEtD6C,EAAQ,CAAA,EACS,UAAVA,IACPA,EAAQ,CAAA,GAGZE,EAAOsL,EAAI7M,GAAGuF,UAAU,EAAGuH,CAAc,EAGrCvQ,OAAOwQ,EAAWxL,CAAI,IACtBF,EAAQA,EAAMf,MAAM,GAAG,GAGvBlE,MAAMuQ,gBAAgBpL,CAAI,EAC1BJ,eAAeC,EAAQG,EAAMF,CAAK,EAElCD,EAAOG,GAAQF,EAGvB,OAAOD,CACX,EAEAhF,MAAMwG,YAAc,SAAUnD,EAAM6C,EAAYpF,GAC5C,OAAKoF,GAMqB,IAAtB7C,EAAKsF,QAAQ,GAAG,GAAiC,CAAC,IAAvBtF,EAAKsF,QAAQ,GAAG,IAC3CtF,EAAO6C,GACgD,MAA/CA,EAAY/D,OAAO+D,EAAY9D,OAAS,CAAC,EAAY,GAAK,KAC3DiB,EACPA,EAAOvC,EAAG8K,UAAUvI,CAAI,GAErBA,EAAKuH,QAAQtL,KAAK8R,gBAAiB,GAAG,GAXlC/N,CAYf,EAEArD,MAAMqR,cAAgB,SAAUC,EAAO3Q,EAAKuF,EAAYpF,GACpD,IAAI8C,EAAGuB,EACP,GAAIxE,EACA,IAAKiD,EAAI,EAAGA,EAAI0N,EAAMlP,OAAQwB,CAAC,GAC3BuB,EAAOmM,EAAM1N,GACT1D,QAAQS,EAAKwE,CAAI,GAA0B,UAArB,OAAOxE,EAAIwE,KACjCxE,EAAIwE,GAAQnF,MAAMwG,YAAY7F,EAAIwE,GAAOe,EAAYpF,CAAE,EAIvE,EAMAd,MAAMuR,cAAgB,SAAUzP,EAAQoE,EAAYpF,GAIhD,IAHA,IAAWqE,EAEXmM,EAAQ,CAAC,SAAU,MAAO,WACrB1N,EAAI,EAAGA,EAAI0N,EAAMlP,OAAQwB,CAAC,GAGvBzD,OAAO2B,EAFXqD,EAAOmM,EAAM1N,EAEU,IAGN,YAATuB,GACArD,EAAO0P,gBAAkB1P,EAAOiC,QAC5BjC,EAAOf,OAIPe,EAAOiC,QAAU/D,MAAMwG,YAAY1E,EAAO0P,gBAAiB1P,EAAOf,OAAOD,CAAE,EAI3EgB,EAAOiC,QAAU/D,MAAMwG,YAAY1E,EAAOqD,GAAOe,EAAYpF,CAAE,GAGnEgB,EAAOqD,GAAQnF,MAAMwG,YAAY1E,EAAOqD,GAAOe,EAAYpF,CAAE,EAGjEgB,EAAOqD,GAAQlD,cAAcH,EAAOqD,EAAK,GAIjDnF,MAAMqR,cAA8B,WAAfvP,EAAOgC,IAAmB,CAAC,SAAW,CAAC,MAAO,SAC/ChC,EAAQoE,EAAYpF,CAAE,EAC1Cd,MAAMqR,cAAc,CAAC,YAAa,WAAYvP,EAAOqE,KAAMD,EAAYpF,CAAE,EACzEd,MAAMqR,cAAc,CAAC,qBAAsBvP,EAAOuO,QAASnK,EAAYpF,CAAE,CAC7E,EAOAd,MAAMmE,qBAAuB,SAAUN,EAAS4N,EAAW3Q,GACvD,IAAI8C,EAAG8N,EAAuBtP,EAAQuP,EAClCC,EAAW/N,EAAQK,MAAM,GAAG,EAC5B2N,EAAcvR,oBAAoB0B,KAAKyP,CAAU,EACjDK,EAAW,GAgBf,IAdAL,EAAa3Q,EAAG8K,UAAU6F,CAAU,EAChCI,GAAe,CAACvR,oBAAoB0B,KAAKyP,CAAU,IACnDA,GAAc,KAIlBM,GAFAJ,EAAcF,EAAWvN,MAAM,GAAG,GAET+I,IAAI,EAI7B2E,EAAS3E,IAAI,EAEb7K,EAASwP,EAASxP,OAEbwB,EAAI,EAAGA,EAAIxB,GACRwP,EAAShO,KAAO+N,EAAY/N,GADZA,GAAK,GAU7B,IAHAoO,EAAaL,EAAYM,MAAMrO,CAAC,EAEhC8N,EAAYtP,EAASwB,EAChBA,EAAI,EAAO,CAAC,EAALA,GAAUA,EAAI8N,EAAW9N,GAAK,EACtCkO,EAASnL,KAAK,IAAI,EAGtB,OAAOmL,EAASxN,KAAK,GAAG,GAAKwN,EAAS1P,OAAS,IAAM,IAC9C4P,EAAW1N,KAAK,GAAG,GAAK0N,EAAW5P,OAAS,IAAM,IAClD2P,CACX,EAEA/R,MAAMkS,UAAY,CACdjR,MAAO,CAAA,EACPgP,IAAK,CAAA,EACLC,UAAW,CAAA,EACXlP,QAAS,CAAA,EACTgP,cAAe,CAAA,CACnB,EA+IAhQ,MAAMqK,aAAe,SAAUzD,KAE3B,IAAI9F,GAAK8F,IAAIN,IAAIxF,GAEbqJ,kBAAmBgI,gBAAiBC,WACpCrB,eAAgBsB,eAAgBpK,UAAW/B,YAC3CpE,OAAS,GACTwQ,gBAAkBzR,oBAAoBC,EAAE,EAK5CoF,YAAcpF,GAAGyF,QAAQ,GAAG,EAc5B,GAbAvG,MAAMuR,cAAc3K,IAAKV,YAAYpF,EAAE,EACvCd,MAAMuR,cAAce,gBAAiBpM,YAAYpF,EAAE,EAEnDxB,KAAKwG,MAAMhE,OAAQwQ,eAAe,EAClChT,KAAKwG,MAAMhE,OAAQ8E,IAAK,CAAA,CAAI,EAKxBtH,KAAKY,QAAQ4B,OAAQ,UAAU,GAC/BtC,OAAOuG,SAASjE,OAAOiE,QAAQ,EAG/BjE,OAAOmG,UAAW,CAMlB,GAJAA,UAAYnH,GAAGyF,QAAQzE,OAAOmG,SAAS,EAInC,CAACnH,GAAG0J,OAAOvC,SAAS,EACpB,MAAM,IAAInB,MAAM,qCAAuCmB,SAAS,EAGpE/B,YAAcpE,OAAOiC,QAAUjD,GAAGyF,QAAQzF,GAAGyR,OAAOtK,SAAS,CAAC,EAG9DkC,kBAAoBrJ,GAAG4F,SAASuB,SAAS,EACzC,IAIIkC,kBAAoBA,kBACCS,QAAQ,yBAA0B,EAAE,EACpC4H,KAAK,EACL5H,QAAQ,KAAM,EAAE,EAErCuH,gBAAkBM,KAAK,IAAMtI,kBAAoB,GAAG,EACpDnK,MAAMuR,cAAcY,gBAAiBjM,YAAYpF,EAAE,EAOnDsE,UAAUtD,OAAQqQ,eAAe,CAGrC,CAFE,MAAOpJ,GACL,MAAM,IAAIjC,MAAM,cAAgBmB,UAAY,kBAAoBc,CAAC,CACrE,CACJ,CAqEA,GAnEAgI,eAAiBjP,OAAOiP,gBAAmBoB,iBAAmBA,gBAAgBpB,eAC1EA,iBAC8B,UAA1B,OAAOA,iBACPA,eAAiB,CAACA,iBAGtBA,eAAe7L,QAAQ,SAAUwN,GAE7B,GADAA,EAAa1S,MAAMwG,YAAYkM,EAAYxM,YAAYpF,EAAE,EACrD,CAACA,GAAG0J,OAAOkI,CAAU,EACrB,MAAM,IAAI5L,MAAM4L,EAAa,kBAAkB,EAEnD,IACIN,WAAa3S,MAAMkT,WAAW7R,GAAG4F,SAASgM,CAAU,CAAC,EAAE5Q,MAU3D,CATE,MAAO8Q,GACL,MAAM,IAAI9L,MAAM,gCACR4L,EAMA,oTAAgCA,EAAa,KAAOE,CAAW,CAC3E,CACIR,aACAC,eAAiBK,EAAWvJ,UAAU,EAAGuJ,EAAWG,YAAY,GAAG,CAAC,EAKhE/Q,OAAOf,QAAU,CAACqR,WAAWrR,SAC7BqR,WAAWrR,OAASe,OAAOf,QAI1BqR,WAAWrO,UACZqO,WAAWrO,QAAUsO,gBAGzBrS,MAAMuR,cAAca,WAAYC,eAAevR,EAAE,EACjDsE,UAAUtD,OAAQsQ,UAAU,EAEpC,CAAC,GAKDD,iBACA/M,UAAUtD,OAAQqQ,gBAAiB,CAAA,CAAI,EAM3C/M,UAAUtD,OAAQ8E,IAAK,CAAA,CAAI,EAI3BtH,KAAKgP,SAASxM,OAAOb,MAAO,SAAUgE,EAAOE,GACzC,GAAI7F,KAAKkG,QAAQP,CAAK,EAClB,MAAM,IAAI6B,MAAM,8FAES3B,CAAI,EAEjCrD,OAAOb,MAAMkE,GAAQnF,MAAMwG,YAAYvB,EAAOnD,OAAOiC,QAAQjD,EAAE,CACnE,CAAC,EAGGZ,QAAQ4B,OAAQ,SAAS,EAAG,CAC5B,GAAIA,OAAOf,OAAQ,CACf,GAAI,CAACe,OAAO0P,gBACR,MAAM,IAAI1K,MAAM,0CAA0C,EAE9DhF,OAAO+I,WAAa7K,MAAMwG,YAAY1E,OAAO0P,gBAAiB1P,OAAOwI,IAAIxJ,EAAE,CAC/E,MACIgB,OAAO+I,WAAa/I,OAAOwI,KAAOxI,OAAOiC,QAI7CjC,OAAO+I,WAAa5I,cAAcH,OAAO+I,UAAU,CACvD,CAEA,GAAI/I,OAAOsL,qBAAsB,CAC7B,GAAI,CAACtL,OAAOwI,IACR,MAAM,IAAIxD,MAAM,0EACiB,EAErChF,OAAOsL,qBAAuBpN,MAAMwG,YAAY1E,OAAOsL,qBAAsBtL,OAAOwI,IAAIxJ,EAAE,CAC9F,CAkBA,GAAIgB,OAAOgR,KACP,MAAM,IAAIhM,MAAM,wEACoC,EAExD,GAAIhF,OAAOgC,KAAO,CAAChC,OAAOW,MAAQ,CAACX,OAAO2H,SAAW,CAAC3H,OAAO4M,SACrD,CAAC5M,OAAO4I,MACZ,MAAM,IAAI5D,MAAM,wDACQ,EAE5B,GAAIhF,OAAO4I,MAAO,CACd,GAAI5I,OAAOwI,KAAOxI,OAAOf,OACrB,MAAM,IAAI+F,MAAM,2HACmE,EAEvF,GAAI,CAAChF,OAAOgC,IACR,MAAM,IAAIgD,MAAM,uBAAuB,CAE/C,CAKA,GAJKhF,OAAO4I,OAAU5I,OAAOiC,UAEzBjC,OAAOiC,QAAU,MAEjB,CAACjC,OAAOgC,KAAO,CAAChC,OAAOwI,IACvB,MAAM,IAAIxD,MAAM,8JAGY,EAEhC,GAAIhF,OAAOf,QAAUe,OAAOgC,IACxB,MAAM,IAAIgD,MAAM,mKAGuB,EAE3C,GAAIhF,OAAOgC,KAAOhC,OAAOwI,IACrB,MAAM,IAAIxD,MAAM,iLAGoC,EAIxD,GAAIhF,OAAOwI,KAIH,CAACxI,OAAO2J,wBAA0B3J,OAAOwI,MAAQxI,OAAOiC,SACxDjC,OAAOwI,MAAQxI,OAAOf,QACrBe,OAAOiC,SACwD,IAD7C/D,MAAMmE,qBAAqBrC,OAAOwI,IAC1BxI,OAAOiC,QAAQjD,EAAE,EAAE6H,QAAQ,IAAI,GACzD7G,OAAOf,QACuE,IAA3Ef,MAAMmE,qBAAqBrC,OAAOwI,IAAKxI,OAAOf,OAAOD,EAAE,EAAE6H,QAAQ,IAAI,GACzE,MAAM,IAAI7B,MAAM,8UAOsC,EAI9D,GAAIhF,OAAO8O,eAAiB,CAACtR,KAAKkG,QAAQ1D,OAAO8O,aAAa,EAC1D,MAAM,IAAI9J,MAAM,kFACsC,EAa1D,GARwB,YAApBhF,OAAOpC,WACPoC,OAAOpC,SAAW,UAElBoC,OAAOsO,UACPtO,OAAOqO,OAASrO,OAAOsO,QACvB,OAAOtO,OAAOsO,SAGdtO,OAAOiR,mBAAoB,CAC3B,GAAIjR,OAAOP,yBAAiD,SAApBO,OAAOpC,UAA2C,WAApBoC,OAAOpC,SACzE,MAAM,IAAIoH,MAAM,8TAK6C,EAC1D,GAAwB,SAApBhF,OAAOpC,UACa,YAApBoC,OAAOpC,UACa,WAApBoC,OAAOpC,SAId,MAAM,IAAIoH,MAAM,cAAgBhF,OAAOpC,SACnC,wCAAwC,CAEpD,CAEA,GAAKoC,CAAAA,OAAOW,MAAQX,CAAAA,OAAO4M,SAAa5M,OAAO2H,QAkBxC,CAAA,GAAI3H,OAAO2H,SAAW3H,OAAOgC,IAChC,MAAM,IAAIgD,MAAM,gKAGsB,EACnC,GAAIhF,OAAO2H,SAAW3H,OAAOW,KAChC,MAAM,IAAIqE,MAAM,+KAGsC,CAC1D,MAvBIhF,OAAO2H,QAAU,CACb,CACIhH,KAAMX,OAAOW,KACbqB,IAAKhC,OAAOgC,IACZyH,OAAQzJ,OAAOyJ,OACfmD,QAAS5M,OAAO4M,QAChB3C,QAASjK,OAAOiK,QAChBU,eAAgB3K,OAAO2K,eACvBmE,cAAe9O,OAAO8O,cACtBC,YAAa/O,OAAO+O,WACxB,GAEJ,OAAO/O,OAAO+O,YAuElB,GA1DI/O,CAAAA,OAAOgC,KAAQhC,OAAO4I,OAOjB9D,IAAI1F,cACLY,OAAOZ,YAAc,QAKzBY,OAAOkR,UAEPlR,OAAOkR,UAAY/Q,cAAcH,OAAOkR,SAAS,EAEjDlR,OAAOkR,UAAY,GAInBlR,OAAO2H,SAAW3H,OAAO2H,QAAQrH,QACjCN,OAAO2H,QAAQvE,QAAQ,SAAU8I,GAC7B,GAAI1O,KAAKkG,QAAQwI,CAAG,GAAoB,UAAf,OAAOA,GAAoB,CAACA,EACjD,MAAM,IAAIlH,MAAM,kFACyC,EAIzDhF,OAAO+O,cACP7C,EAAI6C,YAAc/O,OAAO+O,YAAYlL,OAAOqI,EAAI6C,aAAe,EAAE,GAKjE7C,EAAI6C,cACJ7C,EAAI6C,YAAYoC,QAAU,GAC1BjF,EAAI6C,YAAY3L,QAAQ,SAAUyK,GAC9B3B,EAAI6C,YAAYoC,QAAQtD,GAAM,CAAA,CAClC,CAAC,GAKsB,UAAvB,OAAO3B,EAAIU,UACXV,EAAIU,QAAU,CAACV,EAAIU,UAInBV,EAAIa,UACJ9H,oBAAoBiH,EAAIa,SAAU3I,WAAW,CAErD,CAAC,EAGLa,oBAAoBjF,OAAQoE,WAAW,EAGnCpE,OAAOiI,QACP,MAAM,IAAIjD,MAAM,gGAES,EA4C7B,OAvCK5G,QAAQ4B,OAAQ,qBAAqB,IACd,SAApBA,OAAOpC,UAAuBoC,OAAOiN,gBACrCjN,OAAOkN,oBAAsB,OAE7BlN,OAAOkN,oBAAsB,OAKjC9O,QAAQ4B,OAAQ,qBAAqB,EACK,UAAtC,OAAOA,OAAOoR,oBACdpS,GAAGqS,gBAAkB,IAAIC,OAAOtR,OAAOoR,mBAAmB,EAE1DpS,GAAGqS,gBAAkBrR,OAAOoR,oBAEzBhT,QAAQ4B,OAAQ,oBAAoB,IAI3ChB,GAAGqS,gBAAkBrR,OAAOJ,oBAQ5BI,OAAOgP,OACPhP,OAAOuR,aAAevR,OAAOgP,MAMjC,OAAOhP,OAAOgP,KACd,OAAOhP,OAAOwR,OACd,OAAOxR,OAAOyR,cACd,OAAOzR,OAAO0R,QAEP1R,MACX,EASA9B,MAAMkM,gBAAkB,SAAUnJ,EAAY0G,GAE1C,IADA,IAAOnG,OACFM,EAAI,EAAGA,EAAI6F,EAAQrH,OAAQwB,CAAC,GAE7B,IADAN,OAASmG,EAAQ7F,IACNnB,OAASM,EAChB,OAAOO,OAGf,OAAO,IACX,EASAtD,MAAMwM,iBAAmB,SAAUlJ,OAAQD,EAAM5C,GACzC2I,EAAQ3I,EAAM6L,eAAe3D,QAAQtF,CAAI,EAC/B,CAAC,IAAX+F,GACA3I,EAAM6L,eAAe1D,OAAOQ,EAAO,CAAC,CAE5C,EAaApJ,MAAM6L,kBAAoB,SAAUvI,OAAQxB,EAAQ2R,GAChD,IAAI/E,EAAmBjO,EAAOsJ,EAC1B2J,EACAC,EAAa,CACTC,MAAO,CAAA,EACPC,KAAM,CAAA,EACNC,UAAW,CAAA,CACf,EACAC,EAAWxU,KAAK,EAiDpB,SAASyU,EAAgB/O,GAMrB,IAAIgP,EAAW,CAAA,EACf,GAAIN,EAAW7R,EAAOwE,IAAI7D,MACtB,IACIzC,MAAMkU,eAAenK,EAAStJ,CAAK,CAIvC,CAHE,MAAOsI,GACLkL,EAAW,CAAA,EACXF,EAASI,OAAOpL,CAAC,CACrB,CAGCkL,GACDF,EAASnM,QAAQ3C,CAAK,CAE9B,CAaA,OA7Ea5F,QAAQ+U,YAAY,EAIjC3T,EAAQpB,QAAQgV,OAChBtK,EAAUtJ,EAAMsJ,QAGZ0J,GACApU,QAAQqB,WAAW+S,CAAgB,CAAC,EAGxCjU,OAAOmD,MAAM,gCAAkCW,OAAOb,OAClB,YAAtB,OAAOa,OAAOQ,IAAqB,WAAaR,OAAOQ,KAAK,EAE1E4K,GADAA,EAAU5M,EAAOuR,cAAiB,IAChB1N,OAAOrC,OAAOb,MAAQ,CAACa,OAAOiI,OAAS,CAACjI,OAAOb,MAAQ,EAAE,EACvEa,OAAOoL,UACPA,EAAUA,EAAQ/I,OAAOrC,OAAOoL,OAAO,GAIvCpL,OAAOuL,WAEHA,EADA4E,EACWzT,MAAMsP,qBAAqBmE,EAAkBnQ,OAAOuL,QAAQ,EAE5DnO,WAAW4C,OAAOuL,QAAQ,EAEzCxP,QAAQwP,CAAQ,IAKpB6E,EAAerU,QAAQ6L,EAAEC,SAASC,EAAEtJ,OAAO0J,UAEvClM,KAAKgP,SAASoF,EAAc,SAAUhR,EAAUiN,GACxC2E,EAAMjV,QAAQkF,MAAMoL,CAAE,EAAI,MAC9BtQ,QAAQsI,eAAe2M,GAAO5R,CAClC,CAAC,EAKLqR,EAASI,OAAOI,iBAAmB,CAAA,EAuBnCP,EAAgBO,iBAAmB,CAAA,EAGnClV,QAAQqP,EAASsF,EAAiBD,EAASI,MAAM,EAK7CR,EAAW7R,EAAOwE,IAAI7D,OACtBzC,MAAMkU,eAAenK,EAAStJ,CAAK,EAGhCsT,EAASlM,QAAQE,KAAK,WAQzB,OANIzE,OAAOuL,UAAY4E,GACnBpU,QAAQqB,WAAW+S,CAAgB,CAAC,EAGxCzT,MAAMkU,eAAenK,EAAStJ,CAAK,EAE5BA,CACX,CAAC,CACL,EAEAT,MAAMkU,eAAiB,SAAUnK,EAAStJ,GAGtC,IAAIkP,EAAIxK,EAAM6I,EAAKwG,EAAS/Q,EACxBgR,EAAa,GACbC,EAAkB,GAClBC,EAAkB,GAClBC,EAAS,GACTC,EAAY,GACZC,EAAkB,GAClBC,EAAY,CAAA,EACZC,EAAe,CAAA,EACfpF,EAAU7F,EAAQ6F,QAClBqF,EAAWlL,EAAQkL,SAEvB,SAASC,EAAkBvF,EAAIwF,EAAQC,GAE9BD,IAIAC,GACDR,EAAOjO,KAAKgJ,CAAE,EAGdkF,EAAUM,IACVJ,EAAY,CAAA,EAGPD,EAAgBK,KACjBL,EAAgBK,GAAU,GAE1BL,EAAgBK,GAAQxO,KAAKkO,EAAUM,EAAO,GAElDL,EAAgBK,GAAQxO,KAAKgJ,CAAE,GACvByF,IACRP,EAAUM,GAAUxF,GAE5B,CAEA,IAAKA,KAAMsF,EACH/U,QAAQ+U,EAAUtF,CAAE,GAA2B,IAAtBA,EAAGhH,QAAQ,KAAK,IACzCqM,EAAe,CAAA,EACfhH,EAAM7N,OAAO8U,EAAUtF,CAAE,EAEzBlM,GADA+Q,EAAU7E,EAAGzL,MAAM,GAAG,GACH,GAEiB,CAAC,IAAjCyL,EAAGhH,QAAQ,eAAe,GAAYqF,GAAOA,EAAIqH,SACjDH,EAAkBvF,EAAI3B,EAAIpI,IAAI0O,GAAG,EAMjC,CAACpU,QAAQO,EAAM6U,iBAAkB3F,CAAE,IAAsB,EAAjB6E,EAAQpS,SAC5ChC,UAAUsU,EAAiBjR,CAAQ,GACnCkR,EAAgBhO,KAAKlD,CAAQ,GAEfiR,EAAgBjR,KAEZiR,EAAgBjR,GAAY,KAElCkD,KAAKgJ,GAAM3B,EAAItF,MAAQ,KAAOsF,EAAItF,MAAQ,GAAG,GAOzE,GAAIsM,EACA,IAAKrF,KAAMC,EACH1P,QAAQ0P,EAASD,CAAE,GAAyB,CAAC,IAArBA,EAAGhH,QAAQ,GAAG,GACtCuM,EAAkBvF,EAAItQ,QAAQkF,MAAMoL,CAAE,EAAI,MAAO,CAAA,CAAI,EAKjE,GAAIiF,EAAOxS,QAAUuS,EAAgBvS,OAAQ,CAazC,GAZIuS,EAAgBvS,SAChBqS,GAAc,iBACkB,IAA3BE,EAAgBvS,OAAe,GAAK,KAErC,kDACAuS,EAAgB/O,IAAI,SAAUnC,GAE1B,OAAOA,EAAW,QADIiR,EAAgBjR,GACMa,KAAK,MAAM,CAC3D,CAAC,EAAEA,KAAK,IAAI,EAAI,MAExBmQ,GAAc,wCAA0CG,EAAOtQ,KAAK,IAAI,EAEpEyQ,EAIA,IAAK5P,KAHLsP,GAAc,gIAGDK,EACL5U,QAAQ4U,EAAiB3P,CAAI,IAC7BsP,GAAc,KAAOtP,EAAO,KACd2P,EAAgB3P,GAAMb,KAAK,IAAI,GAIzD,MAAM,IAAIwC,MAAM2N,CAAU,CAC9B,CACJ,EAEAzU,MAAMsP,qBAAuB,SAAUxN,EAAQ+M,GAC3C,IAAIjI,EAAMlG,WAAWoB,CAAM,EACvByT,EAAQ7U,WAAWmO,CAAQ,EAc/B,OAZAvP,KAAKgP,SAASiH,EAAO,SAAUtQ,EAAOE,GAC9BjF,QAAQF,MAAM+P,SAAU5K,CAAI,GAG5ByB,EAAIzB,GAAQ,GACZ7F,KAAKwG,MAAMc,EAAIzB,GAAOrD,EAAOqD,GAAO,CAAA,CAAI,EACxC7F,KAAKwG,MAAMc,EAAIzB,GAAO0J,EAAS1J,GAAO,CAAA,CAAI,GAE1CyB,EAAIzB,GAAQ0J,EAAS1J,EAE7B,CAAC,EAEMyB,CACX,EAgBA5G,MAAM4M,cAAgB,SAAUtJ,OAAQ7C,EAAOqB,GAC3C,IAAIqB,EAAcI,EACdiS,EACArL,EAAoB,GACpBrJ,EAAKgB,EAAOwE,IAAIxF,GAEpB,OAAOvB,KAAK,EAAEyH,MAAM,WAChB,IAAcyO,EAAcC,EACxB3S,EAAYmM,EAAMyG,EAClB1R,EAAO2R,EAASC,EAChBtT,EAAWuT,EAAkBC,EAC7BhM,EAAUtJ,EAAMsJ,QAChBiM,EAAc,GACdC,EAAkB,GAClBC,EAAc,GA6DlB,OAzDI5S,OAAOuL,WACP/M,EAAS9B,MAAMsP,qBAAqBxN,EAAQwB,OAAOuL,QAAQ,GAG/DtM,EAAYT,EAAOS,WAAa,GAChCuT,EAAmBvT,EAAYA,EAAY,IAAM,GACjDwT,EAAqBzS,OAAOuN,aAAevN,OAAOuN,YAAYoC,SAAY,GAG1E3P,OAAO6K,eAAiB,CACpB1L,KAAMa,OAAOb,KACbY,KAAOvB,EAAOwI,IAAMhH,OAAOU,WAAW4G,QAAQ9I,EAAOwI,IAAK,EAAE,EAAIhH,OAAOU,WACvEmS,SAAU,EACd,EAEAhM,GAAqB,KACC7G,OAAO6K,eAAe9K,KACvB,uBAGjB5C,EAAM2V,oBAEW,CAAC,KADlBC,EAAW5V,EAAM6L,eAAe3D,QAAQlI,EAAM2V,kBAAkB,KAE5D3V,EAAM6L,eAAe1D,OAAOyN,EAAU,CAAC,EACvC5V,EAAM6L,eAAegK,QAAQ7V,EAAM2V,kBAAkB,GAIzDtU,EAAOiR,qBACPyC,EAAgB1T,EAAOwI,KAAOxI,EAAOiC,QAEjC2R,EADsB,aAAtBpS,OAAOU,YACaV,OAAOb,MAAQa,OAAOoL,QAAQ,IAAM,YAAc,YAC/D5M,EAAOgC,IACKR,OAAOU,WAAWE,MAAM,GAAG,EAAE+I,IAAI,EAEjC3J,OAAOU,WAAW4G,QAAQ4K,EAAe,EAAE,EAElEjS,EAAqB,IAAItD,mBAAmB,CACxC2C,KAAM8S,CACV,CAAC,GAMLpW,KAAKgP,SAAS7N,EAAMsJ,QAAQjI,OAAOyU,KAAM,SAAStR,EAAOE,GACrD+Q,EAAYjR,GAASE,CACzB,CAAC,EAGDhC,EAAe,GACXrB,EAAOqE,MAAQrE,EAAOqE,KAAKe,YAC3BpF,EAAOqE,KAAKe,WAAWhC,QAAQ,SAAUsR,GACrCrT,EAAeqT,EAAarT,EAAcrB,EAAQyB,CAAkB,CACxE,CAAC,EAGEhE,KAAKuM,OAAOrL,EAAM6L,eAAe1G,IAAI,SAAUvC,GAClD,OAAO,WACH,IAAID,EAAiB,GAQrB,OANAL,EAAatC,EAAM4L,kBAAkBhJ,GAIrCsS,EAAcxV,OAAO+V,EAAanT,CAAU,EAErCxD,KAAK,EAAEyH,MAAM,WAKhB,GAFA/C,EAAQ8F,EAAQwF,cAAcxM,CAAU,EAEpC6S,EADJA,EAAU3R,EAAMyL,QAAUvP,OAAO4J,EAAQ6F,QAAS3L,EAAMyL,MAAM,GA+B1D,OAAOnQ,KAAK,EAAEyH,MAAM,WAChB,OAAI9G,QAAQ6V,EAAmBhT,CAAU,EAIjC7C,QAAQO,EAAMsJ,QAAQ0F,QAAS1M,CAAU,EAGlC,qFAEA,cAGJ1D,QAAQmI,gBAAgBnE,EAAKwD,KAAAA,EAAU/F,CAAE,CAExD,CAAC,EAAEiH,KAAK,SAAUlG,GACd,IAAI4U,EAEJhB,EAAe5T,EAEXC,CAAAA,EAAOmN,cACLnN,EAAOoN,MAAS5P,KAAKY,QAAQ4B,EAAOoN,KAAMnM,CAAU,IACtD0S,EAAe3V,SAASqP,QAAQ9L,EAAMoS,CAAY,GAGlD3T,EAAOsN,cACPqG,EAAe3T,EAAOsN,YAAYrM,EAAYM,EAAMoS,CAAY,GAGhEE,IACAc,EAAkBd,IAAgBlW,MAAMiX,eAAejB,CAAY,GAGnElT,IACAkT,EAAe9V,OAAO4C,UAAUkT,EAAclT,CAAS,GAG3DkT,EAAezV,MAAMiD,YAAYV,EAAWQ,EAAYM,EAAMoS,EAAchV,EAAO,CAC/EkW,aAAc7U,EAAO6U,YACzB,CAAC,EAEGhB,GAAe,CAACc,IAChBhB,EAAe7T,aAAa6T,EAAc3T,CAAM,EAAI,KACpD2T,GAAgBK,EAAmB,WACnBH,EAAc,QAAU5S,EACxB,4CAGhBjB,EAAOuN,eACPoG,EAAe3T,EAAOuN,aAAatM,EAAYM,EAAMoS,CAAY,GAKrErS,GAAkBxB,aAAa6T,EAAc3T,CAAM,CACvD,CAAC,EApFG8T,EAAQgB,YAAcxW,UAAU6V,EAAiBhS,EAAMyL,MAAM,IAC7DsG,EAAYrP,KAAKiP,CAAO,EACxBK,EAAgBhS,EAAMyL,QAAU,CAAA,GAGhCkG,EAAQiB,SACRhB,EAAW,SAAUiB,GACjB1T,GAAkB,KAAOxB,aAAakV,EAAOhV,CAAM,EAC/CA,EAAOuN,eACPjM,EAAiBtB,EAAOuN,aAAatM,EAAYM,EAAMD,CAAc,EAE7E,GACSN,SAAW,SAAUC,EAAY+T,GACtC1T,GAAkB,KACdxB,aAAa5B,MAAMiD,YAAYV,EAAWQ,EAAYM,EAAMyT,EAAOrW,EAAO,CACtEkW,aAAclW,EAAMsJ,QAAQjI,OAAO6U,YACvC,CAAC,EAAG7U,CAAM,EACVA,EAAOuN,eACPjM,EAAiBtB,EAAOuN,aAAatM,EAAYM,EAAMD,CAAc,EAE7E,EAEAwS,EAAQiB,MAAM5S,EAAMyL,OAAQzL,EAAMxB,KAAMoT,EAAU,CAC9CpT,KAAMa,OAAO6K,eAAe1L,KAC5BY,KAAMC,OAAO6K,eAAe9K,IAChC,CAAC,EA6Db,CAAC,EAAE0E,KAAK,WACJ,IAAcgP,EAAY1T,EAAKuH,QAAQ9I,EAAOwI,IAAK,EAAE,EAErDhH,OAAO6K,eAAegI,SAASxP,KAAKoQ,CAAS,EAC7C5M,GAAqB4M,EAAY,KAM7BhU,GAAc3C,UAAUK,EAAM6U,iBAAkBvS,CAAU,GAAK,CAACjB,EAAOkV,uBACvE9H,EAAOpN,EAAOoN,OAAS/O,OAAO2B,EAAOoN,KAAMnM,CAAU,GAAM4S,GAAexV,OAAO2B,EAAOoN,KAAMyG,CAAW,KAErGsB,EAAW3X,KAAKkG,QAAQ0J,CAAI,EAAIA,EAAOA,EAAK4B,KACxChP,EAAOoV,SAEP9T,EAAiB,sBACA0S,EAAmB,WAAa/S,EAAa,OAC5CkU,GAAYA,EAAS7U,OACfpC,MAAMmX,kBAAkBF,CAAQ,EAAI,KAAO,QAEnD,yCACS7T,EAGA,MAAQ8L,EAAKkI,UAAYlI,EAAKkI,UAAU,EAAI,IAIrD,mDAEhBhU,GAAkB,KAAO0S,EAAmB,WAAa/S,EAAa,OACpDkU,GAAYA,EAAS7U,OACfpC,MAAMmX,kBAAkBF,CAAQ,EAAI,KAAO,KACjD/H,EAAKkI,UAAYlI,EAAKkI,UAAU,EAAI,gBACrC,QAGrBhU,GAAkB,KAAO0S,EAAmB,WAAa/S,EAAa,uBAW9EI,EAAeD,qBAAqBC,EAHpCC,GAAkB,KAGgDC,EAAMvB,EAAQwB,OAC5CC,CAAkB,CAC1D,CAAC,CACL,CACJ,CAAC,CAAC,EAAEwE,KAAK,WACDiO,EAAY5T,QACZ4T,EAAY9Q,QAAQ,SAAU0Q,EAASxM,GACnC,IAAI/F,EACsB,UAAtB,OAAOC,OAAOQ,IACdT,EAAOC,OAAOQ,IACsB,UAA7B,OAAOR,OAAOU,aACrBX,EAAOC,OAAOU,YAElB4R,EAAQgB,WAAW,SAAUE,GACzB3T,EACID,qBAAqBC,EAAc,KAAOvB,aAAakV,EAAOhV,CAAM,EAC/C,aAAesH,EAAQ,MAAOtH,EAAQwB,OAAQC,CAAkB,CAC7F,EAAG,CACCd,KAAMa,OAAOb,KACbY,KAAMA,CACV,CAAC,CACL,CAAC,EAGDC,OAAOiI,SAKPpI,EACID,qBAAqBC,EAAc,KAAO2S,EAAmB,WAAaxS,OAAOb,KAC9C,sBAAuB,mBAAoBX,EAAQwB,OACjEC,CAAkB,GAM3CD,OAAOsN,gBACPzN,EACID,qBAAqBC,EAAc,KAAO2S,EAAmB,aAAexS,OAAOsN,cAActM,KAAK,MAAM,EACzE,SAAU,0BAA2BxC,EAAQwB,OAC3DC,CAAkB,EAEnD,CAAC,CACL,CAAC,EAAEwE,KAAK,WAMJ,OALIjG,EAAOqE,MAAQrE,EAAOqE,KAAKgB,UAC3BrF,EAAOqE,KAAKgB,SAASjC,QAAQ,SAAUsR,GACnCrT,EAAeqT,EAAarT,EAAcrB,EAAQyB,CAAkB,CACxE,CAAC,EAEE,CACH1B,KAAMsB,EACN+J,UAAW/C,EACXpK,UAAWwD,EACG8T,KAAKC,UAAU/T,EAAmBgU,OAAO,EAAG,KAAM,IAAI,EACtD1Q,KAAAA,CAClB,CACJ,CAAC,CACL,EAIA7G,MAAMmX,kBAAoB,SAAU1G,GAChC,MAAO,KAAOA,EAAI7K,IAAI,SAAU4R,GAE5B,OAAOlY,KAAKmY,SAASD,CAAI,CAC7B,CAAC,EAAElT,KAAK,KAAK,EAAI,IACrB,EAEAtE,MAAMiD,YAAc,SAAUV,EAAWQ,EAAYM,EAAMX,EAAUjC,EAAOiX,GACxE,IAAI3T,EAAUtD,GAASA,EAAMsJ,QAAQjI,OAAOiC,QAgB5C,OAJIA,IACAV,EAAOA,EAAKuH,QAAQ7G,EAAS,EAAE,GAG5BnE,UAAUqD,YAAYV,EAAWQ,EAAYM,EAAMX,EAd1D,SAAiBoN,GAGTrP,IAAUqP,EAAK6H,SAAW7H,EAAK8H,UAAY7U,KAC3CtC,EAAM6U,iBAAiBvS,GAAc,CAAA,EAE7C,EAQ6E2U,CAAO,CACxF,EAEOrY,QAAQW,MAAQA,KAC3B,CAAC","file":"../build.js","sourcesContent":["/*jslint plusplus: true, nomen: true, regexp: true  */\n/*global define, requirejs, java, process, console */\n\n\ndefine([\n    \"./rjs\",\n    \"./lang\",\n    \"./prim\",\n    \"./logger\",\n    ///\"env!env/file\",\n    \"./parse\",\n    \"./optimize\",\n    \"./pragma\",\n    \"./transform\",\n    \"./requirePatch\",\n    ///\"env\",\n    \"./commonJs\",\n    \"./source-map\"\n],function (\n    require,\n    lang,\n    prim,\n    logger,\n    parse,\n    optimize,\n    pragma,\n    transform,\n    requirePatch,\n    commonJs,\n    sourceMap\n\n) {\n    'use strict';\n\n    var build,\n        ///lang = require('lang'),\n        ///prim = require('prim'),\n        ///logger = require('logger'),\n        ///file = require('env!env/file'),\n        ///parse = require('parse'),\n        ///optimize = require('optimize'),\n        ///pragma = require('pragma'),\n        ///transform = require('transform'),\n        ///requirePatch = require('requirePatch'),\n        ///env = require('env'),\n        ///commonJs = require('commonJs'),\n        ///SourceMapGenerator = require('source-map').SourceMapGenerator,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        hasProp = lang.hasProp,\n        getOwn = lang.getOwn,\n        falseProp = lang.falseProp,\n        endsWithSemiColonRegExp = /;\\s*$/,\n        endsWithSlashRegExp = /[\\/\\\\]$/,\n        resourceIsModuleIdRegExp = /^[\\w\\/\\\\\\.]+$/,\n        deepCopyProps = {\n            layer: true\n        };\n\n    //Deep copy a config object, but do not copy over the \"layer\" property,\n    //as it can be a deeply nested structure with a full requirejs context.\n    function copyConfig(obj) {\n        return lang.deeplikeCopy(obj, deepCopyProps);\n    }\n\n    prim.nextTick = function (fn) {\n        fn();\n    };\n\n    //Now map require to the outermost requirejs, now that we have\n    //local dependencies for this module. The rest of the require use is\n    //manipulating the requirejs loader.\n    ///require = requirejs;\n\n    //Caching function for performance. Attached to\n    //require so it can be reused in requirePatch.js. _cachedRawText\n    //set up by requirePatch.js\n    require._cacheReadAsync = function (path, encoding,fs) {\n        var d;\n\n        if (lang.hasProp(require._cachedRawText, path)) {\n            d = prim();\n            d.resolve(require._cachedRawText[path]);\n            return d.promise;\n        } else {\n            return fs.readFileAsync(path, encoding).then(function (text) {\n                require._cachedRawText[path] = text;\n                return text;\n            });\n        }\n    };\n\n    function makeBuildBaseConfig(fs) {\n        return {\n            appDir: \"\",\n            pragmas: {},\n            paths: {},\n            optimize: \"uglify\",\n            optimizeCss: \"standard.keepLines.keepWhitespace\",\n            inlineText: true,\n            isBuild: true,\n            optimizeAllPluginResources: false,\n            findNestedDependencies: false,\n            preserveLicenseComments: true,\n            writeBuildTxt: true,\n            //Some builds can take a while, up the default limit.\n            waitSeconds: 30,\n            //By default, all files/directories are copied, unless\n            //they match this regexp, by default just excludes .folders\n            dirExclusionRegExp: fs.dirExclusionRegExp,\n            _buildPathToModuleIndex: {}\n        };\n    }\n\n    /**\n     * Some JS may not be valid if concatenated with other JS, in particular\n     * the style of omitting semicolons and rely on ASI. Add a semicolon in\n     * those cases.\n     */\n    function addSemiColon(text, config) {\n        if (config.skipSemiColonInsertion || endsWithSemiColonRegExp.test(text)) {\n            return text;\n        } else {\n            return text + \";\";\n        }\n    }\n\n    function endsWithSlash(dirName) {\n        if (dirName.charAt(dirName.length - 1) !== \"/\") {\n            dirName += \"/\";\n        }\n        return dirName;\n    }\n\n    function endsWithNewLine(text) {\n        if (text.charAt(text.length - 1) !== \"\\n\") {\n            text += \"\\n\";\n        }\n        return text;\n    }\n\n    //Method used by plugin writeFile calls, defined up here to avoid\n    //jslint warning about \"making a function in a loop\".\n    function makeWriteFile(namespace, layer) {\n        function writeFile(name, contents) {\n            logger.trace('Saving plugin-optimized file: ' + name);\n            file.saveUtf8File(name, contents);\n        }\n\n        writeFile.asModule = function (moduleName, fileName, contents) {\n            writeFile(fileName,\n                build.toTransport(namespace, moduleName, fileName, contents, layer));\n        };\n\n        return writeFile;\n    }\n\n    /**\n     * Appends singleContents to fileContents and returns the result.  If a sourceMapGenerator\n     * is provided, adds singleContents to the source map.\n     *\n     * @param {string} fileContents - The file contents to which to append singleContents\n     * @param {string} singleContents - The additional contents to append to fileContents\n     * @param {string} path - An absolute path of a file whose name to use in the source map.\n     * The file need not actually exist if the code in singleContents is generated.\n     * @param {{out: ?string, baseUrl: ?string}} config - The build configuration object.\n     * @param {?{_buildPath: ?string}} module - An object with module information.\n     * @param {?SourceMapGenerator} sourceMapGenerator - An instance of Mozilla's SourceMapGenerator,\n     * or null if no source map is being generated.\n     * @returns {string} fileContents with singleContents appended\n     */\n    function appendToFileContents(fileContents, singleContents, path, config, module, sourceMapGenerator) {\n        var refPath, sourceMapPath, resourcePath, pluginId, sourceMapLineNumber, lineCount, parts, i;\n        if (sourceMapGenerator) {\n            if (config.out) {\n                refPath = config.baseUrl;\n            } else if (module && module._buildPath) {\n                refPath = module._buildPath;\n            } else {\n                refPath = \"\";\n            }\n            parts = path.split('!');\n            if (parts.length === 1) {\n                //Not a plugin resource, fix the path\n                sourceMapPath = build.makeRelativeFilePath(refPath, path);\n            } else {\n                //Plugin resource. If it looks like just a plugin\n                //followed by a module ID, pull off the plugin\n                //and put it at the end of the name, otherwise\n                //just leave it alone.\n                pluginId = parts.shift();\n                resourcePath = parts.join('!');\n                if (resourceIsModuleIdRegExp.test(resourcePath)) {\n                    sourceMapPath = build.makeRelativeFilePath(refPath, require.toUrl(resourcePath)) +\n                                    '!' + pluginId;\n                } else {\n                    sourceMapPath = path;\n                }\n            }\n\n            sourceMapLineNumber = fileContents.split('\\n').length - 1;\n            lineCount = singleContents.split('\\n').length;\n            for (i = 1; i <= lineCount; i += 1) {\n                sourceMapGenerator.addMapping({\n                    generated: {\n                        line: sourceMapLineNumber + i,\n                        column: 0\n                    },\n                    original: {\n                        line: i,\n                        column: 0\n                    },\n                    source: sourceMapPath\n                });\n            }\n\n            //Store the content of the original in the source\n            //map since other transforms later like minification\n            //can mess up translating back to the original\n            //source.\n            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);\n        }\n        fileContents += singleContents;\n        return fileContents;\n    }\n\n    /**\n     * Main API entry point into the build. The args argument can either be\n     * an array of arguments (like the onese passed on a command-line),\n     * or it can be a JavaScript object that has the format of a build profile\n     * file.\n     *\n     * If it is an object, then in addition to the normal properties allowed in\n     * a build profile file, the object should contain one other property:\n     *\n     * The object could also contain a \"buildFile\" property, which is a string\n     * that is the file path to a build profile that contains the rest\n     * of the build profile directives.\n     *\n     * This function does not return a status, it should throw an error if\n     * there is a problem completing the build.\n     */\n    build = function (args) {\n        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,\n            i, j, errorMod,\n            stackRegExp = /( {4}at[^\\n]+)\\n/,\n            standardIndent = '  ';\n\n        return prim().start(function () {\n            if (!args || lang.isArray(args)) {\n                if (!args || args.length < 1) {\n                    logger.error(\"build.js buildProfile.js\\n\" +\n                          \"where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).\");\n                    return undefined;\n                }\n\n                //Next args can include a build file path as well as other build args.\n                //build file path comes first. If it does not contain an = then it is\n                //a build file path. Otherwise, just all build args.\n                if (args[0].indexOf(\"=\") === -1) {\n                    buildFile = args[0];\n                    args.splice(0, 1);\n                }\n\n                //Remaining args are options to the build\n                cmdConfig = build.convertArrayToObject(args);\n                cmdConfig.buildFile = buildFile;\n            } else {\n                cmdConfig = args;\n            }\n\n            return build._run(cmdConfig);\n        }).then(null, function (e) {\n            var err;\n\n            errorMsg = e.toString();\n            errorTree = e.moduleTree;\n            stackMatch = stackRegExp.exec(errorMsg);\n\n            if (stackMatch) {\n                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);\n            }\n\n            //If a module tree that shows what module triggered the error,\n            //print it out.\n            if (errorTree && errorTree.length > 0) {\n                errorMsg += '\\nIn module tree:\\n';\n\n                for (i = errorTree.length - 1; i > -1; i--) {\n                    errorMod = errorTree[i];\n                    if (errorMod) {\n                        for (j = errorTree.length - i; j > -1; j--) {\n                            errorMsg += standardIndent;\n                        }\n                        errorMsg += errorMod + '\\n';\n                    }\n                }\n\n                logger.error(errorMsg);\n            }\n\n            errorStack = e.stack;\n\n            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {\n                errorMsg += '\\n' + errorStack;\n            } else {\n                if (!stackMatch && errorStack) {\n                    //Just trim out the first \"at\" in the stack.\n                    stackMatch = stackRegExp.exec(errorStack);\n                    if (stackMatch) {\n                        errorMsg += '\\n' + stackMatch[0] || '';\n                    }\n                }\n            }\n\n            err = new Error(errorMsg);\n            err.originalError = e;\n            throw err;\n        });\n    };\n\n    build._run = function (cmdConfig) {\n        var buildPaths, fileName, fileNames,\n            paths, i,\n            baseConfig, config,\n            modules, srcPath, buildContext,\n            destPath, moduleMap, parentModuleMap, context,\n            resources, resource, plugin, fileContents,\n            pluginProcessed = {},\n            buildFileContents = \"\",\n            pluginCollector = {},\n            fs;\n\n        return prim().start(function () {\n            var prop;\n\n            //Can now run the patches to require.js to allow it to be used for\n            //build generation. Do it here instead of at the top of the module\n            //because we want normal require behavior to load the build tool\n            //then want to switch to build mode.\n\n            config = build.createConfig(cmdConfig);\n            paths = config.paths;\n            fs = config.env.fs;\n\n            requirePatch(config);\n\n\n            //Remove the previous build dir, in case it contains source transforms,\n            //like the ones done with onBuildRead and onBuildWrite.\n            if (config.dir && !config.keepBuildDir && fs.exists(config.dir)) {\n                fs.deleteFile(config.dir);\n            }\n\n            if (!config.out && !config.cssIn) {\n                //This is not just a one-off file build but a full build profile, with\n                //lots of files to process.\n\n                //First copy all the baseUrl content\n                fs.copyDir((config.appDir || config.baseUrl), config.dir, /\\w/, true);\n\n                //Adjust baseUrl if config.appDir is in play, and set up build output paths.\n                buildPaths = {};\n                if (config.appDir) {\n                    //All the paths should be inside the appDir, so just adjust\n                    //the paths to use the dirBaseUrl\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);\n                        }\n                    }\n                } else {\n                    //If no appDir, then make sure to copy the other paths to this directory.\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            //Set up build path for each path prefix, but only do so\n                            //if the path falls out of the current baseUrl\n                            if (paths[prop].indexOf(config.baseUrl) === 0) {\n                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);\n                            } else {\n                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop;\n\n                                //Make sure source path is fully formed with baseUrl,\n                                //if it is a relative URL.\n                                srcPath = paths[prop];\n                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {\n                                    srcPath = config.baseUrl + srcPath;\n                                }\n\n                                destPath = config.dirBaseUrl + buildPaths[prop];\n\n                                //Skip empty: paths\n                                if (srcPath !== 'empty:') {\n                                    //If the srcPath is a directory, copy the whole directory.\n                                    if (fs.exists(srcPath) && fs.isDirectory(srcPath)) {\n                                        //Copy files to build area. Copy all files (the /\\w/ regexp)\n                                        fs.copyDir(srcPath, destPath, /\\w/, true);\n                                    } else {\n                                        //Try a .js extension\n                                        srcPath += '.js';\n                                        destPath += '.js';\n                                        fs.copyFile(srcPath, destPath);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            //Figure out source file location for each module layer. Do this by seeding require\n            //with source area configuration. This is needed so that later the module layers\n            //can be manually copied over to the source area, since the build may be\n            //require multiple times and the above copyDir call only copies newer files.\n            require({\n                baseUrl: config.baseUrl,\n                paths: paths,\n                packagePaths: config.packagePaths,\n                packages: config.packages\n            });\n            buildContext = require.s.contexts._;\n            modules = config.modules;\n\n            if (modules) {\n                modules.forEach(function (module) {\n                    if (module.name) {\n                        module._sourcePath = buildContext.nameToUrl(module.name);\n                        //If the module does not exist, and this is not a \"new\" module layer,\n                        //as indicated by a true \"create\" property on the module, and\n                        //it is not a plugin-loaded resource, and there is no\n                        //'rawText' containing the module's source then throw an error.\n                        if (!fs.exists(module._sourcePath) && !module.create &&\n                                module.name.indexOf('!') === -1 &&\n                                (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                            throw new Error(\"ERROR: module path does not exist: \" +\n                                            module._sourcePath + \" for module named: \" + module.name +\n                                            \". Path is relative to: \" + fs.absPath('.'));\n                        }\n                    }\n                });\n            }\n\n            if (config.out) {\n                //Just set up the _buildPath for the module layer.\n                require(config);\n                if (!config.cssIn) {\n                    config.modules[0]._buildPath = typeof config.out === 'function' ?\n                                                   'FUNCTION' : config.out;\n                }\n            } else if (!config.cssIn) {\n                //Now set up the config for require to use the build area, and calculate the\n                //build file locations. Pass along any config info too.\n                baseConfig = {\n                    baseUrl: config.dirBaseUrl,\n                    paths: buildPaths\n                };\n\n                lang.mixin(baseConfig, config);\n                require(baseConfig);\n\n                if (modules) {\n                    modules.forEach(function (module) {\n                        if (module.name) {\n                            module._buildPath = buildContext.nameToUrl(module.name, null);\n\n                            //If buildPath and sourcePath are the same, throw since this\n                            //would result in modifying source. This condition can happen\n                            //with some more tricky paths: config and appDir/baseUrl\n                            //setting, which is a sign of incorrect config.\n                            if (module._buildPath === module._sourcePath &&\n                                !config.allowSourceOverwrites) {\n                                throw new Error('Module ID \\'' + module.name  +\n                                                '\\' has a source path that is same as output path: ' +\n                                                module._sourcePath +\n                                                '. Stopping, config is malformed.');\n                            }\n\n                            // Copy the file, but only if it is not provided in rawText.\n                            if (!module.create && (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                                fs.copyFile(module._sourcePath, module._buildPath);\n                            }\n                        }\n                    });\n                }\n            }\n\n            //Run CSS optimizations before doing JS module tracing, to allow\n            //things like text loader plugins loading CSS to get the optimized\n            //CSS.\n            if (config.optimizeCss && config.optimizeCss !== \"none\" && config.dir) {\n                buildFileContents += optimize.css(config.dir, config);\n            }\n        }).then(function() {\n            baseConfig = copyConfig(require.s.contexts._.config);\n        }).then(function () {\n            var actions = [];\n\n            if (modules) {\n                actions = modules.map(function (module, i) {\n                    return function () {\n                        //Save off buildPath to module index in a hash for quicker\n                        //lookup later.\n                        config._buildPathToModuleIndex[fs.normalize(module._buildPath)] = i;\n\n                        //Call require to calculate dependencies.\n                        return build.traceDependencies(module, config, baseConfig)\n                            .then(function (layer) {\n                                module.layer = layer;\n                            });\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            var actions;\n\n            if (modules) {\n                //Now build up shadow layers for anything that should be excluded.\n                //Do this after tracing dependencies for each module, in case one\n                //of those modules end up being one of the excluded values.\n                actions = modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            module.excludeLayers = [];\n                            return prim.serial(module.exclude.map(function (exclude, i) {\n                                return function () {\n                                    //See if it is already in the list of modules.\n                                    //If not trace dependencies for it.\n                                    var found = build.findBuildModule(exclude, modules);\n                                    if (found) {\n                                        module.excludeLayers[i] = found;\n                                    } else {\n                                        return build.traceDependencies({name: exclude}, config, baseConfig)\n                                            .then(function (layer) {\n                                                module.excludeLayers[i] = { layer: layer };\n                                            });\n                                    }\n                                };\n                            }));\n                        }\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            if (modules) {\n                return prim.serial(modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            //module.exclude is an array of module names. For each one,\n                            //get the nested dependencies for it via a matching entry\n                            //in the module.excludeLayers array.\n                            module.exclude.forEach(function (excludeModule, i) {\n                                var excludeLayer = module.excludeLayers[i].layer,\n                                    map = excludeLayer.buildFileToModule;\n                                excludeLayer.buildFilePaths.forEach(function(filePath){\n                                    build.removeModulePath(map[filePath], filePath, module.layer);\n                                });\n                            });\n                        }\n                        if (module.excludeShallow) {\n                            //module.excludeShallow is an array of module names.\n                            //shallow exclusions are just that module itself, and not\n                            //its nested dependencies.\n                            module.excludeShallow.forEach(function (excludeShallowModule) {\n                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);\n                                if (path) {\n                                    build.removeModulePath(excludeShallowModule, path, module.layer);\n                                }\n                            });\n                        }\n\n                        //Flatten them and collect the build output for each module.\n                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {\n                            var finalText, baseName;\n                            //Save it to a temp file for now, in case there are other layers that\n                            //contain optimized content that should not be included in later\n                            //layer optimizations. See issue #56.\n                            if (module._buildPath === 'FUNCTION') {\n                                module._buildText = builtModule.text;\n                                module._buildSourceMap = builtModule.sourceMap;\n                            } else {\n                                finalText = builtModule.text;\n                                if (builtModule.sourceMap) {\n                                    baseName = module._buildPath.split('/');\n                                    baseName = baseName.pop();\n                                    finalText += '\\n//# sourceMappingURL=' + baseName + '.map';\n                                    fs.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);\n                                }\n                                fs.saveUtf8File(module._buildPath + '-temp', finalText);\n\n                            }\n                            buildFileContents += builtModule.buildText;\n                        });\n                    };\n                }));\n            }\n        }).then(function () {\n            var moduleName, outOrigSourceMap,\n                bundlesConfig = {},\n                bundlesConfigOutFile = config.bundlesConfigOutFile;\n\n            if (modules) {\n                //Now move the build layers to their final position.\n                modules.forEach(function (module) {\n                    var entryConfig,\n                        finalPath = module._buildPath;\n\n                    if (finalPath !== 'FUNCTION') {\n                        if (fs.exists(finalPath)) {\n                            fs.deleteFile(finalPath);\n                        }\n                        fs.renameFile(finalPath + '-temp', finalPath);\n\n                        //If bundles config should be written out, scan the\n                        //built file for module IDs. Favor doing this reparse\n                        //since tracking the IDs as the file is built has some\n                        //edge cases around files that had more than one ID in\n                        //them already, and likely loader plugin-written contents.\n                        if (bundlesConfigOutFile) {\n                            entryConfig = bundlesConfig[module.name] = [];\n                            var bundleContents = fs.readFile(finalPath);\n                            var excludeMap = {};\n                            excludeMap[module.name] = true;\n                            var parsedIds = parse.getAllNamedDefines(bundleContents, excludeMap);\n                            entryConfig.push.apply(entryConfig, parsedIds);\n                        }\n\n                        //And finally, if removeCombined is specified, remove\n                        //any of the files that were used in this layer.\n                        //Be sure not to remove other build layers.\n                        if (config.removeCombined && !config.out) {\n                            module.layer.buildFilePaths.forEach(function (path) {\n                                var isLayer = modules.some(function (mod) {\n                                        return mod._buildPath === path;\n                                    }),\n                                    relPath = build.makeRelativeFilePath(config.dir, path);\n\n                                if (fs.exists(path) &&\n                                    // not a build layer target\n                                    !isLayer &&\n                                    // not outside the build directory\n                                    relPath.indexOf('..') !== 0) {\n                                    fs.deleteFile(path);\n                                }\n                            });\n                        }\n                    }\n\n                    //Signal layer is done\n                    if (config.onModuleBundleComplete) {\n                        config.onModuleBundleComplete(module.onCompleteData);\n                    }\n                });\n\n                //Write out bundles config, if it is wanted.\n                if (bundlesConfigOutFile) {\n                    var text = fs.readFile(bundlesConfigOutFile);\n                    text = transform.modifyConfig(text, function (config) {\n                        if (!config.bundles) {\n                            config.bundles = {};\n                        }\n\n                        lang.eachProp(bundlesConfig, function (value, prop) {\n                            config.bundles[prop] = value;\n                        });\n\n                        return config;\n                    });\n\n                    fs.saveUtf8File(bundlesConfigOutFile, text);\n                }\n            }\n\n            //If removeCombined in play, remove any empty directories that\n            //may now exist because of its use\n            if (config.removeCombined && !config.out && config.dir) {\n                fs.deleteEmptyDirs(config.dir);\n            }\n\n            //Do other optimizations.\n            if (config.out && !config.cssIn) {\n                //Just need to worry about one JS file.\n                fileName = config.modules[0]._buildPath;\n                if (fileName === 'FUNCTION') {\n                    outOrigSourceMap = config.modules[0]._buildSourceMap;\n                    config._buildSourceMap = outOrigSourceMap;\n                    config.modules[0]._buildText = optimize.js((config.modules[0].name ||\n                                                                config.modules[0].include[0] ||\n                                                                fileName) + '.build.js',\n                                                               config.modules[0]._buildText,\n                                                               null,\n                                                               config);\n                    if (config._buildSourceMap && config._buildSourceMap !== outOrigSourceMap) {\n                        config.modules[0]._buildSourceMap = config._buildSourceMap;\n                        config._buildSourceMap = null;\n                    }\n                } else {\n                    optimize.jsFile(fileName, null, fileName, config);\n                }\n            } else if (!config.cssIn) {\n                //Normal optimizations across modules.\n\n                //JS optimizations.\n                fileNames = fs.getFilteredFileList(config.dir, /\\.js$/, true);\n                fileNames.forEach(function (fileName) {\n                    var cfg, override, moduleIndex;\n\n                    //Generate the module name from the config.dir root.\n                    moduleName = fileName.replace(config.dir, '');\n                    //Get rid of the extension\n                    moduleName = moduleName.substring(0, moduleName.length - 3);\n\n                    //If there is an override for a specific layer build module,\n                    //and this file is that module, mix in the override for use\n                    //by optimize.jsFile.\n                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);\n                    //Normalize, since getOwn could have returned undefined\n                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;\n\n                    //Try to avoid extra work if the other files do not need to\n                    //be read. Build layers should be processed at the very\n                    //least for optimization.\n                    if (moduleIndex > -1 || !config.skipDirOptimize ||\n                            config.normalizeDirDefines === \"all\" ||\n                            config.cjsTranslate) {\n                        //Convert the file to transport format, but without a name\n                        //inserted (by passing null for moduleName) since the files are\n                        //standalone, one module per file.\n                        fileContents = fs.readFile(fileName);\n\n\n                        //For builds, if wanting cjs translation, do it now, so that\n                        //the individual modules can be loaded cross domain via\n                        //plain script tags.\n                        if (config.cjsTranslate &&\n                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                            fileContents = commonJs.convert(fileName, fileContents);\n                        }\n\n                        if (moduleIndex === -1) {\n                            if (config.onBuildRead) {\n                                fileContents = config.onBuildRead(moduleName,\n                                                                  fileName,\n                                                                  fileContents);\n                            }\n\n                            //Only do transport normalization if this is not a build\n                            //layer (since it was already normalized) and if\n                            //normalizeDirDefines indicated all should be done.\n                            if (config.normalizeDirDefines === \"all\") {\n                                fileContents = build.toTransport(config.namespace,\n                                                             null,\n                                                             fileName,\n                                                             fileContents);\n                            }\n\n                            if (config.onBuildWrite) {\n                                fileContents = config.onBuildWrite(moduleName,\n                                                                   fileName,\n                                                                   fileContents);\n                            }\n                        }\n\n                        override = moduleIndex > -1 ?\n                                   config.modules[moduleIndex].override : null;\n                        if (override) {\n                            cfg = build.createOverrideConfig(config, override);\n                        } else {\n                            cfg = config;\n                        }\n\n                        if (moduleIndex > -1 || !config.skipDirOptimize) {\n                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);\n                        }\n                    }\n                });\n\n                //Normalize all the plugin resources.\n                context = require.s.contexts._;\n\n                for (moduleName in pluginCollector) {\n                    if (hasProp(pluginCollector, moduleName)) {\n                        parentModuleMap = context.makeModuleMap(moduleName);\n                        resources = pluginCollector[moduleName];\n                        for (i = 0; i < resources.length; i++) {\n                            resource = resources[i];\n                            moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            if (falseProp(context.plugins, moduleMap.prefix)) {\n                                //Set the value in context.plugins so it\n                                //will be evaluated as a full plugin.\n                                context.plugins[moduleMap.prefix] = true;\n\n                                //Do not bother if the plugin is not available.\n                                if (!fs.exists(require.toUrl(moduleMap.prefix + '.js'))) {\n                                    continue;\n                                }\n\n                                //Rely on the require in the build environment\n                                //to be synchronous\n                                context.require([moduleMap.prefix]);\n\n                                //Now that the plugin is loaded, redo the moduleMap\n                                //since the plugin will need to normalize part of the path.\n                                moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            }\n\n                            //Only bother with plugin resources that can be handled\n                            //processed by the plugin, via support of the writeFile\n                            //method.\n                            if (falseProp(pluginProcessed, moduleMap.id)) {\n                                //Only do the work if the plugin was really loaded.\n                                //Using an internal access because the file may\n                                //not really be loaded.\n                                plugin = getOwn(context.defined, moduleMap.prefix);\n                                if (plugin && plugin.writeFile) {\n                                    plugin.writeFile(\n                                        moduleMap.prefix,\n                                        moduleMap.name,\n                                        require,\n                                        makeWriteFile(\n                                            config.namespace\n                                        ),\n                                        context.config\n                                    );\n                                }\n\n                                pluginProcessed[moduleMap.id] = true;\n                            }\n                        }\n\n                    }\n                }\n\n                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, \"  \"));\n\n\n                //All module layers are done, write out the build.txt file.\n                if (config.writeBuildTxt) {\n                    fs.saveUtf8File(config.dir + \"build.txt\", buildFileContents);\n                }\n            }\n\n            //If just have one CSS file to optimize, do that here.\n            if (config.cssIn) {\n                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;\n            }\n\n            if (typeof config.out === 'function') {\n                config.out(config.modules[0]._buildText, config.modules[0]._buildSourceMap);\n            }\n\n            //Print out what was built into which layers.\n            if (buildFileContents) {\n                logger.info(buildFileContents);\n                return buildFileContents;\n            }\n\n            return '';\n        });\n    };\n\n    /**\n     * Converts command line args like \"paths.foo=../some/path\"\n     * result.paths = { foo: '../some/path' } where prop = paths,\n     * name = paths.foo and value = ../some/path, so it assumes the\n     * name=value splitting has already happened.\n     */\n    function stringDotToObj(result, name, value) {\n        var parts = name.split('.');\n\n        parts.forEach(function (prop, i) {\n            if (i === parts.length - 1) {\n                result[prop] = value;\n            } else {\n                if (falseProp(result, prop)) {\n                    result[prop] = {};\n                }\n                result = result[prop];\n            }\n\n        });\n    }\n\n    build.objProps = {\n        paths: true,\n        wrap: true,\n        pragmas: true,\n        pragmasOnSave: true,\n        has: true,\n        hasOnSave: true,\n        uglify: true,\n        uglify2: true,\n        closure: true,\n        map: true,\n        throwWhen: true,\n        rawText: true\n    };\n\n    build.hasDotPropMatch = function (prop) {\n        var dotProp,\n            index = prop.indexOf('.');\n\n        if (index !== -1) {\n            dotProp = prop.substring(0, index);\n            return hasProp(build.objProps, dotProp);\n        }\n        return false;\n    };\n\n    /**\n     * Converts an array that has String members of \"name=value\"\n     * into an object, where the properties on the object are the names in the array.\n     * Also converts the strings \"true\" and \"false\" to booleans for the values.\n     * member name/value pairs, and converts some comma-separated lists into\n     * arrays.\n     * @param {Array} ary\n     */\n    build.convertArrayToObject = function (ary) {\n        var result = {}, i, separatorIndex, prop, value,\n            needArray = {\n                \"include\": true,\n                \"exclude\": true,\n                \"excludeShallow\": true,\n                \"insertRequire\": true,\n                \"stubModules\": true,\n                \"deps\": true,\n                \"mainConfigFile\": true,\n                \"wrap.startFile\": true,\n                \"wrap.endFile\": true\n            };\n\n        for (i = 0; i < ary.length; i++) {\n            separatorI.ndex = ary[i].indexOf(\"=\");\n            if (separatorIndex === -1) {\n                throw \"Malformed name/value pair: [\" + ary[i] + \"]. Format should be name=value\";\n            }\n\n            value = ary[i].substring(separatorIndex + 1, ary[i].length);\n            if (value === \"true\") {\n                value = true;\n            } else if (value === \"false\") {\n                value = false;\n            }\n\n            prop = ary[i].substring(0, separatorIndex);\n\n            //Convert to array if necessary\n            if (getOwn(needArray, prop)) {\n                value = value.split(\",\");\n            }\n\n            if (build.hasDotPropMatch(prop)) {\n                stringDotToObj(result, prop, value);\n            } else {\n                result[prop] = value;\n            }\n        }\n        return result; //Object\n    };\n\n    build.makeAbsPath = function (path, absFilePath,fs) {\n        if (!absFilePath) {\n            return path;\n        }\n\n        //Add abspath if necessary. If path starts with a slash or has a colon,\n        //then already is an abolute path.\n        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {\n            path = absFilePath +\n                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +\n                   path;\n            path = fs.normalize(path);\n        }\n        return path.replace(lang.backSlashRegExp, '/');\n    };\n\n    build.makeAbsObject = function (props, obj, absFilePath,fs) {\n        var i, prop;\n        if (obj) {\n            for (i = 0; i < props.length; i++) {\n                prop = props[i];\n                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {\n                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath,fs);\n                }\n            }\n        }\n    };\n\n    /**\n     * For any path in a possible config, make it absolute relative\n     * to the absFilePath passed in.\n     */\n    build.makeAbsConfig = function (config, absFilePath,fs) {\n        var props, prop, i;\n\n        props = [\"appDir\", \"dir\", \"baseUrl\"];\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n\n            if (getOwn(config, prop)) {\n                //Add abspath if necessary, make sure these paths end in\n                //slashes\n                if (prop === \"baseUrl\") {\n                    config.originalBaseUrl = config.baseUrl;\n                    if (config.appDir) {\n                        //If baseUrl with an appDir, the baseUrl is relative to\n                        //the appDir, *not* the absFilePath. appDir and dir are\n                        //made absolute before baseUrl, so this will work.\n                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir,fs);\n                    } else {\n                        //The dir output baseUrl is same as regular baseUrl, both\n                        //relative to the absFilePath.\n                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath,fs);\n                    }\n                } else {\n                    config[prop] = build.makeAbsPath(config[prop], absFilePath,fs);\n                }\n\n                config[prop] = endsWithSlash(config[prop]);\n            }\n        }\n\n        build.makeAbsObject((config.out === \"stdout\" ? [\"cssIn\"] : [\"out\", \"cssIn\"]),\n                            config, absFilePath,fs);\n        build.makeAbsObject([\"startFile\", \"endFile\"], config.wrap, absFilePath,fs);\n        build.makeAbsObject([\"externExportsPath\"], config.closure, absFilePath,fs);\n    };\n\n    /**\n     * Creates a relative path to targetPath from refPath.\n     * Only deals with file paths, not folders. If folders,\n     * make sure paths end in a trailing '/'.\n     */\n    build.makeRelativeFilePath = function (refPath, targetPath,fs) {\n        var i, dotLength, finalParts, length, targetParts, targetName,\n            refParts = refPath.split('/'),\n            hasEndSlash = endsWithSlashRegExp.test(targetPath),\n            dotParts = [];\n\n        targetPath = fs.normalize(targetPath);\n        if (hasEndSlash && !endsWithSlashRegExp.test(targetPath)) {\n            targetPath += '/';\n        }\n        targetParts = targetPath.split('/');\n        //Pull off file name\n        targetName = targetParts.pop();\n\n        //Also pop off the ref file name to make the matches against\n        //targetParts equivalent.\n        refParts.pop();\n\n        length = refParts.length;\n\n        for (i = 0; i < length; i += 1) {\n            if (refParts[i] !== targetParts[i]) {\n                break;\n            }\n        }\n\n        //Now i is the index in which they diverge.\n        finalParts = targetParts.slice(i);\n\n        dotLength = length - i;\n        for (i = 0; i > -1 && i < dotLength; i += 1) {\n            dotParts.push('..');\n        }\n\n        return dotParts.join('/') + (dotParts.length ? '/' : '') +\n               finalParts.join('/') + (finalParts.length ? '/' : '') +\n               targetName;\n    };\n\n    build.nestedMix = {\n        paths: true,\n        has: true,\n        hasOnSave: true,\n        pragmas: true,\n        pragmasOnSave: true\n    };\n\n    /**\n     * Mixes additional source config into target config, and merges some\n     * nested config, like paths, correctly.\n     */\n    function mixConfig(target, source, skipArrays) {\n        var prop, value, isArray, targetValue;\n\n        for (prop in source) {\n            if (hasProp(source, prop)) {\n                //If the value of the property is a plain object, then\n                //allow a one-level-deep mixing of it.\n                value = source[prop];\n                isArray = lang.isArray(value);\n                if (typeof value === 'object' && value &&\n                        !isArray && !lang.isFunction(value) &&\n                        !lang.isRegExp(value)) {\n\n                    // TODO: need to generalize this work, maybe also reuse\n                    // the work done in requirejs configure, perhaps move to\n                    // just a deep copy/merge overall. However, given the\n                    // amount of observable change, wait for a dot release.\n                    // This change is in relation to #645\n                    if (prop === 'map') {\n                        if (!target.map) {\n                            target.map = {};\n                        }\n                        lang.deepMix(target.map, source.map);\n                    } else {\n                        target[prop] = lang.mixin({}, target[prop], value, true);\n                    }\n                } else if (isArray) {\n                    if (!skipArrays) {\n                        // Some config, like packages, are arrays. For those,\n                        // just merge the results.\n                        targetValue = target[prop];\n                        if (lang.isArray(targetValue)) {\n                            target[prop] = targetValue.concat(value);\n                        } else {\n                            target[prop] = value;\n                        }\n                    }\n                } else {\n                    target[prop] = value;\n                }\n            }\n        }\n\n        //Set up log level since it can affect if errors are thrown\n        //or caught and passed to errbacks while doing config setup.\n        if (lang.hasProp(target, 'logLevel')) {\n            logger.logLevel(target.logLevel);\n        }\n    }\n\n    /**\n     * Converts a wrap.startFile or endFile to be start/end as a string.\n     * the startFile/endFile values can be arrays.\n     */\n    function flattenWrapFile(config, keyName, absFilePath) {\n        var wrap = config.wrap,\n            keyFileName = keyName + 'File',\n            keyMapName = '__' + keyName + 'Map',\n            fs = config.env.fs;\n\n        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {\n            wrap[keyName] = '';\n            if (typeof wrap[keyFileName] === 'string') {\n                wrap[keyFileName] = [wrap[keyFileName]];\n            }\n            wrap[keyMapName] = [];\n            wrap[keyFileName].forEach(function (fileName) {\n                var absPath = build.makeAbsPath(fileName, absFilePath,fs),\n                    fileText = endsWithNewLine(fs.readFile(absPath));\n                wrap[keyMapName].push(function (fileContents, cfg, sourceMapGenerator) {\n                    return appendToFileContents(fileContents, fileText, absPath, cfg, null, sourceMapGenerator);\n                });\n                wrap[keyName] += fileText;\n            });\n        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {\n            //Allow missing one, just set to empty string.\n            wrap[keyName] = '';\n        } else if (typeof wrap[keyName] === 'string') {\n            wrap[keyName] = endsWithNewLine(wrap[keyName]);\n            wrap[keyMapName] = [\n                function (fileContents, cfg, sourceMapGenerator) {\n                    var absPath = build.makeAbsPath(\"config-wrap-\" + keyName + \"-default.js\", absFilePath,fs);\n                    return appendToFileContents(fileContents, wrap[keyName], absPath, cfg, null, sourceMapGenerator);\n                }\n            ];\n        } else {\n            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');\n        }\n    }\n\n    function normalizeWrapConfig(config, absFilePath) {\n        //Get any wrap text.\n        var fs = config.env.fs;\n        try {\n            if (config.wrap) {\n                if (config.wrap === true) {\n                    //Use default values.\n                    config.wrap = {\n                        start: '(function () {\\n',\n                        end: '}());',\n                        __startMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"(function () {\\n\",\n                                                            build.makeAbsPath(\"config-wrap-start-default.js\",\n                                                                              absFilePath,fs), cfg, null,\n                                                            sourceMapGenerator);\n                            }\n                        ],\n                        __endMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"}());\",\n                                                            build.makeAbsPath(\"config-wrap-end-default.js\", absFilePath,fs),\n                                                            cfg, null, sourceMapGenerator);\n                            }\n                        ]\n                    };\n                } else {\n                    flattenWrapFile(config, 'start', absFilePath);\n                    flattenWrapFile(config, 'end', absFilePath);\n                }\n            }\n        } catch (wrapError) {\n            throw new Error('Malformed wrap config: ' + wrapError.toString());\n        }\n    }\n\n    /**\n     * Creates a config object for an optimization build.\n     * It will also read the build profile if it is available, to create\n     * the configuration.\n     *\n     * @param {Object} cfg config options that take priority\n     * over defaults and ones in the build file. These options could\n     * be from a command line, for instance.\n     *\n     * @param {Object} the created config object.\n     */\n    build.createConfig = function (cfg) {\n        /*jslint evil: true */\n        var fs = cfg.env.fs;\n\n        var buildFileContents, buildFileConfig, mainConfig,\n            mainConfigFile, mainConfigPath, buildFile, absFilePath,\n            config = {},\n            buildBaseConfig = makeBuildBaseConfig(fs);\n\n\n        //Make sure all paths are relative to current directory.\n\n        absFilePath = fs.absPath('.');\n        build.makeAbsConfig(cfg, absFilePath,fs);\n        build.makeAbsConfig(buildBaseConfig, absFilePath,fs);\n\n        lang.mixin(config, buildBaseConfig);\n        lang.mixin(config, cfg, true);\n\n\n        //Set up log level early since it can affect if errors are thrown\n        //or caught and passed to errbacks, even while constructing config.\n        if (lang.hasProp(config, 'logLevel')) {\n            logger.logLevel(config.logLevel);\n        }\n\n        if (config.buildFile) {\n            //A build file exists, load it to get more config.\n            buildFile = fs.absPath(config.buildFile);\n\n            //Find the build file, and make sure it exists, if this is a build\n            //that has a build profile, and not just command line args with an in=path\n            if (!fs.exists(buildFile)) {\n                throw new Error(\"ERROR: build file does not exist: \" + buildFile);\n            }\n\n            absFilePath = config.baseUrl = fs.absPath(fs.parent(buildFile));\n\n            //Load build file options.\n            buildFileContents = fs.readFile(buildFile);\n            try {\n                //Be a bit lenient in the file ending in a ; or ending with\n                //a //# sourceMappingUrl comment, mostly for compiled languages\n                //that create a config, like typescript.\n                buildFileContents = buildFileContents\n                                    .replace(/\\/\\/\\#[^\\n\\r]+[\\n\\r]*$/, '')\n                                    .trim()\n                                    .replace(/;$/, '');\n\n                buildFileConfig = eval(\"(\" + buildFileContents + \")\");\n                build.makeAbsConfig(buildFileConfig, absFilePath,fs);\n\n                //Mix in the config now so that items in mainConfigFile can\n                //be resolved relative to them if necessary, like if appDir\n                //is set here, but the baseUrl is in mainConfigFile. Will\n                //re-mix in the same build config later after mainConfigFile\n                //is processed, since build config should take priority.\n                mixConfig(config, buildFileConfig);\n            } catch (e) {\n                throw new Error(\"Build file \" + buildFile + \" is malformed: \" + e);\n            }\n        }\n\n        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);\n        if (mainConfigFile) {\n            if (typeof mainConfigFile === 'string') {\n                mainConfigFile = [mainConfigFile];\n            }\n\n            mainConfigFile.forEach(function (configFile) {\n                configFile = build.makeAbsPath(configFile, absFilePath,fs);\n                if (!fs.exists(configFile)) {\n                    throw new Error(configFile + ' does not exist.');\n                }\n                try {\n                    mainConfig = parse.findConfig(fs.readFile(configFile)).config;\n                } catch (configError) {\n                    throw new Error('The config in mainConfigFile ' +\n                            configFile +\n                            ' cannot be used because it cannot be evaluated' +\n                            ' correctly while running in the optimizer. Try only' +\n                            ' using a config that is also valid JSON, or do not use' +\n                            ' mainConfigFile and instead copy the config values needed' +\n                            ' into a build file or command line arguments given to the optimizer.\\n' +\n                            'Source error from parsing: ' + configFile + ': ' + configError);\n                }\n                if (mainConfig) {\n                    mainConfigPath = configFile.substring(0, configFile.lastIndexOf('/'));\n\n                    //Add in some existing config, like appDir, since they can be\n                    //used inside the configFile -- paths and baseUrl are\n                    //relative to them.\n                    if (config.appDir && !mainConfig.appDir) {\n                        mainConfig.appDir = config.appDir;\n                    }\n\n                    //If no baseUrl, then use the directory holding the main config.\n                    if (!mainConfig.baseUrl) {\n                        mainConfig.baseUrl = mainConfigPath;\n                    }\n\n                    build.makeAbsConfig(mainConfig, mainConfigPath,fs);\n                    mixConfig(config, mainConfig);\n                }\n            });\n        }\n\n        //Mix in build file config, but only after mainConfig has been mixed in.\n        //Since this is a re-application, skip array merging.\n        if (buildFileConfig) {\n            mixConfig(config, buildFileConfig, true);\n        }\n\n        //Re-apply the override config values. Command line\n        //args should take precedence over build file values.\n        //Since this is a re-application, skip array merging.\n        mixConfig(config, cfg, true);\n\n        //Fix paths to full paths so that they can be adjusted consistently\n        //lately to be in the output area.\n        lang.eachProp(config.paths, function (value, prop) {\n            if (lang.isArray(value)) {\n                throw new Error('paths fallback not supported in optimizer. ' +\n                                'Please provide a build config path override ' +\n                                'for ' + prop);\n            }\n            config.paths[prop] = build.makeAbsPath(value, config.baseUrl,fs);\n        });\n\n        //Set final output dir\n        if (hasProp(config, \"baseUrl\")) {\n            if (config.appDir) {\n                if (!config.originalBaseUrl) {\n                    throw new Error('Please set a baseUrl in the build config');\n                }\n                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir,fs);\n            } else {\n                config.dirBaseUrl = config.dir || config.baseUrl;\n            }\n            //Make sure dirBaseUrl ends in a slash, since it is\n            //concatenated with other strings.\n            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);\n        }\n\n        if (config.bundlesConfigOutFile) {\n            if (!config.dir) {\n                throw new Error('bundlesConfigOutFile can only be used with optimizations ' +\n                                'that use \"dir\".');\n            }\n            config.bundlesConfigOutFile = build.makeAbsPath(config.bundlesConfigOutFile, config.dir,fs);\n        }\n\n        //If out=stdout, write output to STDOUT instead of a file.\n        ///if (config.out && config.out === 'stdout') {\n        ///    config.out = function (content) {\n        ///        var e = env.get();\n        ///        if (e === 'rhino') {\n        ///            var out = new java.io.PrintStream(java.lang.System.out, true, 'UTF-8');\n        ///            out.println(content);\n        ///        } else if (e === 'node') {\n        ///            process.stdout.write(content, 'utf8');\n        ///        } else {\n        ///            console.log(content);\n        ///        }\n        ///    };\n        ///}\n\n        //Check for errors in config\n        if (config.main) {\n            throw new Error('\"main\" passed as an option, but the ' +\n                            'supported option is called \"name\".');\n        }\n        if (config.out && !config.name && !config.modules && !config.include &&\n                !config.cssIn) {\n            throw new Error('Missing either a \"name\", \"include\" or \"modules\" ' +\n                            'option');\n        }\n        if (config.cssIn) {\n            if (config.dir || config.appDir) {\n                throw new Error('cssIn is only for the output of single file ' +\n                    'CSS optimizations and is not compatible with \"dir\" or \"appDir\" configuration.');\n            }\n            if (!config.out) {\n                throw new Error('\"out\" option missing.');\n            }\n        }\n        if (!config.cssIn && !config.baseUrl) {\n            //Just use the current directory as the baseUrl\n            config.baseUrl = './';\n        }\n        if (!config.out && !config.dir) {\n            throw new Error('Missing either an \"out\" or \"dir\" config value. ' +\n                            'If using \"appDir\" for a full project optimization, ' +\n                            'use \"dir\". If you want to optimize to one file, ' +\n                            'use \"out\".');\n        }\n        if (config.appDir && config.out) {\n            throw new Error('\"appDir\" is not compatible with \"out\". Use \"dir\" ' +\n                            'instead. appDir is used to copy whole projects, ' +\n                            'where \"out\" with \"baseUrl\" is used to just ' +\n                            'optimize to one file.');\n        }\n        if (config.out && config.dir) {\n            throw new Error('The \"out\" and \"dir\" options are incompatible.' +\n                            ' Use \"out\" if you are targeting a single file' +\n                            ' for optimization, and \"dir\" if you want the appDir' +\n                            ' or baseUrl directories optimized.');\n        }\n\n\n        if (config.dir) {\n            // Make sure the output dir is not set to a parent of the\n            // source dir or the same dir, as it will result in source\n            // code deletion.\n            if (!config.allowSourceOverwrites && (config.dir === config.baseUrl ||\n                config.dir === config.appDir ||\n                (config.baseUrl && build.makeRelativeFilePath(config.dir,\n                                           config.baseUrl,fs).indexOf('..') !== 0) ||\n                (config.appDir &&\n                    build.makeRelativeFilePath(config.dir, config.appDir,fs).indexOf('..') !== 0))) {\n                throw new Error('\"dir\" is set to a parent or same directory as' +\n                                ' \"appDir\" or \"baseUrl\". This can result in' +\n                                ' the deletion of source code. Stopping. If' +\n                                ' you want to allow possible overwriting of' +\n                                ' source code, set \"allowSourceOverwrites\"' +\n                                ' to true in the build config, but do so at' +\n                                ' your own risk. In that case, you may want' +\n                                ' to also set \"keepBuildDir\" to true.');\n            }\n        }\n\n        if (config.insertRequire && !lang.isArray(config.insertRequire)) {\n            throw new Error('insertRequire should be a list of module IDs' +\n                            ' to insert in to a require([]) call.');\n        }\n\n        //Support older configs with uglify2 settings, but now that uglify1 has\n        //been removed, just translate it to 'uglify' settings.\n        if (config.optimize === 'uglify2') {\n            config.optimize = 'uglify';\n        }\n        if (config.uglify2) {\n            config.uglify = config.uglify2;\n            delete config.uglify2;\n        }\n\n        if (config.generateSourceMaps) {\n            if (config.preserveLicenseComments && !(config.optimize === 'none' || config.optimize === 'uglify')) {\n                throw new Error('Cannot use preserveLicenseComments and ' +\n                    'generateSourceMaps together, unless optimize is set ' +\n                    'to \\'uglify\\'. Either explicitly set preserveLicenseComments ' +\n                    'to false (default is true) or turn off generateSourceMaps. ' +\n                    'If you want source maps with license comments, see: ' +\n                    'http://requirejs.org/docs/errors.html#sourcemapcomments');\n            } else if (config.optimize !== 'none' &&\n                       config.optimize !== 'closure' &&\n                       config.optimize !== 'uglify') {\n                //Allow optimize: none to pass, since it is useful when toggling\n                //minification on and off to debug something, and it implicitly\n                //works, since it does not need a source map.\n                throw new Error('optimize: \"' + config.optimize +\n                    '\" does not support generateSourceMaps.');\n            }\n        }\n\n        if ((config.name || config.include) && !config.modules) {\n            //Just need to build one file, but may be part of a whole appDir/\n            //baseUrl copy, but specified on the command line, so cannot do\n            //the modules array setup. So create a modules section in that\n            //case.\n            config.modules = [\n                {\n                    name: config.name,\n                    out: config.out,\n                    create: config.create,\n                    include: config.include,\n                    exclude: config.exclude,\n                    excludeShallow: config.excludeShallow,\n                    insertRequire: config.insertRequire,\n                    stubModules: config.stubModules\n                }\n            ];\n            delete config.stubModules;\n        } else if (config.modules && config.out) {\n            throw new Error('If the \"modules\" option is used, then there ' +\n                            'should be a \"dir\" option set and \"out\" should ' +\n                            'not be used since \"out\" is only for single file ' +\n                            'optimization output.');\n        } else if (config.modules && config.name) {\n            throw new Error('\"name\" and \"modules\" options are incompatible. ' +\n                            'Either use \"name\" if doing a single file ' +\n                            'optimization, or \"modules\" if you want to target ' +\n                            'more than one file for optimization.');\n        }\n\n        if (config.out && !config.cssIn) {\n            //Just one file to optimize.\n\n            //Does not have a build file, so set up some defaults.\n            //Optimizing CSS should not be allowed, unless explicitly\n            //asked for on command line. In that case the only task is\n            //to optimize a CSS file.\n            if (!cfg.optimizeCss) {\n                config.optimizeCss = \"none\";\n            }\n        }\n\n        //Normalize cssPrefix\n        if (config.cssPrefix) {\n            //Make sure cssPrefix ends in a slash\n            config.cssPrefix = endsWithSlash(config.cssPrefix);\n        } else {\n            config.cssPrefix = '';\n        }\n\n        //Cycle through modules and normalize\n        if (config.modules && config.modules.length) {\n            config.modules.forEach(function (mod) {\n                if (lang.isArray(mod) || typeof mod === 'string' || !mod) {\n                    throw new Error('modules config item is malformed: it should' +\n                                    ' be an object with a \\'name\\' property.');\n                }\n\n                //Combine any local stubModules with global values.\n                if (config.stubModules) {\n                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);\n                }\n\n                //Create a hash lookup for the stubModules config to make lookup\n                //cheaper later.\n                if (mod.stubModules) {\n                    mod.stubModules._byName = {};\n                    mod.stubModules.forEach(function (id) {\n                        mod.stubModules._byName[id] = true;\n                    });\n                }\n\n                // Legacy command support, which allowed a single string ID\n                // for include.\n                if (typeof mod.include === 'string') {\n                    mod.include = [mod.include];\n                }\n\n                //Allow wrap config in overrides, but normalize it.\n                if (mod.override) {\n                    normalizeWrapConfig(mod.override, absFilePath);\n                }\n            });\n        }\n\n        normalizeWrapConfig(config, absFilePath);\n\n        //Do final input verification\n        if (config.context) {\n            throw new Error('The build argument \"context\" is not supported' +\n                            ' in a build. It should only be used in web' +\n                            ' pages.');\n        }\n\n        //Set up normalizeDirDefines. If not explicitly set, if optimize \"none\",\n        //set to \"skip\" otherwise set to \"all\".\n        if (!hasProp(config, 'normalizeDirDefines')) {\n            if (config.optimize === 'none' || config.skipDirOptimize) {\n                config.normalizeDirDefines = 'skip';\n            } else {\n                config.normalizeDirDefines = 'all';\n            }\n        }\n\n        //Set fs.fileExclusionRegExp if desired\n        if (hasProp(config, 'fileExclusionRegExp')) {\n            if (typeof config.fileExclusionRegExp === \"string\") {\n                fs.exclusionRegExp = new RegExp(config.fileExclusionRegExp);\n            } else {\n                fs.exclusionRegExp = config.fileExclusionRegExp;\n            }\n        } else if (hasProp(config, 'dirExclusionRegExp')) {\n            //Set fs.dirExclusionRegExp if desired, this is the old\n            //name for fileExclusionRegExp before 1.0.2. Support for backwards\n            //compatibility\n            fs.exclusionRegExp = config.dirExclusionRegExp;\n        }\n\n        //Track the deps, but in a different key, so that they are not loaded\n        //as part of config seeding before all config is in play (#648). Was\n        //going to merge this in with \"include\", but include is added after\n        //the \"name\" target. To preserve what r.js has done previously, make\n        //sure \"deps\" comes before the \"name\".\n        if (config.deps) {\n            config._depsInclude = config.deps;\n        }\n\n\n        //Remove things that may cause problems in the build.\n        //deps already merged above\n        delete config.deps;\n        delete config.jQuery;\n        delete config.enforceDefine;\n        delete config.urlArgs;\n\n        return config;\n    };\n\n    /**\n     * finds the module being built/optimized with the given moduleName,\n     * or returns null.\n     * @param {String} moduleName\n     * @param {Array} modules\n     * @returns {Object} the module object from the build profile, or null.\n     */\n    build.findBuildModule = function (moduleName, modules) {\n        var i, module;\n        for (i = 0; i < modules.length; i++) {\n            module = modules[i];\n            if (module.name === moduleName) {\n                return module;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Removes a module name and path from a layer, if it is supposed to be\n     * excluded from the layer.\n     * @param {String} moduleName the name of the module\n     * @param {String} path the file path for the module\n     * @param {Object} layer the layer to remove the module/path from\n     */\n    build.removeModulePath = function (module, path, layer) {\n        var index = layer.buildFilePaths.indexOf(path);\n        if (index !== -1) {\n            layer.buildFilePaths.splice(index, 1);\n        }\n    };\n\n    /**\n     * Uses the module build config object to trace the dependencies for the\n     * given module.\n     *\n     * @param {Object} module the module object from the build config info.\n     * @param {Object} config the build config object.\n     * @param {Object} [baseLoaderConfig] the base loader config to use for env resets.\n     *\n     * @returns {Object} layer information about what paths and modules should\n     * be in the flattened module.\n     */\n    build.traceDependencies = function (module, config, baseLoaderConfig) {\n        var include, override, layer, context, oldContext,\n            rawTextByIds,\n            syncChecks = {\n                rhino: true,\n                node: true,\n                xpconnect: true\n            },\n            deferred = prim();\n\n        //Reset some state set up in requirePatch.js, and clean up require's\n        //current context.\n        oldContext = require._buildReset();\n\n        //Grab the reset layer and context after the reset, but keep the\n        //old config to reuse in the new context.\n        layer = require._layer;\n        context = layer.context;\n\n        //Put back basic config, use a fresh object for it.\n        if (baseLoaderConfig) {\n            require(copyConfig(baseLoaderConfig));\n        }\n\n        logger.trace(\"\\nTracing dependencies for: \" + (module.name ||\n                     (typeof module.out === 'function' ? 'FUNCTION' : module.out)));\n        include = config._depsInclude ||  [];\n        include = include.concat(module.name && !module.create ? [module.name] : []);\n        if (module.include) {\n            include = include.concat(module.include);\n        }\n\n        //If there are overrides to basic config, set that up now.;\n        if (module.override) {\n            if (baseLoaderConfig) {\n                override = build.createOverrideConfig(baseLoaderConfig, module.override);\n            } else {\n                override = copyConfig(module.override);\n            }\n            require(override);\n        }\n\n        //Now, populate the rawText cache with any values explicitly passed in\n        //via config.\n        rawTextByIds = require.s.contexts._.config.rawText;\n        if (rawTextByIds) {\n            lang.eachProp(rawTextByIds, function (contents, id) {\n                var url = require.toUrl(id) + '.js';\n                require._cachedRawText[url] = contents;\n            });\n        }\n\n\n        //Configure the callbacks to be called.\n        deferred.reject.__requireJsBuild = true;\n\n        //Use a wrapping function so can check for errors.\n        function includeFinished(value) {\n            //If a sync build environment, check for errors here, instead of\n            //in the then callback below, since some errors, like two IDs pointed\n            //to same URL but only one anon ID will leave the loader in an\n            //unresolved state since a setTimeout cannot be used to check for\n            //timeout.\n            var hasError = false;\n            if (syncChecks[config.env.name]) {\n                try {\n                    build.checkForErrors(context, layer);\n                } catch (e) {\n                    hasError = true;\n                    deferred.reject(e);\n                }\n            }\n\n            if (!hasError) {\n                deferred.resolve(value);\n            }\n        }\n        includeFinished.__requireJsBuild = true;\n\n        //Figure out module layer dependencies by calling require to do the work.\n        require(include, includeFinished, deferred.reject);\n\n        // If a sync env, then with the \"two IDs to same anon module path\"\n        // issue, the require never completes, need to check for errors\n        // here.\n        if (syncChecks[config.env.name]) {\n            build.checkForErrors(context, layer);\n        }\n\n        return deferred.promise.then(function () {\n            //Reset config\n            if (module.override && baseLoaderConfig) {\n                require(copyConfig(baseLoaderConfig));\n            }\n\n            build.checkForErrors(context, layer);\n\n            return layer;\n        });\n    };\n\n    build.checkForErrors = function (context, layer) {\n        //Check to see if it all loaded. If not, then throw, and give\n        //a message on what is left.\n        var id, prop, mod, idParts, pluginId, pluginResources,\n            errMessage = '',\n            failedPluginMap = {},\n            failedPluginIds = [],\n            errIds = [],\n            errUrlMap = {},\n            errUrlConflicts = {},\n            hasErrUrl = false,\n            hasUndefined = false,\n            defined = context.defined,\n            registry = context.registry;\n\n        function populateErrUrlMap(id, errUrl, skipNew) {\n            // Loader plugins do not have an errUrl, so skip them.\n            if (!errUrl) {\n                return;\n            }\n\n            if (!skipNew) {\n                errIds.push(id);\n            }\n\n            if (errUrlMap[errUrl]) {\n                hasErrUrl = true;\n                //This error module has the same URL as another\n                //error module, could be misconfiguration.\n                if (!errUrlConflicts[errUrl]) {\n                    errUrlConflicts[errUrl] = [];\n                    //Store the original module that had the same URL.\n                    errUrlConflicts[errUrl].push(errUrlMap[errUrl]);\n                }\n                errUrlConflicts[errUrl].push(id);\n            } else if (!skipNew) {\n                errUrlMap[errUrl] = id;\n            }\n        }\n\n        for (id in registry) {\n            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {\n                hasUndefined = true;\n                mod = getOwn(registry, id);\n                idParts = id.split('!');\n                pluginId = idParts[0];\n\n                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {\n                    populateErrUrlMap(id, mod.map.url);\n                }\n\n                //Look for plugins that did not call load()\n                //But skip plugin IDs that were already inlined and called\n                //define() with a name.\n                if (!hasProp(layer.modulesWithNames, id) && idParts.length > 1) {\n                    if (falseProp(failedPluginMap, pluginId)) {\n                        failedPluginIds.push(pluginId);\n                    }\n                    pluginResources = failedPluginMap[pluginId];\n                    if (!pluginResources) {\n                        pluginResources = failedPluginMap[pluginId] = [];\n                    }\n                    pluginResources.push(id + (mod.error ? ': ' + mod.error : ''));\n                }\n            }\n        }\n\n        // If have some modules that are not defined/stuck in the registry,\n        // then check defined modules for URL overlap.\n        if (hasUndefined) {\n            for (id in defined) {\n                if (hasProp(defined, id) && id.indexOf('!') === -1) {\n                    populateErrUrlMap(id, require.toUrl(id) + '.js', true);\n                }\n            }\n        }\n\n        if (errIds.length || failedPluginIds.length) {\n            if (failedPluginIds.length) {\n                errMessage += 'Loader plugin' +\n                    (failedPluginIds.length === 1 ? '' : 's') +\n                    ' did not call ' +\n                    'the load callback in the build:\\n' +\n                    failedPluginIds.map(function (pluginId) {\n                        var pluginResources = failedPluginMap[pluginId];\n                        return pluginId + ':\\n  ' + pluginResources.join('\\n  ');\n                    }).join('\\n') + '\\n';\n            }\n            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');\n\n            if (hasErrUrl) {\n                errMessage += '\\nThe following modules share the same URL. This ' +\n                              'could be a misconfiguration if that URL only has ' +\n                              'one anonymous module in it:';\n                for (prop in errUrlConflicts) {\n                    if (hasProp(errUrlConflicts, prop)) {\n                        errMessage += '\\n' + prop + ': ' +\n                                      errUrlConflicts[prop].join(', ');\n                    }\n                }\n            }\n            throw new Error(errMessage);\n        }\n    };\n\n    build.createOverrideConfig = function (config, override) {\n        var cfg = copyConfig(config),\n            oride = copyConfig(override);\n\n        lang.eachProp(oride, function (value, prop) {\n            if (hasProp(build.objProps, prop)) {\n                //An object property, merge keys. Start a new object\n                //so that source object in config does not get modified.\n                cfg[prop] = {};\n                lang.mixin(cfg[prop], config[prop], true);\n                lang.mixin(cfg[prop], override[prop], true);\n            } else {\n                cfg[prop] = override[prop];\n            }\n        });\n\n        return cfg;\n    };\n\n    /**\n     * Uses the module build config object to create an flattened version\n     * of the module, with deep dependencies included.\n     *\n     * @param {Object} module the module object from the build config info.\n     *\n     * @param {Object} layer the layer object returned from build.traceDependencies.\n     *\n     * @param {Object} the build config object.\n     *\n     * @returns {Object} with two properties: \"text\", the text of the flattened\n     * module, and \"buildText\", a string of text representing which files were\n     * included in the flattened module text.\n     */\n    build.flattenModule = function (module, layer, config) {\n        var fileContents, sourceMapGenerator,\n            sourceMapBase,\n            buildFileContents = '',\n            fs = config.env.fs;\n\n        return prim().start(function () {\n            var reqIndex, currContents, fileForSourceMap,\n                moduleName, shim, packageName,\n                parts, builder, writeApi,\n                namespace, namespaceWithDot, stubModulesByName,\n                context = layer.context,\n                onLayerEnds = [],\n                onLayerEndAdded = {},\n                pkgsMainMap = {};\n\n            //Use override settings, particularly for pragmas\n            //Do this before the var readings since it reads config values.\n            if (module.override) {\n                config = build.createOverrideConfig(config, module.override);\n            }\n\n            namespace = config.namespace || '';\n            namespaceWithDot = namespace ? namespace + '.' : '';\n            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};\n\n            //Start build output for the module.\n            module.onCompleteData = {\n                name: module.name,\n                path: (config.dir ? module._buildPath.replace(config.dir, \"\") : module._buildPath),\n                included: []\n            };\n\n            buildFileContents += \"\\n\" +\n                                  module.onCompleteData.path +\n                                 \"\\n----------------\\n\";\n\n            //If there was an existing file with require in it, hoist to the top.\n            if (layer.existingRequireUrl) {\n                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);\n                if (reqIndex !== -1) {\n                    layer.buildFilePaths.splice(reqIndex, 1);\n                    layer.buildFilePaths.unshift(layer.existingRequireUrl);\n                }\n            }\n\n            if (config.generateSourceMaps) {\n                sourceMapBase = config.dir || config.baseUrl;\n                if (module._buildPath === 'FUNCTION') {\n                    fileForSourceMap = (module.name || module.include[0] || 'FUNCTION') + '.build.js';\n                } else if (config.out) {\n                    fileForSourceMap = module._buildPath.split('/').pop();\n                } else {\n                    fileForSourceMap = module._buildPath.replace(sourceMapBase, '');\n                }\n                sourceMapGenerator = new SourceMapGenerator({\n                    file: fileForSourceMap\n                });\n            }\n\n            //Create a reverse lookup for packages main module IDs to their package\n            //names, useful for knowing when to write out define() package main ID\n            //adapters.\n            lang.eachProp(layer.context.config.pkgs, function(value, prop) {\n                pkgsMainMap[value] = prop;\n            });\n\n            //Write the built module to disk, and build up the build output.\n            fileContents = \"\";\n            if (config.wrap && config.wrap.__startMap) {\n                config.wrap.__startMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n\n            return prim.serial(layer.buildFilePaths.map(function (path) {\n                return function () {\n                    var singleContents = '';\n\n                    moduleName = layer.buildFileToModule[path];\n\n                    //If the moduleName is a package main, then hold on to the\n                    //packageName in case an adapter needs to be written.\n                    packageName = getOwn(pkgsMainMap, moduleName);\n\n                    return prim().start(function () {\n                        //Figure out if the module is a result of a build plugin, and if so,\n                        //then delegate to that plugin.\n                        parts = context.makeModuleMap(moduleName);\n                        builder = parts.prefix && getOwn(context.defined, parts.prefix);\n                        if (builder) {\n                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {\n                                onLayerEnds.push(builder);\n                                onLayerEndAdded[parts.prefix] = true;\n                            }\n\n                            if (builder.write) {\n                                writeApi = function (input) {\n                                    singleContents += \"\\n\" + addSemiColon(input, config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n                                writeApi.asModule = function (moduleName, input) {\n                                    singleContents += \"\\n\" +\n                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {\n                                            useSourceUrl: layer.context.config.useSourceUrl\n                                        }), config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n\n                                builder.write(parts.prefix, parts.name, writeApi, {\n                                    name: module.onCompleteData.name,\n                                    path: module.onCompleteData.path\n                                });\n                            }\n                            return;\n                        } else {\n                            return prim().start(function () {\n                                if (hasProp(stubModulesByName, moduleName)) {\n                                    //Just want to insert a simple module definition instead\n                                    //of the source module. Useful for plugins that inline\n                                    //all their resources.\n                                    if (hasProp(layer.context.plugins, moduleName)) {\n                                        //Slightly different content for plugins, to indicate\n                                        //that dynamic loading will not work.\n                                        return 'define({load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});';\n                                    } else {\n                                        return 'define({});';\n                                    }\n                                } else {\n                                    return require._cacheReadAsync(path,undefined,fs);\n                                }\n                            }).then(function (text) {\n                                var hasPackageName;\n\n                                currContents = text;\n\n                                if (config.cjsTranslate &&\n                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                                    currContents = commonJs.convert(path, currContents);\n                                }\n\n                                if (config.onBuildRead) {\n                                    currContents = config.onBuildRead(moduleName, path, currContents);\n                                }\n\n                                if (packageName) {\n                                    hasPackageName = (packageName === parse.getNamedDefine(currContents));\n                                }\n\n                                if (namespace) {\n                                    currContents = pragma.namespace(currContents, namespace);\n                                }\n\n                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {\n                                    useSourceUrl: config.useSourceUrl\n                                });\n\n                                if (packageName && !hasPackageName) {\n                                    currContents = addSemiColon(currContents, config) + '\\n';\n                                    currContents += namespaceWithDot + \"define('\" +\n                                                    packageName + \"', ['\" + moduleName +\n                                                    \"'], function (main) { return main; });\\n\";\n                                }\n\n                                if (config.onBuildWrite) {\n                                    currContents = config.onBuildWrite(moduleName, path, currContents);\n                                }\n\n                                //Semicolon is for files that are not well formed when\n                                //concatenated with other content.\n                                singleContents += addSemiColon(currContents, config);\n                            });\n                        }\n                    }).then(function () {\n                        var shimDeps, shortPath = path.replace(config.dir, \"\");\n\n                        module.onCompleteData.included.push(shortPath);\n                        buildFileContents += shortPath + \"\\n\";\n\n                        //Some files may not have declared a require module, and if so,\n                        //put in a placeholder call so the require does not try to load them\n                        //after the module is processed.\n                        //If we have a name, but no defined module, then add in the placeholder.\n                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {\n                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageName && getOwn(config.shim, packageName)));\n                            if (shim) {\n                                shimDeps = lang.isArray(shim) ? shim : shim.deps;\n                                if (config.wrapShim) {\n\n                                    singleContents = '(function(root) {\\n' +\n                                                     namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '[], ') +\n                                                    'function() {\\n' +\n                                                    '  return (function() {\\n' +\n                                                             singleContents +\n                                                             // Start with a \\n in case last line is a comment\n                                                             // in the singleContents, like a sourceURL comment.\n                                                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                                                             '\\n' +\n                                                    '  }).apply(root, arguments);\\n' +\n                                                    '});\\n' +\n                                                    '}(this));\\n';\n                                } else {\n                                    singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '') +\n                                                     (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                                                     ');\\n';\n                                }\n                            } else {\n                                singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", function(){});\\n';\n                            }\n                        }\n\n                        //Add line break at end of file, instead of at beginning,\n                        //so source map line numbers stay correct, but still allow\n                        //for some space separation between files in case ASI issues\n                        //for concatenation would cause an error otherwise.\n                        singleContents += '\\n';\n\n                        //Add to the source map and to the final contents\n                        fileContents = appendToFileContents(fileContents, singleContents, path, config, module,\n                                                            sourceMapGenerator);\n                    });\n                };\n            })).then(function () {\n                if (onLayerEnds.length) {\n                    onLayerEnds.forEach(function (builder, index) {\n                        var path;\n                        if (typeof module.out === 'string') {\n                            path = module.out;\n                        } else if (typeof module._buildPath === 'string') {\n                            path = module._buildPath;\n                        }\n                        builder.onLayerEnd(function (input) {\n                            fileContents =\n                                appendToFileContents(fileContents, \"\\n\" + addSemiColon(input, config),\n                                                     'onLayerEnd' + index + '.js', config, module, sourceMapGenerator);\n                        }, {\n                            name: module.name,\n                            path: path\n                        });\n                    });\n                }\n\n                if (module.create) {\n                    //The ID is for a created layer. Write out\n                    //a module definition for it in case the\n                    //built file is used with enforceDefine\n                    //(#432)\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'define(\"' + module.name +\n                                                           '\", function(){});\\n', 'module-create.js', config, module,\n                                             sourceMapGenerator);\n                }\n\n                //Add a require at the end to kick start module execution, if that\n                //was desired. Usually this is only specified when using small shim\n                //loaders like almond.\n                if (module.insertRequire) {\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'require([\"' + module.insertRequire.join('\", \"') +\n                                                           '\"]);\\n', 'module-insertRequire.js', config, module,\n                                             sourceMapGenerator);\n                }\n            });\n        }).then(function () {\n            if (config.wrap && config.wrap.__endMap) {\n                config.wrap.__endMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n            return {\n                text: fileContents,\n                buildText: buildFileContents,\n                sourceMap: sourceMapGenerator ?\n                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :\n                              undefined\n            };\n        });\n    };\n\n    //Converts an JS array of strings to a string representation.\n    //Not using JSON.stringify() for Rhino's sake.\n    build.makeJsArrayString = function (ary) {\n        return '[\"' + ary.map(function (item) {\n            //Escape any double quotes, backslashes\n            return lang.jsEscape(item);\n        }).join('\",\"') + '\"]';\n    };\n\n    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {\n        var baseUrl = layer && layer.context.config.baseUrl;\n\n        function onFound(info) {\n            //Only mark this module as having a name if not a named module,\n            //or if a named module and the name matches expectations.\n            if (layer && (info.needsId || info.foundId === moduleName)) {\n                layer.modulesWithNames[moduleName] = true;\n            }\n        }\n\n        //Convert path to be a local one to the baseUrl, useful for\n        //useSourceUrl.\n        if (baseUrl) {\n            path = path.replace(baseUrl, '');\n        }\n\n        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);\n    };\n\n    return require.build = build;\n});\n"]}