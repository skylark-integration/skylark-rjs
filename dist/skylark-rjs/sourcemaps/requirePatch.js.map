{"version":3,"sources":["requirePatch.js"],"names":["define","pragma","parse","lang","logger","commonJs","prim","allowRun","hasProp","falseProp","getOwn","useStrictRegExp","absoluteUrlRegExp","hideResolutionConflict","config","fs","env","layer","pluginBuilderRegExp","oldNewContext","require","s","newContext","oldDef","exports","module","_cacheReset","_cachedRawText","_cachedFileContents","_cachedDefinesRequireUrls","_isSupportedBuildUrl","url","indexOf","ignoredUrls","info","name","context","oldEnable","enable","moduleProto","Module","prototype","oldInit","init","oldCallPlugin","callPlugin","nextTick","fn","needFullExec","fullExec","plugins","buildShimExports","makeShimExports","value","wrapShim","str","toString","replace","depMap","parent","id","parentId","map","mod","registry","defined","undef","apply","arguments","load","moduleName","contents","pluginBuilderMatch","builderName","shim","shimExports","urlFetched","normalizeUrlWithBase","buildPathMap","buildFileToModule","start","_cacheReadAsync","undefined","then","text","cjsTranslate","convert","onBuildRead","process","existingRequireUrl","definesRequire","e1","Error","exec","makeModuleMap","nameToUrl","insertNeedsDefine","has","findNestedDependencies","e2","eval","completeLoad","e","moduleTree","push","eOuter","fileName","end","execCb","cb","args","__requireJsBuild","depMaps","this","each","bind","isDefine","parentMap","pluginMap","prefix","pluginId","pluginMod","contexts","_","_buildReset","oldContext","_layer","buildFilePaths","pathAdded","modulesWithNames","needsDefine","amd","_readFile","readFile","_fileExists","path","exists","onResourceLoad","eachProp","prop","unnormalized","originalName","jsExtRegExp","test","dir","dirBaseUrl"],"mappings":"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","file":"../requirePatch.js","sourcesContent":["/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine([ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n"]}