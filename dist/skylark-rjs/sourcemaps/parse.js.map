{"version":3,"sources":["parse.js"],"names":["define","esprima","lang","arrayToString","ary","output","forEach","item","i","jsEscape","argPropName","emptyScope","mixin","hasProp","traverse","object","visitor","child","call","keys","Object","length","traverseBroad","key","getValidDeps","node","type","elements","deps","some","elem","push","value","undefined","isFnExpression","parse","moduleName","fileName","fileContents","options","moduleCall","depString","moduleDeps","result","moduleList","needsDefine","astRoot","recurse","callName","config","name","factoryIdentifier","fnExpScope","concat","findNestedDependencies","insertNeedsDefine","onMatch","params","param","tempObject","hasHas","has","test","this","consequent","alternate","parseNode","expression","callee","argument","definesRequire","foundDefine","foundDefineAmd","body","bodyNode","decls","declarations","declNode","id","hasDefineAmd","getAnonDeps","defFunc","findAnonDefineFactory","getAnonDepsFromNode","funcArgLength","findRequireDepNames","isDefineNodeWithArgs","match","arg0","arg1","findConfig","jsConfig","foundConfig","stringData","foundRange","quote","quoteMatch","quoteRegExp","loc","arg","requireType","hasRequire","getRequireObjectLiteral","nodeToString","range","exec","eval","init","renameNamespace","ns","lines","locs","split","reverse","startIndex","start","column","lineIndex","line","substring","join","findDependencies","dependencies","findCjsDependencies","hasDefDefine","left","property","refsDefineAmd","c","hasDefine","getNamedDefine","getAllNamedDefines","excludeMap","names","hasOwnProperty","usesAmdOrRequireJs","uses","usesCommonJs","assignsExports","exp","cjsDeps","factory","refsDefine","args","isUmd","arguments","contents","extracted","preamble","slice","end","getLicenseComments","commentNode","refNode","subNode","j","ast","comment","existsMap","lineEnd","indexOf","comments"],"mappings":"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","file":"../parse.js","sourcesContent":["/*jslint plusplus: true */\n/*global define: false */\n\ndefine([\n    './esprima', \n    './lang'\n], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n"]}