{"version":3,"sources":["skylark-rjs.js"],"names":["define","skylark","require","attach","lang","isJavaObj","hasOwn","Object","prototype","hasOwnProperty","hasProp","obj","prop","call","TMP","java","importPackage","backSlashRegExp","ostring","toString","isArray","Array","it","isFunction","isRegExp","RegExp","falseProp","getOwn","_mixin","dest","source","override","name","mixin","i","l","parameters","slice","arguments","length","pop","deepMix","eachProp","value","deeplikeCopy","ignoredProps","type","result","forEach","push","key","delegate","props","tmp","each","ary","func","bind","fn","apply","jsEscape","content","replace","check","p","prim","hideResolutionConflict","Error","JSON","stringify","notify","nextTick","item","ok","fail","callback","yes","no","errback","v","e","finished","rejected","resolve","reject","start","promise","then","next","err","e2","end","serial","setImmediate","process","setTimeout","TRACE","INFO","WARN","ERROR","SILENT","level","logPrefix","logLevel","this","trace","message","_print","info","warn","error","_sysPrint","console","log","esprima","arrayToString","output","argPropName","emptyScope","traverse","object","visitor","child","keys","traverseBroad","getValidDeps","node","deps","elements","some","elem","undefined","isFnExpression","parse","moduleName","fileName","fileContents","options","moduleCall","depString","moduleDeps","moduleList","needsDefine","astRoot","recurse","callName","config","factoryIdentifier","fnExpScope","concat","findNestedDependencies","insertNeedsDefine","onMatch","params","param","tempObject","hasHas","has","test","consequent","alternate","parseNode","expression","callee","argument","definesRequire","foundDefine","foundDefineAmd","body","bodyNode","decls","declarations","declNode","id","hasDefineAmd","getAnonDeps","defFunc","findAnonDefineFactory","getAnonDepsFromNode","findRequireDepNames","funcArgLength","isDefineNodeWithArgs","match","arg0","arg1","findConfig","jsConfig","foundConfig","stringData","foundRange","quote","quoteMatch","quoteRegExp","loc","arg","requireType","hasRequire","getRequireObjectLiteral","nodeToString","range","exec","eval","init","renameNamespace","ns","lines","locs","split","reverse","startIndex","column","lineIndex","line","substring","join","findDependencies","dependencies","findCjsDependencies","hasDefDefine","left","property","refsDefineAmd","c","hasDefine","getNamedDefine","getAllNamedDefines","excludeMap","names","usesAmdOrRequireJs","uses","usesCommonJs","assignsExports","exp","factory","refsDefine","args","isUmd","cjsDeps","contents","preamble","extracted","getLicenseComments","commentNode","refNode","subNode","j","ast","comment","existsMap","lineEnd","indexOf","comments","logger","Temp","create","temp","pragma","conditionalRegExp","useStrictRegExp","hasRegExp","configRegExp","nsWrapRegExp","apiDefRegExp","defineCheckRegExp","defineStringCheckRegExp","defineTypeFirstCheckRegExp","defineJQueryRegExp","defineHasRegExp","defineTernaryRegExp","defineExistsRegExp","defineExistsAndAmdRegExp","amdefineRegExp","removeStrict","useStrict","namespace","onLifecycleName","pluginCollector","foundIndex","lineEndIndex","conditionLine","matches","marker","condition","isTrue","endRegExp","endMatches","endMarkerIndex","shouldInclude","startLength","lifecycleHas","dep","collectorMod","lifecyclePragmas","pragmas","hasConfig","kwArgs","skipPragmas","lastIndex","optimizeAllPluginResources","eDep","keepAmdefine","uglifyjs","sourcemap","uglify","sourceMap","optimize","cssImportRegExp","cssCommentImportRegExp","cssUrlRegExp","protocolRegExp","SourceMapGenerator","SourceMapConsumer","cleanCssUrlQuotes","url","charAt","fixCssUrlPaths","path","cssPrefix","fullMatch","urlMatch","parts","fixedUrlMatch","firstChar","hasProtocol","splice","jsFile","outFileName","fs","env","readFile","js","saveUtf8File","String","optimizerName","keepLines","licenseContents","optFunc","optimizers","optConfig","generateSourceMaps","_buildSourceMap","preserveLicenseComments","throwWhen","cssFile","endIndex","originalFileContents","flat","flattenCss","cssImportIgnore","included","topLevel","lastIndexOf","filePath","importList","skippedList","urlStart","importFileName","urlEnd","mediaTypes","importEndIndex","importPath","fullImportFileName","importContents","optimizeCss","buildText","dir","map","css","startDir","fileList","shouldRemove","removeCombined","getFilteredFileList","exists","deleteFile","existingMap","resultMap","uconfig","existingMapPath","baseName","outSourceMap","inSourceMap","minify","saveFile","code","errorString","isSyntaxError","transform","baseIndentRegExp","indentRegExp","keyRegExp","bulkIndentRegExps","\n","\r\n","toTransport","onFound","applySourceUrl","useSourceUrl","contentLines","modLine","foundAnon","scanCount","scanReset","defineInfos","firstArgLoc","factoryNode","needsId","depAction","namespaceExists","firstArg","operator","foundId","defineLoc","sourceUrlData","contentInsertion","modifyConfig","onConfig","details","serializeConfig","indent","baseIndent","startString","existingConfigString","lineReturn","lastReturnIndex","outDentRegExp","configString","objectToString","totalIndent","startBrace","endBrace","first","nextIndent","commonJs","useLog","convertDir","commonJsPath","savePath","convertedFileName","jsFileRegExp","convert","copyFile","commonJsProps","dirname","filename","allowRun","absoluteUrlRegExp","layer","pluginBuilderRegExp","oldNewContext","oldDef","exports","module","normalizeUrlWithBase","context","jsExtRegExp","dirBaseUrl","s","newContext","_cacheReset","_cachedRawText","_cachedFileContents","_cachedDefinesRequireUrls","_isSupportedBuildUrl","ignoredUrls","oldEnable","enable","moduleProto","Module","oldInit","oldCallPlugin","callPlugin","needFullExec","fullExec","plugins","buildShimExports","makeShimExports","wrapShim","str","depMap","parent","parentId","mod","registry","defined","undef","load","pluginBuilderMatch","builderName","shim","shimExports","urlFetched","buildPathMap","buildFileToModule","_cacheReadAsync","text","cjsTranslate","onBuildRead","existingRequireUrl","e1","makeModuleMap","nameToUrl","completeLoad","moduleTree","eOuter","execCb","cb","__requireJsBuild","depMaps","isDefine","parentMap","pluginMap","prefix","pluginId","pluginMod","contexts","_","_buildReset","oldContext","_layer","buildFilePaths","pathAdded","modulesWithNames","amd","_readFile","_fileExists","onResourceLoad","unnormalized","originalName","requirePatch","build","endsWithSemiColonRegExp","endsWithSlashRegExp","resourceIsModuleIdRegExp","deepCopyProps","copyConfig","makeBuildBaseConfig","appDir","paths","inlineText","isBuild","writeBuildTxt","waitSeconds","dirExclusionRegExp","_buildPathToModuleIndex","addSemiColon","skipSemiColonInsertion","endsWithSlash","dirName","endsWithNewLine","makeWriteFile","writeFile","file","asModule","appendToFileContents","singleContents","sourceMapGenerator","sourceMapPath","sourceMapLineNumber","lineCount","refPath","out","baseUrl","_buildPath","makeRelativeFilePath","shift","resourcePath","toUrl","addMapping","generated","original","setSourceContent","stringDotToObj","mixConfig","target","skipArrays","targetValue","flattenWrapFile","keyName","absFilePath","wrap","keyFileName","keyMapName","absPath","makeAbsPath","fileText","cfg","normalizeWrapConfig","__startMap","__endMap","wrapError","encoding","d","readFileAsync","buildFile","cmdConfig","errorMsg","errorStack","stackMatch","errorTree","errorMod","stackRegExp","convertArrayToObject","_run","index","stack","originalError","buildPaths","baseConfig","modules","srcPath","buildContext","destPath","moduleMap","parentModuleMap","resources","plugin","pluginProcessed","buildFileContents","createConfig","keepBuildDir","cssIn","copyDir","isDirectory","packagePaths","packages","_sourcePath","rawText","allowSourceOverwrites","actions","normalize","traceDependencies","exclude","excludeLayers","found","findBuildModule","excludeModule","excludeLayer","removeModulePath","excludeShallow","excludeShallowModule","flattenModule","builtModule","finalText","_buildText","bundlesConfig","bundlesConfigOutFile","entryConfig","finalPath","renameFile","bundleContents","parsedIds","isLayer","relPath","onModuleBundleComplete","onCompleteData","bundles","deleteEmptyDirs","outOrigSourceMap","include","moduleIndex","skipDirOptimize","normalizeDirDefines","onBuildWrite","createOverrideConfig","resource","objProps","pragmasOnSave","hasOnSave","uglify2","closure","hasDotPropMatch","dotProp","separatorIndex","needArray","insertRequire","stubModules","mainConfigFile","wrap.startFile","wrap.endFile","separatorI","ndex","makeAbsObject","makeAbsConfig","originalBaseUrl","targetPath","dotLength","targetParts","refParts","hasEndSlash","dotParts","targetName","finalParts","nestedMix","buildFileConfig","mainConfig","mainConfigPath","buildBaseConfig","trim","configFile","configError","main","_byName","fileExclusionRegExp","exclusionRegExp","_depsInclude","jQuery","enforceDefine","urlArgs","baseLoaderConfig","rawTextByIds","syncChecks","rhino","xpconnect","deferred","includeFinished","hasError","checkForErrors","idParts","errMessage","failedPluginMap","failedPluginIds","errIds","errUrlMap","errUrlConflicts","hasErrUrl","hasUndefined","populateErrUrlMap","errUrl","skipNew","enabled","oride","sourceMapBase","currContents","fileForSourceMap","packageName","builder","writeApi","namespaceWithDot","stubModulesByName","onLayerEnds","onLayerEndAdded","pkgsMainMap","reqIndex","unshift","pkgs","wrapFunction","hasPackageName","onLayerEnd","write","input","shortPath","skipModuleInsertion","shimDeps","makeJsArrayString","exportsFn","toJSON","rjs","createRjsApi"],"mappings":"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","file":"../skylark-rjs.js","sourcesContent":["define('skylark-rjs/rjs',[\r\n    \"skylark-langx-ns\",\r\n],function(skylark){\r\n    require.define = define;\r\n\r\n\treturn skylark.attach(\"intg.rjs\",require);\r\n});\n/*jslint plusplus: true */\n/*global define, java */\n\ndefine('skylark-rjs/lang',[],function () {\n    'use strict';\n\n    var lang, isJavaObj,\n        hasOwn = Object.prototype.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    isJavaObj = function () {\n        return false;\n    };\n\n    //Rhino, but not Nashorn (detected by importPackage not existing)\n    //Can have some strange foreign objects.\n    if (typeof java !== 'undefined' && java.lang && java.lang.Object && typeof importPackage !== 'undefined') {\n        isJavaObj = function (obj) {\n            return obj instanceof java.lang.Object;\n        };\n    }\n\n    lang = {\n        backSlashRegExp: /\\\\/g,\n        ostring: Object.prototype.toString,\n\n        isArray: Array.isArray || function (it) {\n            return lang.ostring.call(it) === \"[object Array]\";\n        },\n\n        isFunction: function(it) {\n            return lang.ostring.call(it) === \"[object Function]\";\n        },\n\n        isRegExp: function(it) {\n            return it && it instanceof RegExp;\n        },\n\n        hasProp: hasProp,\n\n        //returns true if the object does not have an own property prop,\n        //or if it does, it is a falsy value.\n        falseProp: function (obj, prop) {\n            return !hasProp(obj, prop) || !obj[prop];\n        },\n\n        //gets own property value for given prop on object\n        getOwn: function (obj, prop) {\n            return hasProp(obj, prop) && obj[prop];\n        },\n\n        _mixin: function(dest, source, override){\n            var name;\n            for (name in source) {\n                if(source.hasOwnProperty(name) &&\n                    (override || !dest.hasOwnProperty(name))) {\n                    dest[name] = source[name];\n                }\n            }\n\n            return dest; // Object\n        },\n\n        /**\n         * mixin({}, obj1, obj2) is allowed. If the last argument is a boolean,\n         * then the source objects properties are force copied over to dest.\n         */\n        mixin: function(dest){\n            var parameters = Array.prototype.slice.call(arguments),\n                override, i, l;\n\n            if (!dest) { dest = {}; }\n\n            if (parameters.length > 2 && typeof arguments[parameters.length-1] === 'boolean') {\n                override = parameters.pop();\n            }\n\n            for (i = 1, l = parameters.length; i < l; i++) {\n                lang._mixin(dest, parameters[i], override);\n            }\n            return dest; // Object\n        },\n\n        /**\n         * Does a deep mix of source into dest, where source values override\n         * dest values if a winner is needed.\n         * @param  {Object} dest destination object that receives the mixed\n         * values.\n         * @param  {Object} source source object contributing properties to mix\n         * in.\n         * @return {[Object]} returns dest object with the modification.\n         */\n        deepMix: function(dest, source) {\n            lang.eachProp(source, function (value, prop) {\n                if (typeof value === 'object' && value &&\n                    !lang.isArray(value) && !lang.isFunction(value) &&\n                    !(value instanceof RegExp)) {\n\n                    if (!dest[prop]) {\n                        dest[prop] = {};\n                    }\n                    lang.deepMix(dest[prop], value);\n                } else {\n                    dest[prop] = value;\n                }\n            });\n            return dest;\n        },\n\n        /**\n         * Does a type of deep copy. Do not give it anything fancy, best\n         * for basic object copies of objects that also work well as\n         * JSON-serialized things, or has properties pointing to functions.\n         * For non-array/object values, just returns the same object.\n         * @param  {Object} obj      copy properties from this object\n         * @param  {Object} [ignoredProps] optional object whose own properties\n         * are keys that should be ignored.\n         * @return {Object}\n         */\n        deeplikeCopy: function (obj, ignoredProps) {\n            var type, result;\n\n            if (lang.isArray(obj)) {\n                result = [];\n                obj.forEach(function(value) {\n                    result.push(lang.deeplikeCopy(value, ignoredProps));\n                });\n                return result;\n            }\n\n            type = typeof obj;\n            if (obj === null || obj === undefined || type === 'boolean' ||\n                type === 'string' || type === 'number' || lang.isFunction(obj) ||\n                lang.isRegExp(obj)|| isJavaObj(obj)) {\n                return obj;\n            }\n\n            //Anything else is an object, hopefully.\n            result = {};\n            lang.eachProp(obj, function(value, key) {\n                if (!ignoredProps || !hasProp(ignoredProps, key)) {\n                    result[key] = lang.deeplikeCopy(value, ignoredProps);\n                }\n            });\n            return result;\n        },\n\n        delegate: (function () {\n            // boodman/crockford delegation w/ cornford optimization\n            function TMP() {}\n            return function (obj, props) {\n                TMP.prototype = obj;\n                var tmp = new TMP();\n                TMP.prototype = null;\n                if (props) {\n                    lang.mixin(tmp, props);\n                }\n                return tmp; // Object\n            };\n        }()),\n\n        /**\n         * Helper function for iterating over an array. If the func returns\n         * a true value, it will break out of the loop.\n         */\n        each: function each(ary, func) {\n            if (ary) {\n                var i;\n                for (i = 0; i < ary.length; i += 1) {\n                    if (func(ary[i], i, ary)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Cycles over properties in an object and calls a function for each\n         * property value. If the function returns a truthy value, then the\n         * iteration is stopped.\n         */\n        eachProp: function eachProp(obj, func) {\n            var prop;\n            for (prop in obj) {\n                if (hasProp(obj, prop)) {\n                    if (func(obj[prop], prop)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        //Similar to Function.prototype.bind, but the \"this\" object is specified\n        //first, since it is easier to read/figure out what \"this\" will be.\n        bind: function bind(obj, fn) {\n            return function () {\n                return fn.apply(obj, arguments);\n            };\n        },\n\n        //Escapes a content string to be be a string that has characters escaped\n        //for inclusion as part of a JS string.\n        jsEscape: function (content) {\n            return content.replace(/([\"'\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\");\n        }\n    };\n    return lang;\n});\n\n/**\n * prim 0.0.1 Copyright (c) 2012-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/prim for details\n */\n\n/*global setImmediate, process, setTimeout, define, module */\n\n//Set prime.hideResolutionConflict = true to allow \"resolution-races\"\n//in promise-tests to pass.\n//Since the goal of prim is to be a small impl for trusted code, it is\n//more important to normally throw in this case so that we can find\n//logic errors quicker.\n\ndefine('skylark-rjs/prim',[],function () {\n    'use strict';\n    var op = Object.prototype,\n        hasOwn = op.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i]) {\n                    func(ary[i], i, ary);\n                }\n            }\n        }\n    }\n\n    function check(p) {\n        if (hasProp(p, 'e') || hasProp(p, 'v')) {\n            if (!prim.hideResolutionConflict) {\n                throw new Error('Prim promise already resolved: ' +\n                                JSON.stringify(p));\n            }\n            return false;\n        }\n        return true;\n    }\n\n    function notify(ary, value) {\n        prim.nextTick(function () {\n            each(ary, function (item) {\n                item(value);\n            });\n        });\n    }\n\n    function prim() {\n        var p,\n            ok = [],\n            fail = [];\n\n        return (p = {\n            callback: function (yes, no) {\n                if (no) {\n                    p.errback(no);\n                }\n\n                if (hasProp(p, 'v')) {\n                    prim.nextTick(function () {\n                        yes(p.v);\n                    });\n                } else {\n                    ok.push(yes);\n                }\n            },\n\n            errback: function (no) {\n                if (hasProp(p, 'e')) {\n                    prim.nextTick(function () {\n                        no(p.e);\n                    });\n                } else {\n                    fail.push(no);\n                }\n            },\n\n            finished: function () {\n                return hasProp(p, 'e') || hasProp(p, 'v');\n            },\n\n            rejected: function () {\n                return hasProp(p, 'e');\n            },\n\n            resolve: function (v) {\n                if (check(p)) {\n                    p.v = v;\n                    notify(ok, v);\n                }\n                return p;\n            },\n            reject: function (e) {\n                if (check(p)) {\n                    p.e = e;\n                    notify(fail, e);\n                }\n                return p;\n            },\n\n            start: function (fn) {\n                p.resolve();\n                return p.promise.then(fn);\n            },\n\n            promise: {\n                then: function (yes, no) {\n                    var next = prim();\n\n                    p.callback(function (v) {\n                        try {\n                            if (yes && typeof yes === 'function') {\n                                v = yes(v);\n                            }\n\n                            if (v && v.then) {\n                                v.then(next.resolve, next.reject);\n                            } else {\n                                next.resolve(v);\n                            }\n                        } catch (e) {\n                            next.reject(e);\n                        }\n                    }, function (e) {\n                        var err;\n\n                        try {\n                            if (!no || typeof no !== 'function') {\n                                next.reject(e);\n                            } else {\n                                err = no(e);\n\n                                if (err && err.then) {\n                                    err.then(next.resolve, next.reject);\n                                } else {\n                                    next.resolve(err);\n                                }\n                            }\n                        } catch (e2) {\n                            next.reject(e2);\n                        }\n                    });\n\n                    return next.promise;\n                },\n\n                fail: function (no) {\n                    return p.promise.then(null, no);\n                },\n\n                end: function () {\n                    p.errback(function (e) {\n                        throw e;\n                    });\n                }\n            }\n        });\n    };\n\n    prim.serial = function (ary) {\n        var result = prim().resolve().promise;\n        each(ary, function (item) {\n            result = result.then(function () {\n                return item();\n            });\n        });\n        return result;\n    };\n\n    prim.nextTick = typeof setImmediate === 'function' ? setImmediate :\n        (typeof process !== 'undefined' && process.nextTick ?\n            process.nextTick : (typeof setTimeout !== 'undefined' ?\n                function (fn) {\n                setTimeout(fn, 0);\n            } : function (fn) {\n        fn();\n    }));\n\n    return prim;\n});\n/*jslint nomen: false, strict: false */\n/*global define: false */\n\ndefine('skylark-rjs/logger',[],function () {\n    function print(msg,e) {\n        console.log(msg,e);\n    }\n\n    var logger = {\n        TRACE: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        SILENT: 4,\n        level: 0,\n        logPrefix: \"\",\n\n        logLevel: function( level ) {\n            this.level = level;\n        },\n\n        trace: function (message) {\n            if (this.level <= this.TRACE) {\n                this._print(message);\n            }\n        },\n\n        info: function (message) {\n            if (this.level <= this.INFO) {\n                this._print(message);\n            }\n        },\n\n        warn: function (message) {\n            if (this.level <= this.WARN) {\n                this._print(message);\n            }\n        },\n\n        error: function (message) {\n            if (this.level <= this.ERROR) {\n                this._print(message);\n            }\n        },\n\n        _print: function (message) {\n            this._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n        },\n\n        _sysPrint: function (message) {\n            print(message);\n        }\n    };\n\n    return logger;\n});\n\n/*global define, Reflect */\n\n/*\n * xpcshell has a smaller stack on linux and windows (1MB vs 9MB on mac),\n * and the recursive nature of esprima can cause it to overflow pretty\n * quickly. So favor it built in Reflect parser:\n * https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n */\ndefine('skylark-rjs/esprima',['skylark-espree'], function (esprima) {\n    return esprima;\n});\n\n/*jslint plusplus: true */\n/*global define: false */\n\ndefine('skylark-rjs/parse',[\n    './esprima', \n    './lang'\n], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n\n/*jslint regexp: true, plusplus: true  */\n/*global define: false */\n\ndefine('skylark-rjs/pragma',[\n    './parse', \n    './logger'\n], function (parse, logger) {\n    'use strict';\n    function Temp() {}\n\n    function create(obj, mixin) {\n        Temp.prototype = obj;\n        var temp = new Temp(), prop;\n\n        //Avoid any extra memory hanging around\n        Temp.prototype = null;\n\n        if (mixin) {\n            for (prop in mixin) {\n                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {\n                    temp[prop] = mixin[prop];\n                }\n            }\n        }\n\n        return temp; // Object\n    }\n\n    var pragma = {\n        conditionalRegExp: /(exclude|include)Start\\s*\\(\\s*[\"'](\\w+)[\"']\\s*,(.*)\\)/,\n        useStrictRegExp: /(^|[^{]\\r?\\n)['\"]use strict['\"];/g,\n        hasRegExp: /has\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n        configRegExp: /(^|[^\\.])(requirejs|require)(\\.config)\\s*\\(/g,\n        nsWrapRegExp: /\\/\\*requirejs namespace: true \\*\\//,\n        apiDefRegExp: /var requirejs,\\s*require,\\s*define;/,\n        defineCheckRegExp: /typeof(\\s+|\\s*\\(\\s*)define(\\s*\\))?\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineStringCheckRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\[\\s*[\"']amd[\"']\\s*\\]/g,\n        defineTypeFirstCheckRegExp: /\\s*[\"']function[\"']\\s*==(=?)\\s*typeof\\s+define\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineJQueryRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\.\\s*jQuery/g,\n        defineHasRegExp: /typeof\\s+define\\s*==(=)?\\s*['\"]function['\"]\\s*&&\\s*typeof\\s+define\\.amd\\s*==(=)?\\s*['\"]object['\"]\\s*&&\\s*define\\.amd/g,\n        defineTernaryRegExp: /typeof\\s+define\\s*===?\\s*['\"]function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\?\\s*define/,\n        defineExistsRegExp: /\\s+typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*/,\n        defineExistsAndAmdRegExp: /typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*/,\n        amdefineRegExp: /if\\s*\\(\\s*typeof define\\s*\\!==\\s*['\"]function['\"]\\s*\\)\\s*\\{\\s*[^\\{\\}]+amdefine[^\\{\\}]+\\}/g,\n\n        removeStrict: function (contents, config) {\n            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '$1');\n        },\n\n        namespace: function (fileContents, ns, onLifecycleName) {\n            if (ns) {\n                //Namespace require/define calls\n                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');\n\n\n                fileContents = parse.renameNamespace(fileContents, ns);\n\n                //Namespace define ternary use:\n                fileContents = fileContents.replace(pragma.defineTernaryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd ? \" + ns + \".define\");\n\n                //Namespace define jquery use:\n                fileContents = fileContents.replace(pragma.defineJQueryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd && \" + ns + \".define.amd.jQuery\");\n\n                //Namespace has.js define use:\n                fileContents = fileContents.replace(pragma.defineHasRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && typeof \" + ns + \".define.amd === 'object' && \" + ns + \".define.amd\");\n\n                //Namespace async.js define use:\n                fileContents = fileContents.replace(pragma.defineExistsAndAmdRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined' && \" + ns + \".define.amd\");\n\n                //Namespace define checks.\n                //Do these ones last, since they are a subset of the more specific\n                //checks above.\n                fileContents = fileContents.replace(pragma.defineCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define['amd']\");\n                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,\n                                                    \"'function' === typeof \" + ns + \".define && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineExistsRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined'\");\n\n                //Check for require.js with the require/define definitions\n                if (pragma.apiDefRegExp.test(fileContents) &&\n                    fileContents.indexOf(\"if (!\" + ns + \" || !\" + ns + \".requirejs)\") === -1) {\n                    //Wrap the file contents in a typeof check, and a function\n                    //to contain the API globals.\n                    fileContents = \"var \" + ns + \";(function () { if (!\" + ns + \" || !\" + ns + \".requirejs) {\\n\" +\n                                    \"if (!\" + ns + \") { \" + ns + ' = {}; } else { require = ' + ns + '; }\\n' +\n                                    fileContents +\n                                    \"\\n\" +\n                                    ns + \".requirejs = requirejs;\" +\n                                    ns + \".require = require;\" +\n                                    ns + \".define = define;\\n\" +\n                                    \"}\\n}());\";\n                }\n\n                //Finally, if the file wants a special wrapper because it ties\n                //in to the requirejs internals in a way that would not fit\n                //the above matches, do that. Look for /*requirejs namespace: true*/\n                if (pragma.nsWrapRegExp.test(fileContents)) {\n                    //Remove the pragma.\n                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');\n\n                    //Alter the contents.\n                    fileContents = '(function () {\\n' +\n                                   'var require = ' + ns + '.require,' +\n                                   'requirejs = ' + ns + '.requirejs,' +\n                                   'define = ' + ns + '.define;\\n' +\n                                   fileContents +\n                                   '\\n}());';\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * processes the fileContents for some //>> conditional statements\n         */\n        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {\n            /*jslint evil: true */\n            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,\n                matches, type, marker, condition, isTrue, endRegExp, endMatches,\n                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,\n                i, dep, moduleName, collectorMod,\n                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,\n                //Legacy arg defined to help in dojo conversion script. Remove later\n                //when dojo no longer needs conversion:\n                kwArgs = pragmas;\n\n            //Mix in a specific lifecycle scoped object, to allow targeting\n            //some pragmas/has tests to only when files are saved, or at different\n            //lifecycle events. Do not bother with kwArgs in this section, since\n            //the old dojo kwArgs were for all points in the build lifecycle.\n            if (onLifecycleName) {\n                lifecyclePragmas = config['pragmas' + onLifecycleName];\n                lifecycleHas = config['has' + onLifecycleName];\n\n                if (lifecyclePragmas) {\n                    pragmas = create(pragmas || {}, lifecyclePragmas);\n                }\n\n                if (lifecycleHas) {\n                    hasConfig = create(hasConfig || {}, lifecycleHas);\n                }\n            }\n\n            //Replace has references if desired\n            if (hasConfig) {\n                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {\n                    if (hasConfig.hasOwnProperty(test)) {\n                        return !!hasConfig[test];\n                    }\n                    return match;\n                });\n            }\n\n            if (!config.skipPragmas) {\n\n                while ((foundIndex = fileContents.indexOf(\"//>>\", startIndex)) !== -1) {\n                    //Found a conditional. Get the conditional line.\n                    lineEndIndex = fileContents.indexOf(\"\\n\", foundIndex);\n                    if (lineEndIndex === -1) {\n                        lineEndIndex = fileContents.length - 1;\n                    }\n\n                    //Increment startIndex past the line so the next conditional search can be done.\n                    startIndex = lineEndIndex + 1;\n\n                    //Break apart the conditional.\n                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);\n                    matches = conditionLine.match(pragma.conditionalRegExp);\n                    if (matches) {\n                        type = matches[1];\n                        marker = matches[2];\n                        condition = matches[3];\n                        isTrue = false;\n                        //See if the condition is true.\n                        try {\n                            isTrue = !!eval(\"(\" + condition + \")\");\n                        } catch (e) {\n                            throw \"Error in file: \" +\n                                   fileName +\n                                   \". Conditional comment: \" +\n                                   conditionLine +\n                                   \" failed with this error: \" + e;\n                        }\n\n                        //Find the endpoint marker.\n                        endRegExp = new RegExp('\\\\/\\\\/\\\\>\\\\>\\\\s*' + type + 'End\\\\(\\\\s*[\\'\"]' + marker + '[\\'\"]\\\\s*\\\\)', \"g\");\n                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));\n                        if (endMatches) {\n                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;\n\n                            //Find the next line return based on the match position.\n                            lineEndIndex = fileContents.indexOf(\"\\n\", endMarkerIndex);\n                            if (lineEndIndex === -1) {\n                                lineEndIndex = fileContents.length - 1;\n                            }\n\n                            //Should we include the segment?\n                            shouldInclude = ((type === \"exclude\" && !isTrue) || (type === \"include\" && isTrue));\n\n                            //Remove the conditional comments, and optionally remove the content inside\n                            //the conditional comments.\n                            startLength = startIndex - foundIndex;\n                            fileContents = fileContents.substring(0, foundIndex) +\n                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : \"\") +\n                                fileContents.substring(lineEndIndex + 1, fileContents.length);\n\n                            //Move startIndex to foundIndex, since that is the new position in the file\n                            //where we need to look for more conditionals in the next while loop pass.\n                            startIndex = foundIndex;\n                        } else {\n                            throw \"Error in file: \" +\n                                  fileName +\n                                  \". Cannot find end marker for conditional comment: \" +\n                                  conditionLine;\n\n                        }\n                    }\n                }\n            }\n\n            //If need to find all plugin resources to optimize, do that now,\n            //before namespacing, since the namespacing will change the API\n            //names.\n            //If there is a plugin collector, scan the file for plugin resources.\n            if (config.optimizeAllPluginResources && pluginCollector) {\n                try {\n                    deps = parse.findDependencies(fileName, fileContents);\n                    if (deps.length) {\n                        for (i = 0; i < deps.length; i++) {\n                            dep = deps[i];\n                            if (dep.indexOf('!') !== -1) {\n                                moduleName = dep.split('!')[0];\n                                collectorMod = pluginCollector[moduleName];\n                                if (!collectorMod) {\n                                 collectorMod = pluginCollector[moduleName] = [];\n                                }\n                                collectorMod.push(dep);\n                            }\n                        }\n                    }\n                } catch (eDep) {\n                    logger.error('Parse error looking for plugin resources in ' +\n                                 fileName + ', skipping.');\n                }\n            }\n\n            //Strip amdefine use for node-shared modules.\n            if (!config.keepAmdefine) {\n                fileContents = fileContents.replace(pragma.amdefineRegExp, '');\n            }\n\n            //Do namespacing\n            if (onLifecycleName === 'OnSave' && config.namespace) {\n                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);\n            }\n\n\n            return pragma.removeStrict(fileContents, config);\n        }\n    };\n\n    return pragma;\n});\n\n//Distributed under the BSD license:\n//Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\ndefine('skylark-rjs/uglifyjs',['skylark-uglifyjs'], function (uglifyjs) {\n    return uglifyjs;\n});\n\ndefine('skylark-rjs/source-map',['skylark-sourcemap'], function (sourcemap) {\n    return sourcemap;\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true */\n/*global define: false */\n\ndefine('skylark-rjs/optimize',[ \n    './lang', \n    './logger', \n///    'env!env/optimize', \n///    'env!env/file', \n    './parse',\n    './pragma', \n    './uglifyjs',\n    './source-map'\n],function (\n    lang,\n    logger,\n///     envOptimize, \n///     file, \n     parse,\n     pragma, \n     uglify,\n     sourceMap\n) {\n    'use strict';\n\n    var optimize,\n        cssImportRegExp = /\\@import\\s+(url\\()?\\s*([^);]+)\\s*(\\))?([\\w, ]*)(;)?/ig,\n        cssCommentImportRegExp = /\\/\\*[^\\*]*@import[^\\*]*\\*\\//g,\n        cssUrlRegExp = /\\url\\(\\s*([^\\)]+)\\s*\\)?/g,\n        protocolRegExp = /^\\w+:/,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        SourceMapConsumer = sourceMap.SourceMapConsumer,\n        es5PlusGuidance = 'If the source uses ES2015 or later syntax, please pass \"optimize: \\'none\\'\" to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.';\n\n    /**\n     * If an URL from a CSS url value contains start/end quotes, remove them.\n     * This is not done in the regexp, since my regexp fu is not that strong,\n     * and the CSS spec allows for ' and \" in the URL if they are backslash escaped.\n     * @param {String} url\n     */\n    function cleanCssUrlQuotes(url) {\n        //Make sure we are not ending in whitespace.\n        //Not very confident of the css regexps above that there will not be ending\n        //whitespace.\n        url = url.replace(/\\s+$/, \"\");\n\n        if (url.charAt(0) === \"'\" || url.charAt(0) === \"\\\"\") {\n            url = url.substring(1, url.length - 1);\n        }\n\n        return url;\n    }\n\n    function fixCssUrlPaths(fileName, path, contents, cssPrefix) {\n        return contents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {\n            var firstChar, hasProtocol, parts, i,\n                fixedUrlMatch = cleanCssUrlQuotes(urlMatch);\n\n            fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, \"/\");\n\n            //Only do the work for relative URLs. Skip things that start with / or #, or have\n            //a protocol.\n            firstChar = fixedUrlMatch.charAt(0);\n            hasProtocol = protocolRegExp.test(fixedUrlMatch);\n            if (firstChar !== \"/\" && firstChar !== \"#\" && !hasProtocol) {\n                //It is a relative URL, tack on the cssPrefix and path prefix\n                urlMatch = cssPrefix + path + fixedUrlMatch;\n            } else if (!hasProtocol) {\n                logger.trace(fileName + \"\\n  URL not a relative URL, skipping: \" + urlMatch);\n            }\n\n            //Collapse .. and .\n            parts = urlMatch.split(\"/\");\n            for (i = parts.length - 1; i > 0; i--) {\n                if (parts[i] === \".\") {\n                    parts.splice(i, 1);\n                } else if (parts[i] === \"..\") {\n                    if (i !== 0 && parts[i - 1] !== \"..\") {\n                        parts.splice(i - 1, 2);\n                        i -= 1;\n                    }\n                }\n            }\n\n            return \"url(\" + parts.join(\"/\") + \")\";\n        });\n    }\n\n    /**\n     * Inlines nested stylesheets that have @import calls in them.\n     * @param {String} fileName the file name\n     * @param {String} fileContents the file contents\n     * @param {String} cssImportIgnore comma delimited string of files to ignore\n     * @param {String} cssPrefix string to be prefixed before relative URLs\n     * @param {Object} included an object used to track the files already imported\n     */\n    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included, topLevel,config) {\n        //Find the last slash in the name.\n        fileName = fileName.replace(lang.backSlashRegExp, \"/\");\n        var endIndex = fileName.lastIndexOf(\"/\"),\n            //Make a file path based on the last slash.\n            //If no slash, so must be just a file name. Use empty string then.\n            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : \"\",\n            //store a list of merged files\n            importList = [],\n            skippedList = [],\n            fs = config.env.fs;\n\n        //First make a pass by removing any commented out @import calls.\n        fileContents = fileContents.replace(cssCommentImportRegExp, '');\n\n        //Make sure we have a delimited ignore list to make matching faster\n        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== \",\") {\n            cssImportIgnore += \",\";\n        }\n\n        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {\n            //Only process media type \"all\" or empty media type rules.\n            if (mediaTypes && ((mediaTypes.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')) !== \"all\")) {\n                skippedList.push(fileName);\n                return fullMatch;\n            }\n\n            importFileName = cleanCssUrlQuotes(importFileName);\n\n            //Ignore the file import if it is part of an ignore list.\n            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + \",\") !== -1) {\n                return fullMatch;\n            }\n\n            //Make sure we have a unix path for the rest of the operation.\n            importFileName = importFileName.replace(lang.backSlashRegExp, \"/\");\n\n            try {\n                //if a relative path, then tack on the filePath.\n                //If it is not a relative path, then the readFile below will fail,\n                //and we will just skip that import.\n                var fullImportFileName = importFileName.charAt(0) === \"/\" ? importFileName : filePath + importFileName,\n                    importContents = fs.readFile(fullImportFileName),\n                    importEndIndex, importPath, flat;\n\n                //Skip the file if it has already been included.\n                if (included[fullImportFileName]) {\n                    return '';\n                }\n                included[fullImportFileName] = true;\n\n                //Make sure to flatten any nested imports.\n                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included,false,config);\n                importContents = flat.fileContents;\n\n                if (flat.importList.length) {\n                    importList.push.apply(importList, flat.importList);\n                }\n                if (flat.skippedList.length) {\n                    skippedList.push.apply(skippedList, flat.skippedList);\n                }\n\n                //Make the full import path\n                importEndIndex = importFileName.lastIndexOf(\"/\");\n\n                //Make a file path based on the last slash.\n                //If no slash, so must be just a file name. Use empty string then.\n                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : \"\";\n\n                //fix url() on relative import (#5)\n                importPath = importPath.replace(/^\\.\\//, '');\n\n                //Modify URL paths to match the path represented by this file.\n                importContents = fixCssUrlPaths(importFileName, importPath, importContents, cssPrefix);\n\n                importList.push(fullImportFileName);\n                return importContents;\n            } catch (e) {\n                logger.warn(fileName + \"\\n  Cannot inline css import, skipping: \" + importFileName);\n                return fullMatch;\n            }\n        });\n\n        if (cssPrefix && topLevel) {\n            //Modify URL paths to match the path represented by this file.\n            fileContents = fixCssUrlPaths(fileName, '', fileContents, cssPrefix);\n        }\n\n        return {\n            importList : importList,\n            skippedList: skippedList,\n            fileContents : fileContents\n        };\n    }\n\n    optimize = {\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file to optimize\n         * @param {String} fileContents the contents to optimize. If this is\n         * a null value, then fileName will be used to read the fileContents.\n         * @param {String} outFileName the name of the file to use for the\n         * saved optimized content.\n         * @param {Object} config the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var fs = config.env.fs;\n            if (!fileContents) {\n                fileContents = fs.readFile(fileName);\n            }\n\n            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);\n\n            fs.saveUtf8File(outFileName, fileContents);\n        },\n\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file that matches the\n         * fileContents.\n         * @param {String} fileContents the string of JS to optimize.\n         * @param {Object} [config] the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        js: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var optFunc, optConfig,\n                parts = (String(config.optimize)).split('.'),\n                optimizerName = parts[0],\n                keepLines = parts[1] === 'keepLines',\n                licenseContents = '';\n\n            config = config || {};\n\n            //Apply pragmas/namespace renaming\n            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n\n            //Optimize the JS files if asked.\n            if (optimizerName && optimizerName !== 'none') {\n                ///optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n                optFunc = optimize.optimizers[optimizerName];\n                if (!optFunc) {\n                    throw new Error('optimizer with name of \"' +\n                                    optimizerName +\n                                    '\" not found for this environment');\n                }\n\n                optConfig = config[optimizerName] || {};\n                if (config.generateSourceMaps) {\n                    optConfig.generateSourceMaps = !!config.generateSourceMaps;\n                    optConfig._buildSourceMap = config._buildSourceMap;\n                }\n                ///optConfig.env = config.env;\n\n                try {\n                    if (config.preserveLicenseComments) {\n                        //Pull out any license comments for prepending after optimization.\n                        try {\n                            licenseContents = parse.getLicenseComments(fileName, fileContents);\n                        } catch (e) {\n                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n                        }\n                    }\n\n                    if (config.generateSourceMaps && licenseContents) {\n                        optConfig.preamble = licenseContents;\n                        licenseContents = '';\n                    }\n\n                    fileContents = licenseContents + optFunc(fileName,\n                                                             fileContents,\n                                                             outFileName,\n                                                             keepLines,\n                                                             optConfig,\n                                                             config.env.fs);\n                    if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n                        config._buildSourceMap = optConfig._buildSourceMap;\n                    }\n                } catch (e) {\n                    if (config.throwWhen && config.throwWhen.optimize) {\n                        throw e;\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            } else {\n                if (config._buildSourceMap) {\n                    config._buildSourceMap = null;\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * Optimizes one CSS file, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} fileName the path to the CSS file to optimize\n         * @param {String} outFileName the path to save the optimized file.\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        cssFile: function (fileName, outFileName, config) {\n            var fs = config.env.fs;\n            //Read in the file. Make sure we have a JS string.\n            var originalFileContents = fs.readFile(fileName),\n                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}, true,config),\n                //Do not use the flattened CSS if there was one that was skipped.\n                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,\n                startIndex, endIndex, buildText, comment;\n\n            if (flat.skippedList.length) {\n                logger.warn('Cannot inline @imports for ' + fileName +\n                            ',\\nthe following files had media queries in them:\\n' +\n                            flat.skippedList.join('\\n'));\n            }\n\n            //Do comment removal.\n            try {\n                if (config.optimizeCss.indexOf(\".keepComments\") === -1) {\n                    startIndex = 0;\n                    //Get rid of comments.\n                    while ((startIndex = fileContents.indexOf(\"/*\", startIndex)) !== -1) {\n                        endIndex = fileContents.indexOf(\"*/\", startIndex + 2);\n                        if (endIndex === -1) {\n                            throw \"Improper comment in CSS file: \" + fileName;\n                        }\n                        comment = fileContents.substring(startIndex, endIndex);\n\n                        if (config.preserveLicenseComments &&\n                            (comment.indexOf('license') !== -1 ||\n                             comment.indexOf('opyright') !== -1 ||\n                             comment.indexOf('(c)') !== -1)) {\n                            //Keep the comment, just increment the startIndex\n                            startIndex = endIndex;\n                        } else {\n                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);\n                            startIndex = 0;\n                        }\n                    }\n                }\n                //Get rid of newlines.\n                if (config.optimizeCss.indexOf(\".keepLines\") === -1) {\n                    fileContents = fileContents.replace(/[\\r\\n]/g, \" \");\n                    fileContents = fileContents.replace(/\\s+/g, \" \");\n                    fileContents = fileContents.replace(/\\{\\s/g, \"{\");\n                    fileContents = fileContents.replace(/\\s\\}/g, \"}\");\n                } else {\n                    //Remove multiple empty lines.\n                    fileContents = fileContents.replace(/(\\r\\n)+/g, \"\\r\\n\");\n                    fileContents = fileContents.replace(/(\\n)+/g, \"\\n\");\n                }\n                //Remove unnecessary whitespace\n                if (config.optimizeCss.indexOf(\".keepWhitespace\") === -1) {\n                    //Remove leading and trailing whitespace from lines\n                    fileContents = fileContents.replace(/^[ \\t]+/gm, \"\");\n                    fileContents = fileContents.replace(/[ \\t]+$/gm, \"\");\n                    //Remove whitespace after semicolon, colon, curly brackets and commas\n                    fileContents = fileContents.replace(/(;|:|\\{|}|,)[ \\t]+/g, \"$1\");\n                    //Remove whitespace before opening curly brackets\n                    fileContents = fileContents.replace(/[ \\t]+(\\{)/g, \"$1\");\n                    //Truncate double whitespace\n                    fileContents = fileContents.replace(/([ \\t])+/g, \"$1\");\n                    //Remove empty lines\n                    fileContents = fileContents.replace(/^[ \\t]*[\\r\\n]/gm,'');\n                }\n            } catch (e) {\n                fileContents = originalFileContents;\n                logger.error(\"Could not optimized CSS file: \" + fileName + \", error: \" + e);\n            }\n\n            fs.saveUtf8File(outFileName, fileContents);\n\n            //text output to stdout and/or written to build.txt file\n            buildText = \"\\n\"+ outFileName.replace(config.dir, \"\") +\"\\n----------------\\n\";\n            flat.importList.push(fileName);\n            buildText += flat.importList.map(function(path){\n                return path.replace(config.dir, \"\");\n            }).join(\"\\n\");\n\n            return {\n                importList: flat.importList,\n                buildText: buildText +\"\\n\"\n            };\n        },\n\n        /**\n         * Optimizes CSS files, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} startDir the path to the top level directory\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        css: function (startDir, config) {\n            var buildText = \"\",\n                importList = [],\n                shouldRemove = config.dir && config.removeCombined,\n                i, fileName, result, fileList,\n                fs = config.env.fs;\n\n            if (config.optimizeCss.indexOf(\"standard\") !== -1) {\n                fileList = fs.getFilteredFileList(startDir, /\\.css$/, true);\n                if (fileList) {\n                    for (i = 0; i < fileList.length; i++) {\n                        fileName = fileList[i];\n                        logger.trace(\"Optimizing (\" + config.optimizeCss + \") CSS file: \" + fileName);\n                        result = optimize.cssFile(fileName, fileName, config);\n                        buildText += result.buildText;\n                        if (shouldRemove) {\n                            result.importList.pop();\n                            importList = importList.concat(result.importList);\n                        }\n                    }\n                }\n\n                if (shouldRemove) {\n                    importList.forEach(function (path) {\n                        if (fs.exists(path)) {\n                            fs.deleteFile(path);\n                        }\n                    });\n                }\n            }\n            return buildText;\n        },\n\n        optimizers: {\n            uglify: function (fileName, fileContents, outFileName, keepLines, config,fs) {\n                var result, existingMap, resultMap, finalMap, sourceIndex,\n                    uconfig = {},\n                    existingMapPath = outFileName + '.map',\n                    baseName = fileName && fileName.split('/').pop();\n\n                config = config || {};\n\n                lang.mixin(uconfig, config, true);\n\n                ///uconfig.fromString = true;  // uglify 2 -> 3\n\n                if (config.preamble) {\n                    uconfig.output = {preamble: config.preamble};\n                }\n\n                ///var fs = config.env.fs;\n\n                if (config.generateSourceMaps && (outFileName || config._buildSourceMap)) {\n                    uconfig.outSourceMap = baseName + '.map';\n\n                    if (config._buildSourceMap) {\n                        existingMap = JSON.parse(config._buildSourceMap);\n                        uconfig.inSourceMap = existingMap;\n                    } else if (fs.exists(existingMapPath)) {\n                        uconfig.inSourceMap = existingMapPath;\n                        existingMap = JSON.parse(fs.readFile(existingMapPath));\n                    }\n                }\n\n                logger.trace(\"Uglify file: \" + fileName);\n\n                try {\n                    //var tempContents = fileContents.replace(/\\/\\/\\# sourceMappingURL=.*$/, '');\n                    result = uglify.minify(fileContents, uconfig, baseName + '.src.js');\n                    if (uconfig.outSourceMap && result.map) {\n                        resultMap = result.map;\n                        if (!existingMap && !config._buildSourceMap) {\n                            fs.saveFile(outFileName + '.src.js', fileContents);\n                        }\n\n                        fileContents = result.code;\n\n                        if (config._buildSourceMap) {\n                            config._buildSourceMap = resultMap;\n                        } else {\n                            fs.saveFile(outFileName + '.map', resultMap);\n                        }\n                    } else {\n                        fileContents = result.code;\n                    }\n                } catch (e) {\n                    var errorString = e.toString();\n                    var isSyntaxError = /SyntaxError/.test(errorString);\n                    throw new Error('Cannot uglify file: ' + fileName +\n                                    '. Skipping it. Error is:\\n' + errorString +\n                                  (isSyntaxError ? '\\n\\n' + es5PlusGuidance : ''));\n                }\n                return fileContents;\n            }\n        }\n    };\n\n    return optimize;\n});\n\n/*global define */\n\ndefine('skylark-rjs/transform',[ \n    './esprima', \n    './parse', \n    './logger', \n    './lang'\n],\nfunction (esprima, parse, logger, lang) {\n    'use strict';\n    var transform,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                logger.trace('toTransport skipping ' + path + ': ' +\n                             e.toString());\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            logger.trace(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n\n/*jslint */\n/*global define: false, console: false */\n\ndefine('skylark-rjs/commonJs',[\n    './parse'\n], function (\n    parse\n) {\n    'use strict';\n    var commonJs = {\n        //Set to false if you do not want this file to log. Useful in environments\n        //like node where you want the work to happen without noise.\n        useLog: true,\n\n        convertDir: function (commonJsPath, savePath,fs) {\n            var fileList, i,\n                jsFileRegExp = /\\.js$/,\n                fileName, convertedFileName, fileContents;\n\n            //Get list of files to convert.\n            fileList = fs.getFilteredFileList(commonJsPath, /\\w/, true);\n\n            //Normalize on front slashes and make sure the paths do not end in a slash.\n            commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n            savePath = savePath.replace(/\\\\/g, \"/\");\n            if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n                commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n            }\n            if (savePath.charAt(savePath.length - 1) === \"/\") {\n                savePath = savePath.substring(0, savePath.length - 1);\n            }\n\n            //Cycle through all the JS files and convert them.\n            if (!fileList || !fileList.length) {\n                if (commonJs.useLog) {\n                    if (commonJsPath === \"convert\") {\n                        //A request just to convert one file.\n                        console.log('\\n\\n' + commonJs.convert(savePath, fs.readFile(savePath),config));\n                    } else {\n                        console.log(\"No files to convert in directory: \" + commonJsPath);\n                    }\n                }\n            } else {\n                for (i = 0; i < fileList.length; i++) {\n                    fileName = fileList[i];\n                    convertedFileName = fileName.replace(commonJsPath, savePath);\n\n                    //Handle JS files.\n                    if (jsFileRegExp.test(fileName)) {\n                        fileContents = fs.readFile(fileName);\n                        fileContents = commonJs.convert(fileName, fileContents,config);\n                        fs.saveUtf8File(convertedFileName, fileContents);\n                    } else {\n                        //Just copy the file over.\n                        fs.copyFile(fileName, convertedFileName, true);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Does the actual file conversion.\n         *\n         * @param {String} fileName the name of the file.\n         *\n         * @param {String} fileContents the contents of a file :)\n         *\n         * @returns {String} the converted contents\n         */\n        convert: function (fileName, fileContents) {\n            //Strip out comments.\n            try {\n                var preamble = '',\n                    commonJsProps = parse.usesCommonJs(fileName, fileContents);\n\n                //First see if the module is not already RequireJS-formatted.\n                if (parse.usesAmdOrRequireJs(fileName, fileContents) || !commonJsProps) {\n                    return fileContents;\n                }\n\n                if (commonJsProps.dirname || commonJsProps.filename) {\n                    preamble = 'var __filename = module.uri || \"\", ' +\n                               '__dirname = __filename.substring(0, __filename.lastIndexOf(\"/\") + 1); ';\n                }\n\n                //Construct the wrapper boilerplate.\n                fileContents = 'define(function (require, exports, module) {' +\n                    preamble +\n                    fileContents +\n                    '\\n});\\n';\n\n            } catch (e) {\n                console.log(\"commonJs.convert: COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n                return fileContents;\n            }\n\n            return fileContents;\n        }\n    };\n\n    return commonJs;\n});\n\n/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine('skylark-rjs/requirePatch',[ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true  */\n/*global define, requirejs, java, process, console */\n\n\ndefine('skylark-rjs/build',[\n    \"./rjs\",\n    \"./lang\",\n    \"./prim\",\n    \"./logger\",\n    ///\"env!env/file\",\n    \"./parse\",\n    \"./optimize\",\n    \"./pragma\",\n    \"./transform\",\n    \"./requirePatch\",\n    ///\"env\",\n    \"./commonJs\",\n    \"./source-map\"\n],function (\n    require,\n    lang,\n    prim,\n    logger,\n    parse,\n    optimize,\n    pragma,\n    transform,\n    requirePatch,\n    commonJs,\n    sourceMap\n\n) {\n    'use strict';\n\n    var build,\n        ///lang = require('lang'),\n        ///prim = require('prim'),\n        ///logger = require('logger'),\n        ///file = require('env!env/file'),\n        ///parse = require('parse'),\n        ///optimize = require('optimize'),\n        ///pragma = require('pragma'),\n        ///transform = require('transform'),\n        ///requirePatch = require('requirePatch'),\n        ///env = require('env'),\n        ///commonJs = require('commonJs'),\n        ///SourceMapGenerator = require('source-map').SourceMapGenerator,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        hasProp = lang.hasProp,\n        getOwn = lang.getOwn,\n        falseProp = lang.falseProp,\n        endsWithSemiColonRegExp = /;\\s*$/,\n        endsWithSlashRegExp = /[\\/\\\\]$/,\n        resourceIsModuleIdRegExp = /^[\\w\\/\\\\\\.]+$/,\n        deepCopyProps = {\n            layer: true\n        };\n\n    //Deep copy a config object, but do not copy over the \"layer\" property,\n    //as it can be a deeply nested structure with a full requirejs context.\n    function copyConfig(obj) {\n        return lang.deeplikeCopy(obj, deepCopyProps);\n    }\n\n    prim.nextTick = function (fn) {\n        fn();\n    };\n\n    //Now map require to the outermost requirejs, now that we have\n    //local dependencies for this module. The rest of the require use is\n    //manipulating the requirejs loader.\n    ///require = requirejs;\n\n    //Caching function for performance. Attached to\n    //require so it can be reused in requirePatch.js. _cachedRawText\n    //set up by requirePatch.js\n    require._cacheReadAsync = function (path, encoding,fs) {\n        var d;\n\n        if (lang.hasProp(require._cachedRawText, path)) {\n            d = prim();\n            d.resolve(require._cachedRawText[path]);\n            return d.promise;\n        } else {\n            return fs.readFileAsync(path, encoding).then(function (text) {\n                require._cachedRawText[path] = text;\n                return text;\n            });\n        }\n    };\n\n    function makeBuildBaseConfig(fs) {\n        return {\n            appDir: \"\",\n            pragmas: {},\n            paths: {},\n            optimize: \"uglify\",\n            optimizeCss: \"standard.keepLines.keepWhitespace\",\n            inlineText: true,\n            isBuild: true,\n            optimizeAllPluginResources: false,\n            findNestedDependencies: false,\n            preserveLicenseComments: true,\n            writeBuildTxt: true,\n            //Some builds can take a while, up the default limit.\n            waitSeconds: 30,\n            //By default, all files/directories are copied, unless\n            //they match this regexp, by default just excludes .folders\n            dirExclusionRegExp: fs.dirExclusionRegExp,\n            _buildPathToModuleIndex: {}\n        };\n    }\n\n    /**\n     * Some JS may not be valid if concatenated with other JS, in particular\n     * the style of omitting semicolons and rely on ASI. Add a semicolon in\n     * those cases.\n     */\n    function addSemiColon(text, config) {\n        if (config.skipSemiColonInsertion || endsWithSemiColonRegExp.test(text)) {\n            return text;\n        } else {\n            return text + \";\";\n        }\n    }\n\n    function endsWithSlash(dirName) {\n        if (dirName.charAt(dirName.length - 1) !== \"/\") {\n            dirName += \"/\";\n        }\n        return dirName;\n    }\n\n    function endsWithNewLine(text) {\n        if (text.charAt(text.length - 1) !== \"\\n\") {\n            text += \"\\n\";\n        }\n        return text;\n    }\n\n    //Method used by plugin writeFile calls, defined up here to avoid\n    //jslint warning about \"making a function in a loop\".\n    function makeWriteFile(namespace, layer) {\n        function writeFile(name, contents) {\n            logger.trace('Saving plugin-optimized file: ' + name);\n            file.saveUtf8File(name, contents);\n        }\n\n        writeFile.asModule = function (moduleName, fileName, contents) {\n            writeFile(fileName,\n                build.toTransport(namespace, moduleName, fileName, contents, layer));\n        };\n\n        return writeFile;\n    }\n\n    /**\n     * Appends singleContents to fileContents and returns the result.  If a sourceMapGenerator\n     * is provided, adds singleContents to the source map.\n     *\n     * @param {string} fileContents - The file contents to which to append singleContents\n     * @param {string} singleContents - The additional contents to append to fileContents\n     * @param {string} path - An absolute path of a file whose name to use in the source map.\n     * The file need not actually exist if the code in singleContents is generated.\n     * @param {{out: ?string, baseUrl: ?string}} config - The build configuration object.\n     * @param {?{_buildPath: ?string}} module - An object with module information.\n     * @param {?SourceMapGenerator} sourceMapGenerator - An instance of Mozilla's SourceMapGenerator,\n     * or null if no source map is being generated.\n     * @returns {string} fileContents with singleContents appended\n     */\n    function appendToFileContents(fileContents, singleContents, path, config, module, sourceMapGenerator) {\n        var refPath, sourceMapPath, resourcePath, pluginId, sourceMapLineNumber, lineCount, parts, i;\n        if (sourceMapGenerator) {\n            if (config.out) {\n                refPath = config.baseUrl;\n            } else if (module && module._buildPath) {\n                refPath = module._buildPath;\n            } else {\n                refPath = \"\";\n            }\n            parts = path.split('!');\n            if (parts.length === 1) {\n                //Not a plugin resource, fix the path\n                sourceMapPath = build.makeRelativeFilePath(refPath, path);\n            } else {\n                //Plugin resource. If it looks like just a plugin\n                //followed by a module ID, pull off the plugin\n                //and put it at the end of the name, otherwise\n                //just leave it alone.\n                pluginId = parts.shift();\n                resourcePath = parts.join('!');\n                if (resourceIsModuleIdRegExp.test(resourcePath)) {\n                    sourceMapPath = build.makeRelativeFilePath(refPath, require.toUrl(resourcePath)) +\n                                    '!' + pluginId;\n                } else {\n                    sourceMapPath = path;\n                }\n            }\n\n            sourceMapLineNumber = fileContents.split('\\n').length - 1;\n            lineCount = singleContents.split('\\n').length;\n            for (i = 1; i <= lineCount; i += 1) {\n                sourceMapGenerator.addMapping({\n                    generated: {\n                        line: sourceMapLineNumber + i,\n                        column: 0\n                    },\n                    original: {\n                        line: i,\n                        column: 0\n                    },\n                    source: sourceMapPath\n                });\n            }\n\n            //Store the content of the original in the source\n            //map since other transforms later like minification\n            //can mess up translating back to the original\n            //source.\n            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);\n        }\n        fileContents += singleContents;\n        return fileContents;\n    }\n\n    /**\n     * Main API entry point into the build. The args argument can either be\n     * an array of arguments (like the onese passed on a command-line),\n     * or it can be a JavaScript object that has the format of a build profile\n     * file.\n     *\n     * If it is an object, then in addition to the normal properties allowed in\n     * a build profile file, the object should contain one other property:\n     *\n     * The object could also contain a \"buildFile\" property, which is a string\n     * that is the file path to a build profile that contains the rest\n     * of the build profile directives.\n     *\n     * This function does not return a status, it should throw an error if\n     * there is a problem completing the build.\n     */\n    build = function (args) {\n        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,\n            i, j, errorMod,\n            stackRegExp = /( {4}at[^\\n]+)\\n/,\n            standardIndent = '  ';\n\n        return prim().start(function () {\n            if (!args || lang.isArray(args)) {\n                if (!args || args.length < 1) {\n                    logger.error(\"build.js buildProfile.js\\n\" +\n                          \"where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).\");\n                    return undefined;\n                }\n\n                //Next args can include a build file path as well as other build args.\n                //build file path comes first. If it does not contain an = then it is\n                //a build file path. Otherwise, just all build args.\n                if (args[0].indexOf(\"=\") === -1) {\n                    buildFile = args[0];\n                    args.splice(0, 1);\n                }\n\n                //Remaining args are options to the build\n                cmdConfig = build.convertArrayToObject(args);\n                cmdConfig.buildFile = buildFile;\n            } else {\n                cmdConfig = args;\n            }\n\n            return build._run(cmdConfig);\n        }).then(null, function (e) {\n            var err;\n\n            errorMsg = e.toString();\n            errorTree = e.moduleTree;\n            stackMatch = stackRegExp.exec(errorMsg);\n\n            if (stackMatch) {\n                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);\n            }\n\n            //If a module tree that shows what module triggered the error,\n            //print it out.\n            if (errorTree && errorTree.length > 0) {\n                errorMsg += '\\nIn module tree:\\n';\n\n                for (i = errorTree.length - 1; i > -1; i--) {\n                    errorMod = errorTree[i];\n                    if (errorMod) {\n                        for (j = errorTree.length - i; j > -1; j--) {\n                            errorMsg += standardIndent;\n                        }\n                        errorMsg += errorMod + '\\n';\n                    }\n                }\n\n                logger.error(errorMsg);\n            }\n\n            errorStack = e.stack;\n\n            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {\n                errorMsg += '\\n' + errorStack;\n            } else {\n                if (!stackMatch && errorStack) {\n                    //Just trim out the first \"at\" in the stack.\n                    stackMatch = stackRegExp.exec(errorStack);\n                    if (stackMatch) {\n                        errorMsg += '\\n' + stackMatch[0] || '';\n                    }\n                }\n            }\n\n            err = new Error(errorMsg);\n            err.originalError = e;\n            throw err;\n        });\n    };\n\n    build._run = function (cmdConfig) {\n        var buildPaths, fileName, fileNames,\n            paths, i,\n            baseConfig, config,\n            modules, srcPath, buildContext,\n            destPath, moduleMap, parentModuleMap, context,\n            resources, resource, plugin, fileContents,\n            pluginProcessed = {},\n            buildFileContents = \"\",\n            pluginCollector = {},\n            fs;\n\n        return prim().start(function () {\n            var prop;\n\n            //Can now run the patches to require.js to allow it to be used for\n            //build generation. Do it here instead of at the top of the module\n            //because we want normal require behavior to load the build tool\n            //then want to switch to build mode.\n\n            config = build.createConfig(cmdConfig);\n            paths = config.paths;\n            fs = config.env.fs;\n\n            requirePatch(config);\n\n\n            //Remove the previous build dir, in case it contains source transforms,\n            //like the ones done with onBuildRead and onBuildWrite.\n            if (config.dir && !config.keepBuildDir && fs.exists(config.dir)) {\n                fs.deleteFile(config.dir);\n            }\n\n            if (!config.out && !config.cssIn) {\n                //This is not just a one-off file build but a full build profile, with\n                //lots of files to process.\n\n                //First copy all the baseUrl content\n                fs.copyDir((config.appDir || config.baseUrl), config.dir, /\\w/, true);\n\n                //Adjust baseUrl if config.appDir is in play, and set up build output paths.\n                buildPaths = {};\n                if (config.appDir) {\n                    //All the paths should be inside the appDir, so just adjust\n                    //the paths to use the dirBaseUrl\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);\n                        }\n                    }\n                } else {\n                    //If no appDir, then make sure to copy the other paths to this directory.\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            //Set up build path for each path prefix, but only do so\n                            //if the path falls out of the current baseUrl\n                            if (paths[prop].indexOf(config.baseUrl) === 0) {\n                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);\n                            } else {\n                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop;\n\n                                //Make sure source path is fully formed with baseUrl,\n                                //if it is a relative URL.\n                                srcPath = paths[prop];\n                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {\n                                    srcPath = config.baseUrl + srcPath;\n                                }\n\n                                destPath = config.dirBaseUrl + buildPaths[prop];\n\n                                //Skip empty: paths\n                                if (srcPath !== 'empty:') {\n                                    //If the srcPath is a directory, copy the whole directory.\n                                    if (fs.exists(srcPath) && fs.isDirectory(srcPath)) {\n                                        //Copy files to build area. Copy all files (the /\\w/ regexp)\n                                        fs.copyDir(srcPath, destPath, /\\w/, true);\n                                    } else {\n                                        //Try a .js extension\n                                        srcPath += '.js';\n                                        destPath += '.js';\n                                        fs.copyFile(srcPath, destPath);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            //Figure out source file location for each module layer. Do this by seeding require\n            //with source area configuration. This is needed so that later the module layers\n            //can be manually copied over to the source area, since the build may be\n            //require multiple times and the above copyDir call only copies newer files.\n            require({\n                baseUrl: config.baseUrl,\n                paths: paths,\n                packagePaths: config.packagePaths,\n                packages: config.packages\n            });\n            buildContext = require.s.contexts._;\n            modules = config.modules;\n\n            if (modules) {\n                modules.forEach(function (module) {\n                    if (module.name) {\n                        module._sourcePath = buildContext.nameToUrl(module.name);\n                        //If the module does not exist, and this is not a \"new\" module layer,\n                        //as indicated by a true \"create\" property on the module, and\n                        //it is not a plugin-loaded resource, and there is no\n                        //'rawText' containing the module's source then throw an error.\n                        if (!fs.exists(module._sourcePath) && !module.create &&\n                                module.name.indexOf('!') === -1 &&\n                                (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                            throw new Error(\"ERROR: module path does not exist: \" +\n                                            module._sourcePath + \" for module named: \" + module.name +\n                                            \". Path is relative to: \" + fs.absPath('.'));\n                        }\n                    }\n                });\n            }\n\n            if (config.out) {\n                //Just set up the _buildPath for the module layer.\n                require(config);\n                if (!config.cssIn) {\n                    config.modules[0]._buildPath = typeof config.out === 'function' ?\n                                                   'FUNCTION' : config.out;\n                }\n            } else if (!config.cssIn) {\n                //Now set up the config for require to use the build area, and calculate the\n                //build file locations. Pass along any config info too.\n                baseConfig = {\n                    baseUrl: config.dirBaseUrl,\n                    paths: buildPaths\n                };\n\n                lang.mixin(baseConfig, config);\n                require(baseConfig);\n\n                if (modules) {\n                    modules.forEach(function (module) {\n                        if (module.name) {\n                            module._buildPath = buildContext.nameToUrl(module.name, null);\n\n                            //If buildPath and sourcePath are the same, throw since this\n                            //would result in modifying source. This condition can happen\n                            //with some more tricky paths: config and appDir/baseUrl\n                            //setting, which is a sign of incorrect config.\n                            if (module._buildPath === module._sourcePath &&\n                                !config.allowSourceOverwrites) {\n                                throw new Error('Module ID \\'' + module.name  +\n                                                '\\' has a source path that is same as output path: ' +\n                                                module._sourcePath +\n                                                '. Stopping, config is malformed.');\n                            }\n\n                            // Copy the file, but only if it is not provided in rawText.\n                            if (!module.create && (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                                fs.copyFile(module._sourcePath, module._buildPath);\n                            }\n                        }\n                    });\n                }\n            }\n\n            //Run CSS optimizations before doing JS module tracing, to allow\n            //things like text loader plugins loading CSS to get the optimized\n            //CSS.\n            if (config.optimizeCss && config.optimizeCss !== \"none\" && config.dir) {\n                buildFileContents += optimize.css(config.dir, config);\n            }\n        }).then(function() {\n            baseConfig = copyConfig(require.s.contexts._.config);\n        }).then(function () {\n            var actions = [];\n\n            if (modules) {\n                actions = modules.map(function (module, i) {\n                    return function () {\n                        //Save off buildPath to module index in a hash for quicker\n                        //lookup later.\n                        config._buildPathToModuleIndex[fs.normalize(module._buildPath)] = i;\n\n                        //Call require to calculate dependencies.\n                        return build.traceDependencies(module, config, baseConfig)\n                            .then(function (layer) {\n                                module.layer = layer;\n                            });\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            var actions;\n\n            if (modules) {\n                //Now build up shadow layers for anything that should be excluded.\n                //Do this after tracing dependencies for each module, in case one\n                //of those modules end up being one of the excluded values.\n                actions = modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            module.excludeLayers = [];\n                            return prim.serial(module.exclude.map(function (exclude, i) {\n                                return function () {\n                                    //See if it is already in the list of modules.\n                                    //If not trace dependencies for it.\n                                    var found = build.findBuildModule(exclude, modules);\n                                    if (found) {\n                                        module.excludeLayers[i] = found;\n                                    } else {\n                                        return build.traceDependencies({name: exclude}, config, baseConfig)\n                                            .then(function (layer) {\n                                                module.excludeLayers[i] = { layer: layer };\n                                            });\n                                    }\n                                };\n                            }));\n                        }\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            if (modules) {\n                return prim.serial(modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            //module.exclude is an array of module names. For each one,\n                            //get the nested dependencies for it via a matching entry\n                            //in the module.excludeLayers array.\n                            module.exclude.forEach(function (excludeModule, i) {\n                                var excludeLayer = module.excludeLayers[i].layer,\n                                    map = excludeLayer.buildFileToModule;\n                                excludeLayer.buildFilePaths.forEach(function(filePath){\n                                    build.removeModulePath(map[filePath], filePath, module.layer);\n                                });\n                            });\n                        }\n                        if (module.excludeShallow) {\n                            //module.excludeShallow is an array of module names.\n                            //shallow exclusions are just that module itself, and not\n                            //its nested dependencies.\n                            module.excludeShallow.forEach(function (excludeShallowModule) {\n                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);\n                                if (path) {\n                                    build.removeModulePath(excludeShallowModule, path, module.layer);\n                                }\n                            });\n                        }\n\n                        //Flatten them and collect the build output for each module.\n                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {\n                            var finalText, baseName;\n                            //Save it to a temp file for now, in case there are other layers that\n                            //contain optimized content that should not be included in later\n                            //layer optimizations. See issue #56.\n                            if (module._buildPath === 'FUNCTION') {\n                                module._buildText = builtModule.text;\n                                module._buildSourceMap = builtModule.sourceMap;\n                            } else {\n                                finalText = builtModule.text;\n                                if (builtModule.sourceMap) {\n                                    baseName = module._buildPath.split('/');\n                                    baseName = baseName.pop();\n                                    finalText += '\\n//# sourceMappingURL=' + baseName + '.map';\n                                    fs.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);\n                                }\n                                fs.saveUtf8File(module._buildPath + '-temp', finalText);\n\n                            }\n                            buildFileContents += builtModule.buildText;\n                        });\n                    };\n                }));\n            }\n        }).then(function () {\n            var moduleName, outOrigSourceMap,\n                bundlesConfig = {},\n                bundlesConfigOutFile = config.bundlesConfigOutFile;\n\n            if (modules) {\n                //Now move the build layers to their final position.\n                modules.forEach(function (module) {\n                    var entryConfig,\n                        finalPath = module._buildPath;\n\n                    if (finalPath !== 'FUNCTION') {\n                        if (fs.exists(finalPath)) {\n                            fs.deleteFile(finalPath);\n                        }\n                        fs.renameFile(finalPath + '-temp', finalPath);\n\n                        //If bundles config should be written out, scan the\n                        //built file for module IDs. Favor doing this reparse\n                        //since tracking the IDs as the file is built has some\n                        //edge cases around files that had more than one ID in\n                        //them already, and likely loader plugin-written contents.\n                        if (bundlesConfigOutFile) {\n                            entryConfig = bundlesConfig[module.name] = [];\n                            var bundleContents = fs.readFile(finalPath);\n                            var excludeMap = {};\n                            excludeMap[module.name] = true;\n                            var parsedIds = parse.getAllNamedDefines(bundleContents, excludeMap);\n                            entryConfig.push.apply(entryConfig, parsedIds);\n                        }\n\n                        //And finally, if removeCombined is specified, remove\n                        //any of the files that were used in this layer.\n                        //Be sure not to remove other build layers.\n                        if (config.removeCombined && !config.out) {\n                            module.layer.buildFilePaths.forEach(function (path) {\n                                var isLayer = modules.some(function (mod) {\n                                        return mod._buildPath === path;\n                                    }),\n                                    relPath = build.makeRelativeFilePath(config.dir, path);\n\n                                if (fs.exists(path) &&\n                                    // not a build layer target\n                                    !isLayer &&\n                                    // not outside the build directory\n                                    relPath.indexOf('..') !== 0) {\n                                    fs.deleteFile(path);\n                                }\n                            });\n                        }\n                    }\n\n                    //Signal layer is done\n                    if (config.onModuleBundleComplete) {\n                        config.onModuleBundleComplete(module.onCompleteData);\n                    }\n                });\n\n                //Write out bundles config, if it is wanted.\n                if (bundlesConfigOutFile) {\n                    var text = fs.readFile(bundlesConfigOutFile);\n                    text = transform.modifyConfig(text, function (config) {\n                        if (!config.bundles) {\n                            config.bundles = {};\n                        }\n\n                        lang.eachProp(bundlesConfig, function (value, prop) {\n                            config.bundles[prop] = value;\n                        });\n\n                        return config;\n                    });\n\n                    fs.saveUtf8File(bundlesConfigOutFile, text);\n                }\n            }\n\n            //If removeCombined in play, remove any empty directories that\n            //may now exist because of its use\n            if (config.removeCombined && !config.out && config.dir) {\n                fs.deleteEmptyDirs(config.dir);\n            }\n\n            //Do other optimizations.\n            if (config.out && !config.cssIn) {\n                //Just need to worry about one JS file.\n                fileName = config.modules[0]._buildPath;\n                if (fileName === 'FUNCTION') {\n                    outOrigSourceMap = config.modules[0]._buildSourceMap;\n                    config._buildSourceMap = outOrigSourceMap;\n                    config.modules[0]._buildText = optimize.js((config.modules[0].name ||\n                                                                config.modules[0].include[0] ||\n                                                                fileName) + '.build.js',\n                                                               config.modules[0]._buildText,\n                                                               null,\n                                                               config);\n                    if (config._buildSourceMap && config._buildSourceMap !== outOrigSourceMap) {\n                        config.modules[0]._buildSourceMap = config._buildSourceMap;\n                        config._buildSourceMap = null;\n                    }\n                } else {\n                    optimize.jsFile(fileName, null, fileName, config);\n                }\n            } else if (!config.cssIn) {\n                //Normal optimizations across modules.\n\n                //JS optimizations.\n                fileNames = fs.getFilteredFileList(config.dir, /\\.js$/, true);\n                fileNames.forEach(function (fileName) {\n                    var cfg, override, moduleIndex;\n\n                    //Generate the module name from the config.dir root.\n                    moduleName = fileName.replace(config.dir, '');\n                    //Get rid of the extension\n                    moduleName = moduleName.substring(0, moduleName.length - 3);\n\n                    //If there is an override for a specific layer build module,\n                    //and this file is that module, mix in the override for use\n                    //by optimize.jsFile.\n                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);\n                    //Normalize, since getOwn could have returned undefined\n                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;\n\n                    //Try to avoid extra work if the other files do not need to\n                    //be read. Build layers should be processed at the very\n                    //least for optimization.\n                    if (moduleIndex > -1 || !config.skipDirOptimize ||\n                            config.normalizeDirDefines === \"all\" ||\n                            config.cjsTranslate) {\n                        //Convert the file to transport format, but without a name\n                        //inserted (by passing null for moduleName) since the files are\n                        //standalone, one module per file.\n                        fileContents = fs.readFile(fileName);\n\n\n                        //For builds, if wanting cjs translation, do it now, so that\n                        //the individual modules can be loaded cross domain via\n                        //plain script tags.\n                        if (config.cjsTranslate &&\n                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                            fileContents = commonJs.convert(fileName, fileContents);\n                        }\n\n                        if (moduleIndex === -1) {\n                            if (config.onBuildRead) {\n                                fileContents = config.onBuildRead(moduleName,\n                                                                  fileName,\n                                                                  fileContents);\n                            }\n\n                            //Only do transport normalization if this is not a build\n                            //layer (since it was already normalized) and if\n                            //normalizeDirDefines indicated all should be done.\n                            if (config.normalizeDirDefines === \"all\") {\n                                fileContents = build.toTransport(config.namespace,\n                                                             null,\n                                                             fileName,\n                                                             fileContents);\n                            }\n\n                            if (config.onBuildWrite) {\n                                fileContents = config.onBuildWrite(moduleName,\n                                                                   fileName,\n                                                                   fileContents);\n                            }\n                        }\n\n                        override = moduleIndex > -1 ?\n                                   config.modules[moduleIndex].override : null;\n                        if (override) {\n                            cfg = build.createOverrideConfig(config, override);\n                        } else {\n                            cfg = config;\n                        }\n\n                        if (moduleIndex > -1 || !config.skipDirOptimize) {\n                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);\n                        }\n                    }\n                });\n\n                //Normalize all the plugin resources.\n                context = require.s.contexts._;\n\n                for (moduleName in pluginCollector) {\n                    if (hasProp(pluginCollector, moduleName)) {\n                        parentModuleMap = context.makeModuleMap(moduleName);\n                        resources = pluginCollector[moduleName];\n                        for (i = 0; i < resources.length; i++) {\n                            resource = resources[i];\n                            moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            if (falseProp(context.plugins, moduleMap.prefix)) {\n                                //Set the value in context.plugins so it\n                                //will be evaluated as a full plugin.\n                                context.plugins[moduleMap.prefix] = true;\n\n                                //Do not bother if the plugin is not available.\n                                if (!fs.exists(require.toUrl(moduleMap.prefix + '.js'))) {\n                                    continue;\n                                }\n\n                                //Rely on the require in the build environment\n                                //to be synchronous\n                                context.require([moduleMap.prefix]);\n\n                                //Now that the plugin is loaded, redo the moduleMap\n                                //since the plugin will need to normalize part of the path.\n                                moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            }\n\n                            //Only bother with plugin resources that can be handled\n                            //processed by the plugin, via support of the writeFile\n                            //method.\n                            if (falseProp(pluginProcessed, moduleMap.id)) {\n                                //Only do the work if the plugin was really loaded.\n                                //Using an internal access because the file may\n                                //not really be loaded.\n                                plugin = getOwn(context.defined, moduleMap.prefix);\n                                if (plugin && plugin.writeFile) {\n                                    plugin.writeFile(\n                                        moduleMap.prefix,\n                                        moduleMap.name,\n                                        require,\n                                        makeWriteFile(\n                                            config.namespace\n                                        ),\n                                        context.config\n                                    );\n                                }\n\n                                pluginProcessed[moduleMap.id] = true;\n                            }\n                        }\n\n                    }\n                }\n\n                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, \"  \"));\n\n\n                //All module layers are done, write out the build.txt file.\n                if (config.writeBuildTxt) {\n                    fs.saveUtf8File(config.dir + \"build.txt\", buildFileContents);\n                }\n            }\n\n            //If just have one CSS file to optimize, do that here.\n            if (config.cssIn) {\n                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;\n            }\n\n            if (typeof config.out === 'function') {\n                config.out(config.modules[0]._buildText, config.modules[0]._buildSourceMap);\n            }\n\n            //Print out what was built into which layers.\n            if (buildFileContents) {\n                logger.info(buildFileContents);\n                return buildFileContents;\n            }\n\n            return '';\n        });\n    };\n\n    /**\n     * Converts command line args like \"paths.foo=../some/path\"\n     * result.paths = { foo: '../some/path' } where prop = paths,\n     * name = paths.foo and value = ../some/path, so it assumes the\n     * name=value splitting has already happened.\n     */\n    function stringDotToObj(result, name, value) {\n        var parts = name.split('.');\n\n        parts.forEach(function (prop, i) {\n            if (i === parts.length - 1) {\n                result[prop] = value;\n            } else {\n                if (falseProp(result, prop)) {\n                    result[prop] = {};\n                }\n                result = result[prop];\n            }\n\n        });\n    }\n\n    build.objProps = {\n        paths: true,\n        wrap: true,\n        pragmas: true,\n        pragmasOnSave: true,\n        has: true,\n        hasOnSave: true,\n        uglify: true,\n        uglify2: true,\n        closure: true,\n        map: true,\n        throwWhen: true,\n        rawText: true\n    };\n\n    build.hasDotPropMatch = function (prop) {\n        var dotProp,\n            index = prop.indexOf('.');\n\n        if (index !== -1) {\n            dotProp = prop.substring(0, index);\n            return hasProp(build.objProps, dotProp);\n        }\n        return false;\n    };\n\n    /**\n     * Converts an array that has String members of \"name=value\"\n     * into an object, where the properties on the object are the names in the array.\n     * Also converts the strings \"true\" and \"false\" to booleans for the values.\n     * member name/value pairs, and converts some comma-separated lists into\n     * arrays.\n     * @param {Array} ary\n     */\n    build.convertArrayToObject = function (ary) {\n        var result = {}, i, separatorIndex, prop, value,\n            needArray = {\n                \"include\": true,\n                \"exclude\": true,\n                \"excludeShallow\": true,\n                \"insertRequire\": true,\n                \"stubModules\": true,\n                \"deps\": true,\n                \"mainConfigFile\": true,\n                \"wrap.startFile\": true,\n                \"wrap.endFile\": true\n            };\n\n        for (i = 0; i < ary.length; i++) {\n            separatorI.ndex = ary[i].indexOf(\"=\");\n            if (separatorIndex === -1) {\n                throw \"Malformed name/value pair: [\" + ary[i] + \"]. Format should be name=value\";\n            }\n\n            value = ary[i].substring(separatorIndex + 1, ary[i].length);\n            if (value === \"true\") {\n                value = true;\n            } else if (value === \"false\") {\n                value = false;\n            }\n\n            prop = ary[i].substring(0, separatorIndex);\n\n            //Convert to array if necessary\n            if (getOwn(needArray, prop)) {\n                value = value.split(\",\");\n            }\n\n            if (build.hasDotPropMatch(prop)) {\n                stringDotToObj(result, prop, value);\n            } else {\n                result[prop] = value;\n            }\n        }\n        return result; //Object\n    };\n\n    build.makeAbsPath = function (path, absFilePath,fs) {\n        if (!absFilePath) {\n            return path;\n        }\n\n        //Add abspath if necessary. If path starts with a slash or has a colon,\n        //then already is an abolute path.\n        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {\n            path = absFilePath +\n                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +\n                   path;\n            path = fs.normalize(path);\n        }\n        return path.replace(lang.backSlashRegExp, '/');\n    };\n\n    build.makeAbsObject = function (props, obj, absFilePath,fs) {\n        var i, prop;\n        if (obj) {\n            for (i = 0; i < props.length; i++) {\n                prop = props[i];\n                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {\n                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath,fs);\n                }\n            }\n        }\n    };\n\n    /**\n     * For any path in a possible config, make it absolute relative\n     * to the absFilePath passed in.\n     */\n    build.makeAbsConfig = function (config, absFilePath,fs) {\n        var props, prop, i;\n\n        props = [\"appDir\", \"dir\", \"baseUrl\"];\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n\n            if (getOwn(config, prop)) {\n                //Add abspath if necessary, make sure these paths end in\n                //slashes\n                if (prop === \"baseUrl\") {\n                    config.originalBaseUrl = config.baseUrl;\n                    if (config.appDir) {\n                        //If baseUrl with an appDir, the baseUrl is relative to\n                        //the appDir, *not* the absFilePath. appDir and dir are\n                        //made absolute before baseUrl, so this will work.\n                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir,fs);\n                    } else {\n                        //The dir output baseUrl is same as regular baseUrl, both\n                        //relative to the absFilePath.\n                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath,fs);\n                    }\n                } else {\n                    config[prop] = build.makeAbsPath(config[prop], absFilePath,fs);\n                }\n\n                config[prop] = endsWithSlash(config[prop]);\n            }\n        }\n\n        build.makeAbsObject((config.out === \"stdout\" ? [\"cssIn\"] : [\"out\", \"cssIn\"]),\n                            config, absFilePath,fs);\n        build.makeAbsObject([\"startFile\", \"endFile\"], config.wrap, absFilePath,fs);\n        build.makeAbsObject([\"externExportsPath\"], config.closure, absFilePath,fs);\n    };\n\n    /**\n     * Creates a relative path to targetPath from refPath.\n     * Only deals with file paths, not folders. If folders,\n     * make sure paths end in a trailing '/'.\n     */\n    build.makeRelativeFilePath = function (refPath, targetPath,fs) {\n        var i, dotLength, finalParts, length, targetParts, targetName,\n            refParts = refPath.split('/'),\n            hasEndSlash = endsWithSlashRegExp.test(targetPath),\n            dotParts = [];\n\n        targetPath = fs.normalize(targetPath);\n        if (hasEndSlash && !endsWithSlashRegExp.test(targetPath)) {\n            targetPath += '/';\n        }\n        targetParts = targetPath.split('/');\n        //Pull off file name\n        targetName = targetParts.pop();\n\n        //Also pop off the ref file name to make the matches against\n        //targetParts equivalent.\n        refParts.pop();\n\n        length = refParts.length;\n\n        for (i = 0; i < length; i += 1) {\n            if (refParts[i] !== targetParts[i]) {\n                break;\n            }\n        }\n\n        //Now i is the index in which they diverge.\n        finalParts = targetParts.slice(i);\n\n        dotLength = length - i;\n        for (i = 0; i > -1 && i < dotLength; i += 1) {\n            dotParts.push('..');\n        }\n\n        return dotParts.join('/') + (dotParts.length ? '/' : '') +\n               finalParts.join('/') + (finalParts.length ? '/' : '') +\n               targetName;\n    };\n\n    build.nestedMix = {\n        paths: true,\n        has: true,\n        hasOnSave: true,\n        pragmas: true,\n        pragmasOnSave: true\n    };\n\n    /**\n     * Mixes additional source config into target config, and merges some\n     * nested config, like paths, correctly.\n     */\n    function mixConfig(target, source, skipArrays) {\n        var prop, value, isArray, targetValue;\n\n        for (prop in source) {\n            if (hasProp(source, prop)) {\n                //If the value of the property is a plain object, then\n                //allow a one-level-deep mixing of it.\n                value = source[prop];\n                isArray = lang.isArray(value);\n                if (typeof value === 'object' && value &&\n                        !isArray && !lang.isFunction(value) &&\n                        !lang.isRegExp(value)) {\n\n                    // TODO: need to generalize this work, maybe also reuse\n                    // the work done in requirejs configure, perhaps move to\n                    // just a deep copy/merge overall. However, given the\n                    // amount of observable change, wait for a dot release.\n                    // This change is in relation to #645\n                    if (prop === 'map') {\n                        if (!target.map) {\n                            target.map = {};\n                        }\n                        lang.deepMix(target.map, source.map);\n                    } else {\n                        target[prop] = lang.mixin({}, target[prop], value, true);\n                    }\n                } else if (isArray) {\n                    if (!skipArrays) {\n                        // Some config, like packages, are arrays. For those,\n                        // just merge the results.\n                        targetValue = target[prop];\n                        if (lang.isArray(targetValue)) {\n                            target[prop] = targetValue.concat(value);\n                        } else {\n                            target[prop] = value;\n                        }\n                    }\n                } else {\n                    target[prop] = value;\n                }\n            }\n        }\n\n        //Set up log level since it can affect if errors are thrown\n        //or caught and passed to errbacks while doing config setup.\n        if (lang.hasProp(target, 'logLevel')) {\n            logger.logLevel(target.logLevel);\n        }\n    }\n\n    /**\n     * Converts a wrap.startFile or endFile to be start/end as a string.\n     * the startFile/endFile values can be arrays.\n     */\n    function flattenWrapFile(config, keyName, absFilePath) {\n        var wrap = config.wrap,\n            keyFileName = keyName + 'File',\n            keyMapName = '__' + keyName + 'Map',\n            fs = config.env.fs;\n\n        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {\n            wrap[keyName] = '';\n            if (typeof wrap[keyFileName] === 'string') {\n                wrap[keyFileName] = [wrap[keyFileName]];\n            }\n            wrap[keyMapName] = [];\n            wrap[keyFileName].forEach(function (fileName) {\n                var absPath = build.makeAbsPath(fileName, absFilePath,fs),\n                    fileText = endsWithNewLine(fs.readFile(absPath));\n                wrap[keyMapName].push(function (fileContents, cfg, sourceMapGenerator) {\n                    return appendToFileContents(fileContents, fileText, absPath, cfg, null, sourceMapGenerator);\n                });\n                wrap[keyName] += fileText;\n            });\n        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {\n            //Allow missing one, just set to empty string.\n            wrap[keyName] = '';\n        } else if (typeof wrap[keyName] === 'string') {\n            wrap[keyName] = endsWithNewLine(wrap[keyName]);\n            wrap[keyMapName] = [\n                function (fileContents, cfg, sourceMapGenerator) {\n                    var absPath = build.makeAbsPath(\"config-wrap-\" + keyName + \"-default.js\", absFilePath,fs);\n                    return appendToFileContents(fileContents, wrap[keyName], absPath, cfg, null, sourceMapGenerator);\n                }\n            ];\n        } else {\n            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');\n        }\n    }\n\n    function normalizeWrapConfig(config, absFilePath) {\n        //Get any wrap text.\n        var fs = config.env.fs;\n        try {\n            if (config.wrap) {\n                if (config.wrap === true) {\n                    //Use default values.\n                    config.wrap = {\n                        start: '(function () {\\n',\n                        end: '}());',\n                        __startMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"(function () {\\n\",\n                                                            build.makeAbsPath(\"config-wrap-start-default.js\",\n                                                                              absFilePath,fs), cfg, null,\n                                                            sourceMapGenerator);\n                            }\n                        ],\n                        __endMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"}());\",\n                                                            build.makeAbsPath(\"config-wrap-end-default.js\", absFilePath,fs),\n                                                            cfg, null, sourceMapGenerator);\n                            }\n                        ]\n                    };\n                } else {\n                    flattenWrapFile(config, 'start', absFilePath);\n                    flattenWrapFile(config, 'end', absFilePath);\n                }\n            }\n        } catch (wrapError) {\n            throw new Error('Malformed wrap config: ' + wrapError.toString());\n        }\n    }\n\n    /**\n     * Creates a config object for an optimization build.\n     * It will also read the build profile if it is available, to create\n     * the configuration.\n     *\n     * @param {Object} cfg config options that take priority\n     * over defaults and ones in the build file. These options could\n     * be from a command line, for instance.\n     *\n     * @param {Object} the created config object.\n     */\n    build.createConfig = function (cfg) {\n        /*jslint evil: true */\n        var fs = cfg.env.fs;\n\n        var buildFileContents, buildFileConfig, mainConfig,\n            mainConfigFile, mainConfigPath, buildFile, absFilePath,\n            config = {},\n            buildBaseConfig = makeBuildBaseConfig(fs);\n\n\n        //Make sure all paths are relative to current directory.\n\n        absFilePath = fs.absPath('.');\n        build.makeAbsConfig(cfg, absFilePath,fs);\n        build.makeAbsConfig(buildBaseConfig, absFilePath,fs);\n\n        lang.mixin(config, buildBaseConfig);\n        lang.mixin(config, cfg, true);\n\n\n        //Set up log level early since it can affect if errors are thrown\n        //or caught and passed to errbacks, even while constructing config.\n        if (lang.hasProp(config, 'logLevel')) {\n            logger.logLevel(config.logLevel);\n        }\n\n        if (config.buildFile) {\n            //A build file exists, load it to get more config.\n            buildFile = fs.absPath(config.buildFile);\n\n            //Find the build file, and make sure it exists, if this is a build\n            //that has a build profile, and not just command line args with an in=path\n            if (!fs.exists(buildFile)) {\n                throw new Error(\"ERROR: build file does not exist: \" + buildFile);\n            }\n\n            absFilePath = config.baseUrl = fs.absPath(fs.parent(buildFile));\n\n            //Load build file options.\n            buildFileContents = fs.readFile(buildFile);\n            try {\n                //Be a bit lenient in the file ending in a ; or ending with\n                //a //# sourceMappingUrl comment, mostly for compiled languages\n                //that create a config, like typescript.\n                buildFileContents = buildFileContents\n                                    .replace(/\\/\\/\\#[^\\n\\r]+[\\n\\r]*$/, '')\n                                    .trim()\n                                    .replace(/;$/, '');\n\n                buildFileConfig = eval(\"(\" + buildFileContents + \")\");\n                build.makeAbsConfig(buildFileConfig, absFilePath,fs);\n\n                //Mix in the config now so that items in mainConfigFile can\n                //be resolved relative to them if necessary, like if appDir\n                //is set here, but the baseUrl is in mainConfigFile. Will\n                //re-mix in the same build config later after mainConfigFile\n                //is processed, since build config should take priority.\n                mixConfig(config, buildFileConfig);\n            } catch (e) {\n                throw new Error(\"Build file \" + buildFile + \" is malformed: \" + e);\n            }\n        }\n\n        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);\n        if (mainConfigFile) {\n            if (typeof mainConfigFile === 'string') {\n                mainConfigFile = [mainConfigFile];\n            }\n\n            mainConfigFile.forEach(function (configFile) {\n                configFile = build.makeAbsPath(configFile, absFilePath,fs);\n                if (!fs.exists(configFile)) {\n                    throw new Error(configFile + ' does not exist.');\n                }\n                try {\n                    mainConfig = parse.findConfig(fs.readFile(configFile)).config;\n                } catch (configError) {\n                    throw new Error('The config in mainConfigFile ' +\n                            configFile +\n                            ' cannot be used because it cannot be evaluated' +\n                            ' correctly while running in the optimizer. Try only' +\n                            ' using a config that is also valid JSON, or do not use' +\n                            ' mainConfigFile and instead copy the config values needed' +\n                            ' into a build file or command line arguments given to the optimizer.\\n' +\n                            'Source error from parsing: ' + configFile + ': ' + configError);\n                }\n                if (mainConfig) {\n                    mainConfigPath = configFile.substring(0, configFile.lastIndexOf('/'));\n\n                    //Add in some existing config, like appDir, since they can be\n                    //used inside the configFile -- paths and baseUrl are\n                    //relative to them.\n                    if (config.appDir && !mainConfig.appDir) {\n                        mainConfig.appDir = config.appDir;\n                    }\n\n                    //If no baseUrl, then use the directory holding the main config.\n                    if (!mainConfig.baseUrl) {\n                        mainConfig.baseUrl = mainConfigPath;\n                    }\n\n                    build.makeAbsConfig(mainConfig, mainConfigPath,fs);\n                    mixConfig(config, mainConfig);\n                }\n            });\n        }\n\n        //Mix in build file config, but only after mainConfig has been mixed in.\n        //Since this is a re-application, skip array merging.\n        if (buildFileConfig) {\n            mixConfig(config, buildFileConfig, true);\n        }\n\n        //Re-apply the override config values. Command line\n        //args should take precedence over build file values.\n        //Since this is a re-application, skip array merging.\n        mixConfig(config, cfg, true);\n\n        //Fix paths to full paths so that they can be adjusted consistently\n        //lately to be in the output area.\n        lang.eachProp(config.paths, function (value, prop) {\n            if (lang.isArray(value)) {\n                throw new Error('paths fallback not supported in optimizer. ' +\n                                'Please provide a build config path override ' +\n                                'for ' + prop);\n            }\n            config.paths[prop] = build.makeAbsPath(value, config.baseUrl,fs);\n        });\n\n        //Set final output dir\n        if (hasProp(config, \"baseUrl\")) {\n            if (config.appDir) {\n                if (!config.originalBaseUrl) {\n                    throw new Error('Please set a baseUrl in the build config');\n                }\n                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir,fs);\n            } else {\n                config.dirBaseUrl = config.dir || config.baseUrl;\n            }\n            //Make sure dirBaseUrl ends in a slash, since it is\n            //concatenated with other strings.\n            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);\n        }\n\n        if (config.bundlesConfigOutFile) {\n            if (!config.dir) {\n                throw new Error('bundlesConfigOutFile can only be used with optimizations ' +\n                                'that use \"dir\".');\n            }\n            config.bundlesConfigOutFile = build.makeAbsPath(config.bundlesConfigOutFile, config.dir,fs);\n        }\n\n        //If out=stdout, write output to STDOUT instead of a file.\n        ///if (config.out && config.out === 'stdout') {\n        ///    config.out = function (content) {\n        ///        var e = env.get();\n        ///        if (e === 'rhino') {\n        ///            var out = new java.io.PrintStream(java.lang.System.out, true, 'UTF-8');\n        ///            out.println(content);\n        ///        } else if (e === 'node') {\n        ///            process.stdout.write(content, 'utf8');\n        ///        } else {\n        ///            console.log(content);\n        ///        }\n        ///    };\n        ///}\n\n        //Check for errors in config\n        if (config.main) {\n            throw new Error('\"main\" passed as an option, but the ' +\n                            'supported option is called \"name\".');\n        }\n        if (config.out && !config.name && !config.modules && !config.include &&\n                !config.cssIn) {\n            throw new Error('Missing either a \"name\", \"include\" or \"modules\" ' +\n                            'option');\n        }\n        if (config.cssIn) {\n            if (config.dir || config.appDir) {\n                throw new Error('cssIn is only for the output of single file ' +\n                    'CSS optimizations and is not compatible with \"dir\" or \"appDir\" configuration.');\n            }\n            if (!config.out) {\n                throw new Error('\"out\" option missing.');\n            }\n        }\n        if (!config.cssIn && !config.baseUrl) {\n            //Just use the current directory as the baseUrl\n            config.baseUrl = './';\n        }\n        if (!config.out && !config.dir) {\n            throw new Error('Missing either an \"out\" or \"dir\" config value. ' +\n                            'If using \"appDir\" for a full project optimization, ' +\n                            'use \"dir\". If you want to optimize to one file, ' +\n                            'use \"out\".');\n        }\n        if (config.appDir && config.out) {\n            throw new Error('\"appDir\" is not compatible with \"out\". Use \"dir\" ' +\n                            'instead. appDir is used to copy whole projects, ' +\n                            'where \"out\" with \"baseUrl\" is used to just ' +\n                            'optimize to one file.');\n        }\n        if (config.out && config.dir) {\n            throw new Error('The \"out\" and \"dir\" options are incompatible.' +\n                            ' Use \"out\" if you are targeting a single file' +\n                            ' for optimization, and \"dir\" if you want the appDir' +\n                            ' or baseUrl directories optimized.');\n        }\n\n\n        if (config.dir) {\n            // Make sure the output dir is not set to a parent of the\n            // source dir or the same dir, as it will result in source\n            // code deletion.\n            if (!config.allowSourceOverwrites && (config.dir === config.baseUrl ||\n                config.dir === config.appDir ||\n                (config.baseUrl && build.makeRelativeFilePath(config.dir,\n                                           config.baseUrl,fs).indexOf('..') !== 0) ||\n                (config.appDir &&\n                    build.makeRelativeFilePath(config.dir, config.appDir,fs).indexOf('..') !== 0))) {\n                throw new Error('\"dir\" is set to a parent or same directory as' +\n                                ' \"appDir\" or \"baseUrl\". This can result in' +\n                                ' the deletion of source code. Stopping. If' +\n                                ' you want to allow possible overwriting of' +\n                                ' source code, set \"allowSourceOverwrites\"' +\n                                ' to true in the build config, but do so at' +\n                                ' your own risk. In that case, you may want' +\n                                ' to also set \"keepBuildDir\" to true.');\n            }\n        }\n\n        if (config.insertRequire && !lang.isArray(config.insertRequire)) {\n            throw new Error('insertRequire should be a list of module IDs' +\n                            ' to insert in to a require([]) call.');\n        }\n\n        //Support older configs with uglify2 settings, but now that uglify1 has\n        //been removed, just translate it to 'uglify' settings.\n        if (config.optimize === 'uglify2') {\n            config.optimize = 'uglify';\n        }\n        if (config.uglify2) {\n            config.uglify = config.uglify2;\n            delete config.uglify2;\n        }\n\n        if (config.generateSourceMaps) {\n            if (config.preserveLicenseComments && !(config.optimize === 'none' || config.optimize === 'uglify')) {\n                throw new Error('Cannot use preserveLicenseComments and ' +\n                    'generateSourceMaps together, unless optimize is set ' +\n                    'to \\'uglify\\'. Either explicitly set preserveLicenseComments ' +\n                    'to false (default is true) or turn off generateSourceMaps. ' +\n                    'If you want source maps with license comments, see: ' +\n                    'http://requirejs.org/docs/errors.html#sourcemapcomments');\n            } else if (config.optimize !== 'none' &&\n                       config.optimize !== 'closure' &&\n                       config.optimize !== 'uglify') {\n                //Allow optimize: none to pass, since it is useful when toggling\n                //minification on and off to debug something, and it implicitly\n                //works, since it does not need a source map.\n                throw new Error('optimize: \"' + config.optimize +\n                    '\" does not support generateSourceMaps.');\n            }\n        }\n\n        if ((config.name || config.include) && !config.modules) {\n            //Just need to build one file, but may be part of a whole appDir/\n            //baseUrl copy, but specified on the command line, so cannot do\n            //the modules array setup. So create a modules section in that\n            //case.\n            config.modules = [\n                {\n                    name: config.name,\n                    out: config.out,\n                    create: config.create,\n                    include: config.include,\n                    exclude: config.exclude,\n                    excludeShallow: config.excludeShallow,\n                    insertRequire: config.insertRequire,\n                    stubModules: config.stubModules\n                }\n            ];\n            delete config.stubModules;\n        } else if (config.modules && config.out) {\n            throw new Error('If the \"modules\" option is used, then there ' +\n                            'should be a \"dir\" option set and \"out\" should ' +\n                            'not be used since \"out\" is only for single file ' +\n                            'optimization output.');\n        } else if (config.modules && config.name) {\n            throw new Error('\"name\" and \"modules\" options are incompatible. ' +\n                            'Either use \"name\" if doing a single file ' +\n                            'optimization, or \"modules\" if you want to target ' +\n                            'more than one file for optimization.');\n        }\n\n        if (config.out && !config.cssIn) {\n            //Just one file to optimize.\n\n            //Does not have a build file, so set up some defaults.\n            //Optimizing CSS should not be allowed, unless explicitly\n            //asked for on command line. In that case the only task is\n            //to optimize a CSS file.\n            if (!cfg.optimizeCss) {\n                config.optimizeCss = \"none\";\n            }\n        }\n\n        //Normalize cssPrefix\n        if (config.cssPrefix) {\n            //Make sure cssPrefix ends in a slash\n            config.cssPrefix = endsWithSlash(config.cssPrefix);\n        } else {\n            config.cssPrefix = '';\n        }\n\n        //Cycle through modules and normalize\n        if (config.modules && config.modules.length) {\n            config.modules.forEach(function (mod) {\n                if (lang.isArray(mod) || typeof mod === 'string' || !mod) {\n                    throw new Error('modules config item is malformed: it should' +\n                                    ' be an object with a \\'name\\' property.');\n                }\n\n                //Combine any local stubModules with global values.\n                if (config.stubModules) {\n                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);\n                }\n\n                //Create a hash lookup for the stubModules config to make lookup\n                //cheaper later.\n                if (mod.stubModules) {\n                    mod.stubModules._byName = {};\n                    mod.stubModules.forEach(function (id) {\n                        mod.stubModules._byName[id] = true;\n                    });\n                }\n\n                // Legacy command support, which allowed a single string ID\n                // for include.\n                if (typeof mod.include === 'string') {\n                    mod.include = [mod.include];\n                }\n\n                //Allow wrap config in overrides, but normalize it.\n                if (mod.override) {\n                    normalizeWrapConfig(mod.override, absFilePath);\n                }\n            });\n        }\n\n        normalizeWrapConfig(config, absFilePath);\n\n        //Do final input verification\n        if (config.context) {\n            throw new Error('The build argument \"context\" is not supported' +\n                            ' in a build. It should only be used in web' +\n                            ' pages.');\n        }\n\n        //Set up normalizeDirDefines. If not explicitly set, if optimize \"none\",\n        //set to \"skip\" otherwise set to \"all\".\n        if (!hasProp(config, 'normalizeDirDefines')) {\n            if (config.optimize === 'none' || config.skipDirOptimize) {\n                config.normalizeDirDefines = 'skip';\n            } else {\n                config.normalizeDirDefines = 'all';\n            }\n        }\n\n        //Set fs.fileExclusionRegExp if desired\n        if (hasProp(config, 'fileExclusionRegExp')) {\n            if (typeof config.fileExclusionRegExp === \"string\") {\n                fs.exclusionRegExp = new RegExp(config.fileExclusionRegExp);\n            } else {\n                fs.exclusionRegExp = config.fileExclusionRegExp;\n            }\n        } else if (hasProp(config, 'dirExclusionRegExp')) {\n            //Set fs.dirExclusionRegExp if desired, this is the old\n            //name for fileExclusionRegExp before 1.0.2. Support for backwards\n            //compatibility\n            fs.exclusionRegExp = config.dirExclusionRegExp;\n        }\n\n        //Track the deps, but in a different key, so that they are not loaded\n        //as part of config seeding before all config is in play (#648). Was\n        //going to merge this in with \"include\", but include is added after\n        //the \"name\" target. To preserve what r.js has done previously, make\n        //sure \"deps\" comes before the \"name\".\n        if (config.deps) {\n            config._depsInclude = config.deps;\n        }\n\n\n        //Remove things that may cause problems in the build.\n        //deps already merged above\n        delete config.deps;\n        delete config.jQuery;\n        delete config.enforceDefine;\n        delete config.urlArgs;\n\n        return config;\n    };\n\n    /**\n     * finds the module being built/optimized with the given moduleName,\n     * or returns null.\n     * @param {String} moduleName\n     * @param {Array} modules\n     * @returns {Object} the module object from the build profile, or null.\n     */\n    build.findBuildModule = function (moduleName, modules) {\n        var i, module;\n        for (i = 0; i < modules.length; i++) {\n            module = modules[i];\n            if (module.name === moduleName) {\n                return module;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Removes a module name and path from a layer, if it is supposed to be\n     * excluded from the layer.\n     * @param {String} moduleName the name of the module\n     * @param {String} path the file path for the module\n     * @param {Object} layer the layer to remove the module/path from\n     */\n    build.removeModulePath = function (module, path, layer) {\n        var index = layer.buildFilePaths.indexOf(path);\n        if (index !== -1) {\n            layer.buildFilePaths.splice(index, 1);\n        }\n    };\n\n    /**\n     * Uses the module build config object to trace the dependencies for the\n     * given module.\n     *\n     * @param {Object} module the module object from the build config info.\n     * @param {Object} config the build config object.\n     * @param {Object} [baseLoaderConfig] the base loader config to use for env resets.\n     *\n     * @returns {Object} layer information about what paths and modules should\n     * be in the flattened module.\n     */\n    build.traceDependencies = function (module, config, baseLoaderConfig) {\n        var include, override, layer, context, oldContext,\n            rawTextByIds,\n            syncChecks = {\n                rhino: true,\n                node: true,\n                xpconnect: true\n            },\n            deferred = prim();\n\n        //Reset some state set up in requirePatch.js, and clean up require's\n        //current context.\n        oldContext = require._buildReset();\n\n        //Grab the reset layer and context after the reset, but keep the\n        //old config to reuse in the new context.\n        layer = require._layer;\n        context = layer.context;\n\n        //Put back basic config, use a fresh object for it.\n        if (baseLoaderConfig) {\n            require(copyConfig(baseLoaderConfig));\n        }\n\n        logger.trace(\"\\nTracing dependencies for: \" + (module.name ||\n                     (typeof module.out === 'function' ? 'FUNCTION' : module.out)));\n        include = config._depsInclude ||  [];\n        include = include.concat(module.name && !module.create ? [module.name] : []);\n        if (module.include) {\n            include = include.concat(module.include);\n        }\n\n        //If there are overrides to basic config, set that up now.;\n        if (module.override) {\n            if (baseLoaderConfig) {\n                override = build.createOverrideConfig(baseLoaderConfig, module.override);\n            } else {\n                override = copyConfig(module.override);\n            }\n            require(override);\n        }\n\n        //Now, populate the rawText cache with any values explicitly passed in\n        //via config.\n        rawTextByIds = require.s.contexts._.config.rawText;\n        if (rawTextByIds) {\n            lang.eachProp(rawTextByIds, function (contents, id) {\n                var url = require.toUrl(id) + '.js';\n                require._cachedRawText[url] = contents;\n            });\n        }\n\n\n        //Configure the callbacks to be called.\n        deferred.reject.__requireJsBuild = true;\n\n        //Use a wrapping function so can check for errors.\n        function includeFinished(value) {\n            //If a sync build environment, check for errors here, instead of\n            //in the then callback below, since some errors, like two IDs pointed\n            //to same URL but only one anon ID will leave the loader in an\n            //unresolved state since a setTimeout cannot be used to check for\n            //timeout.\n            var hasError = false;\n            if (syncChecks[config.env.name]) {\n                try {\n                    build.checkForErrors(context, layer);\n                } catch (e) {\n                    hasError = true;\n                    deferred.reject(e);\n                }\n            }\n\n            if (!hasError) {\n                deferred.resolve(value);\n            }\n        }\n        includeFinished.__requireJsBuild = true;\n\n        //Figure out module layer dependencies by calling require to do the work.\n        require(include, includeFinished, deferred.reject);\n\n        // If a sync env, then with the \"two IDs to same anon module path\"\n        // issue, the require never completes, need to check for errors\n        // here.\n        if (syncChecks[config.env.name]) {\n            build.checkForErrors(context, layer);\n        }\n\n        return deferred.promise.then(function () {\n            //Reset config\n            if (module.override && baseLoaderConfig) {\n                require(copyConfig(baseLoaderConfig));\n            }\n\n            build.checkForErrors(context, layer);\n\n            return layer;\n        });\n    };\n\n    build.checkForErrors = function (context, layer) {\n        //Check to see if it all loaded. If not, then throw, and give\n        //a message on what is left.\n        var id, prop, mod, idParts, pluginId, pluginResources,\n            errMessage = '',\n            failedPluginMap = {},\n            failedPluginIds = [],\n            errIds = [],\n            errUrlMap = {},\n            errUrlConflicts = {},\n            hasErrUrl = false,\n            hasUndefined = false,\n            defined = context.defined,\n            registry = context.registry;\n\n        function populateErrUrlMap(id, errUrl, skipNew) {\n            // Loader plugins do not have an errUrl, so skip them.\n            if (!errUrl) {\n                return;\n            }\n\n            if (!skipNew) {\n                errIds.push(id);\n            }\n\n            if (errUrlMap[errUrl]) {\n                hasErrUrl = true;\n                //This error module has the same URL as another\n                //error module, could be misconfiguration.\n                if (!errUrlConflicts[errUrl]) {\n                    errUrlConflicts[errUrl] = [];\n                    //Store the original module that had the same URL.\n                    errUrlConflicts[errUrl].push(errUrlMap[errUrl]);\n                }\n                errUrlConflicts[errUrl].push(id);\n            } else if (!skipNew) {\n                errUrlMap[errUrl] = id;\n            }\n        }\n\n        for (id in registry) {\n            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {\n                hasUndefined = true;\n                mod = getOwn(registry, id);\n                idParts = id.split('!');\n                pluginId = idParts[0];\n\n                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {\n                    populateErrUrlMap(id, mod.map.url);\n                }\n\n                //Look for plugins that did not call load()\n                //But skip plugin IDs that were already inlined and called\n                //define() with a name.\n                if (!hasProp(layer.modulesWithNames, id) && idParts.length > 1) {\n                    if (falseProp(failedPluginMap, pluginId)) {\n                        failedPluginIds.push(pluginId);\n                    }\n                    pluginResources = failedPluginMap[pluginId];\n                    if (!pluginResources) {\n                        pluginResources = failedPluginMap[pluginId] = [];\n                    }\n                    pluginResources.push(id + (mod.error ? ': ' + mod.error : ''));\n                }\n            }\n        }\n\n        // If have some modules that are not defined/stuck in the registry,\n        // then check defined modules for URL overlap.\n        if (hasUndefined) {\n            for (id in defined) {\n                if (hasProp(defined, id) && id.indexOf('!') === -1) {\n                    populateErrUrlMap(id, require.toUrl(id) + '.js', true);\n                }\n            }\n        }\n\n        if (errIds.length || failedPluginIds.length) {\n            if (failedPluginIds.length) {\n                errMessage += 'Loader plugin' +\n                    (failedPluginIds.length === 1 ? '' : 's') +\n                    ' did not call ' +\n                    'the load callback in the build:\\n' +\n                    failedPluginIds.map(function (pluginId) {\n                        var pluginResources = failedPluginMap[pluginId];\n                        return pluginId + ':\\n  ' + pluginResources.join('\\n  ');\n                    }).join('\\n') + '\\n';\n            }\n            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');\n\n            if (hasErrUrl) {\n                errMessage += '\\nThe following modules share the same URL. This ' +\n                              'could be a misconfiguration if that URL only has ' +\n                              'one anonymous module in it:';\n                for (prop in errUrlConflicts) {\n                    if (hasProp(errUrlConflicts, prop)) {\n                        errMessage += '\\n' + prop + ': ' +\n                                      errUrlConflicts[prop].join(', ');\n                    }\n                }\n            }\n            throw new Error(errMessage);\n        }\n    };\n\n    build.createOverrideConfig = function (config, override) {\n        var cfg = copyConfig(config),\n            oride = copyConfig(override);\n\n        lang.eachProp(oride, function (value, prop) {\n            if (hasProp(build.objProps, prop)) {\n                //An object property, merge keys. Start a new object\n                //so that source object in config does not get modified.\n                cfg[prop] = {};\n                lang.mixin(cfg[prop], config[prop], true);\n                lang.mixin(cfg[prop], override[prop], true);\n            } else {\n                cfg[prop] = override[prop];\n            }\n        });\n\n        return cfg;\n    };\n\n    /**\n     * Uses the module build config object to create an flattened version\n     * of the module, with deep dependencies included.\n     *\n     * @param {Object} module the module object from the build config info.\n     *\n     * @param {Object} layer the layer object returned from build.traceDependencies.\n     *\n     * @param {Object} the build config object.\n     *\n     * @returns {Object} with two properties: \"text\", the text of the flattened\n     * module, and \"buildText\", a string of text representing which files were\n     * included in the flattened module text.\n     */\n    build.flattenModule = function (module, layer, config) {\n        var fileContents, sourceMapGenerator,\n            sourceMapBase,\n            buildFileContents = '',\n            fs = config.env.fs;\n\n        return prim().start(function () {\n            var reqIndex, currContents, fileForSourceMap,\n                moduleName, shim, packageName,\n                parts, builder, writeApi,\n                namespace, namespaceWithDot, stubModulesByName,\n                context = layer.context,\n                onLayerEnds = [],\n                onLayerEndAdded = {},\n                pkgsMainMap = {};\n\n            //Use override settings, particularly for pragmas\n            //Do this before the var readings since it reads config values.\n            if (module.override) {\n                config = build.createOverrideConfig(config, module.override);\n            }\n\n            namespace = config.namespace || '';\n            namespaceWithDot = namespace ? namespace + '.' : '';\n            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};\n\n            //Start build output for the module.\n            module.onCompleteData = {\n                name: module.name,\n                path: (config.dir ? module._buildPath.replace(config.dir, \"\") : module._buildPath),\n                included: []\n            };\n\n            buildFileContents += \"\\n\" +\n                                  module.onCompleteData.path +\n                                 \"\\n----------------\\n\";\n\n            //If there was an existing file with require in it, hoist to the top.\n            if (layer.existingRequireUrl) {\n                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);\n                if (reqIndex !== -1) {\n                    layer.buildFilePaths.splice(reqIndex, 1);\n                    layer.buildFilePaths.unshift(layer.existingRequireUrl);\n                }\n            }\n\n            if (config.generateSourceMaps) {\n                sourceMapBase = config.dir || config.baseUrl;\n                if (module._buildPath === 'FUNCTION') {\n                    fileForSourceMap = (module.name || module.include[0] || 'FUNCTION') + '.build.js';\n                } else if (config.out) {\n                    fileForSourceMap = module._buildPath.split('/').pop();\n                } else {\n                    fileForSourceMap = module._buildPath.replace(sourceMapBase, '');\n                }\n                sourceMapGenerator = new SourceMapGenerator({\n                    file: fileForSourceMap\n                });\n            }\n\n            //Create a reverse lookup for packages main module IDs to their package\n            //names, useful for knowing when to write out define() package main ID\n            //adapters.\n            lang.eachProp(layer.context.config.pkgs, function(value, prop) {\n                pkgsMainMap[value] = prop;\n            });\n\n            //Write the built module to disk, and build up the build output.\n            fileContents = \"\";\n            if (config.wrap && config.wrap.__startMap) {\n                config.wrap.__startMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n\n            return prim.serial(layer.buildFilePaths.map(function (path) {\n                return function () {\n                    var singleContents = '';\n\n                    moduleName = layer.buildFileToModule[path];\n\n                    //If the moduleName is a package main, then hold on to the\n                    //packageName in case an adapter needs to be written.\n                    packageName = getOwn(pkgsMainMap, moduleName);\n\n                    return prim().start(function () {\n                        //Figure out if the module is a result of a build plugin, and if so,\n                        //then delegate to that plugin.\n                        parts = context.makeModuleMap(moduleName);\n                        builder = parts.prefix && getOwn(context.defined, parts.prefix);\n                        if (builder) {\n                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {\n                                onLayerEnds.push(builder);\n                                onLayerEndAdded[parts.prefix] = true;\n                            }\n\n                            if (builder.write) {\n                                writeApi = function (input) {\n                                    singleContents += \"\\n\" + addSemiColon(input, config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n                                writeApi.asModule = function (moduleName, input) {\n                                    singleContents += \"\\n\" +\n                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {\n                                            useSourceUrl: layer.context.config.useSourceUrl\n                                        }), config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n\n                                builder.write(parts.prefix, parts.name, writeApi, {\n                                    name: module.onCompleteData.name,\n                                    path: module.onCompleteData.path\n                                });\n                            }\n                            return;\n                        } else {\n                            return prim().start(function () {\n                                if (hasProp(stubModulesByName, moduleName)) {\n                                    //Just want to insert a simple module definition instead\n                                    //of the source module. Useful for plugins that inline\n                                    //all their resources.\n                                    if (hasProp(layer.context.plugins, moduleName)) {\n                                        //Slightly different content for plugins, to indicate\n                                        //that dynamic loading will not work.\n                                        return 'define({load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});';\n                                    } else {\n                                        return 'define({});';\n                                    }\n                                } else {\n                                    return require._cacheReadAsync(path,undefined,fs);\n                                }\n                            }).then(function (text) {\n                                var hasPackageName;\n\n                                currContents = text;\n\n                                if (config.cjsTranslate &&\n                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                                    currContents = commonJs.convert(path, currContents);\n                                }\n\n                                if (config.onBuildRead) {\n                                    currContents = config.onBuildRead(moduleName, path, currContents);\n                                }\n\n                                if (packageName) {\n                                    hasPackageName = (packageName === parse.getNamedDefine(currContents));\n                                }\n\n                                if (namespace) {\n                                    currContents = pragma.namespace(currContents, namespace);\n                                }\n\n                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {\n                                    useSourceUrl: config.useSourceUrl\n                                });\n\n                                if (packageName && !hasPackageName) {\n                                    currContents = addSemiColon(currContents, config) + '\\n';\n                                    currContents += namespaceWithDot + \"define('\" +\n                                                    packageName + \"', ['\" + moduleName +\n                                                    \"'], function (main) { return main; });\\n\";\n                                }\n\n                                if (config.onBuildWrite) {\n                                    currContents = config.onBuildWrite(moduleName, path, currContents);\n                                }\n\n                                //Semicolon is for files that are not well formed when\n                                //concatenated with other content.\n                                singleContents += addSemiColon(currContents, config);\n                            });\n                        }\n                    }).then(function () {\n                        var shimDeps, shortPath = path.replace(config.dir, \"\");\n\n                        module.onCompleteData.included.push(shortPath);\n                        buildFileContents += shortPath + \"\\n\";\n\n                        //Some files may not have declared a require module, and if so,\n                        //put in a placeholder call so the require does not try to load them\n                        //after the module is processed.\n                        //If we have a name, but no defined module, then add in the placeholder.\n                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {\n                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageName && getOwn(config.shim, packageName)));\n                            if (shim) {\n                                shimDeps = lang.isArray(shim) ? shim : shim.deps;\n                                if (config.wrapShim) {\n\n                                    singleContents = '(function(root) {\\n' +\n                                                     namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '[], ') +\n                                                    'function() {\\n' +\n                                                    '  return (function() {\\n' +\n                                                             singleContents +\n                                                             // Start with a \\n in case last line is a comment\n                                                             // in the singleContents, like a sourceURL comment.\n                                                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                                                             '\\n' +\n                                                    '  }).apply(root, arguments);\\n' +\n                                                    '});\\n' +\n                                                    '}(this));\\n';\n                                } else {\n                                    singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '') +\n                                                     (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                                                     ');\\n';\n                                }\n                            } else {\n                                singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", function(){});\\n';\n                            }\n                        }\n\n                        //Add line break at end of file, instead of at beginning,\n                        //so source map line numbers stay correct, but still allow\n                        //for some space separation between files in case ASI issues\n                        //for concatenation would cause an error otherwise.\n                        singleContents += '\\n';\n\n                        //Add to the source map and to the final contents\n                        fileContents = appendToFileContents(fileContents, singleContents, path, config, module,\n                                                            sourceMapGenerator);\n                    });\n                };\n            })).then(function () {\n                if (onLayerEnds.length) {\n                    onLayerEnds.forEach(function (builder, index) {\n                        var path;\n                        if (typeof module.out === 'string') {\n                            path = module.out;\n                        } else if (typeof module._buildPath === 'string') {\n                            path = module._buildPath;\n                        }\n                        builder.onLayerEnd(function (input) {\n                            fileContents =\n                                appendToFileContents(fileContents, \"\\n\" + addSemiColon(input, config),\n                                                     'onLayerEnd' + index + '.js', config, module, sourceMapGenerator);\n                        }, {\n                            name: module.name,\n                            path: path\n                        });\n                    });\n                }\n\n                if (module.create) {\n                    //The ID is for a created layer. Write out\n                    //a module definition for it in case the\n                    //built file is used with enforceDefine\n                    //(#432)\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'define(\"' + module.name +\n                                                           '\", function(){});\\n', 'module-create.js', config, module,\n                                             sourceMapGenerator);\n                }\n\n                //Add a require at the end to kick start module execution, if that\n                //was desired. Usually this is only specified when using small shim\n                //loaders like almond.\n                if (module.insertRequire) {\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'require([\"' + module.insertRequire.join('\", \"') +\n                                                           '\"]);\\n', 'module-insertRequire.js', config, module,\n                                             sourceMapGenerator);\n                }\n            });\n        }).then(function () {\n            if (config.wrap && config.wrap.__endMap) {\n                config.wrap.__endMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n            return {\n                text: fileContents,\n                buildText: buildFileContents,\n                sourceMap: sourceMapGenerator ?\n                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :\n                              undefined\n            };\n        });\n    };\n\n    //Converts an JS array of strings to a string representation.\n    //Not using JSON.stringify() for Rhino's sake.\n    build.makeJsArrayString = function (ary) {\n        return '[\"' + ary.map(function (item) {\n            //Escape any double quotes, backslashes\n            return lang.jsEscape(item);\n        }).join('\",\"') + '\"]';\n    };\n\n    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {\n        var baseUrl = layer && layer.context.config.baseUrl;\n\n        function onFound(info) {\n            //Only mark this module as having a name if not a named module,\n            //or if a named module and the name matches expectations.\n            if (layer && (info.needsId || info.foundId === moduleName)) {\n                layer.modulesWithNames[moduleName] = true;\n            }\n        }\n\n        //Convert path to be a local one to the baseUrl, useful for\n        //useSourceUrl.\n        if (baseUrl) {\n            path = path.replace(baseUrl, '');\n        }\n\n        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);\n    };\n\n    return require.build = build;\n});\n\ndefine('skylark-rjs/main',[\r\n    \"./rjs\",\r\n    \"./build\",\r\n    \"./lang\",\r\n    \"./prim\",\r\n    \"./logger\",\r\n    \"./parse\",\r\n    \"./optimize\",\r\n    \"./pragma\",\r\n    \"./transform\",\r\n    \"./requirePatch\",\r\n    \"./commonJs\",\r\n    \"./source-map\"\r\n],function (\r\n    rjs,\r\n    build,\r\n    lang,\r\n    prim,\r\n    logger,\r\n    parse,\r\n    optimize,\r\n    pragma,\r\n    transform,\r\n    requirePatch,\r\n    commonJs,\r\n    sourceMap,\r\n    createRjsApi\r\n\r\n) {\r\n    'use strict';\r\n\r\n    /*return {\r\n    \tbuild,\r\n    \tlang,\r\n    \tprim,\r\n    \tlogger,\r\n    \tparse,\r\n    \toptimize,\r\n    \tpragma,\r\n    \ttransform,\r\n    \trequirePatch,\r\n    \tcommonJs,\r\n    \tsourceMap,\r\n    }\r\n    */\r\n    return rjs;\r\n\t\r\n});\ndefine('skylark-rjs', ['skylark-rjs/main'], function (main) { return main; });\n\n"]}