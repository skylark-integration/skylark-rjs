{"version":3,"sources":["build.js"],"names":["define","require","lang","prim","logger","parse","optimize","pragma","transform","requirePatch","commonJs","sourceMap","build","SourceMapGenerator","hasProp","getOwn","falseProp","endsWithSemiColonRegExp","endsWithSlashRegExp","resourceIsModuleIdRegExp","deepCopyProps","layer","copyConfig","obj","deeplikeCopy","makeBuildBaseConfig","fs","appDir","pragmas","paths","optimizeCss","inlineText","isBuild","optimizeAllPluginResources","findNestedDependencies","preserveLicenseComments","writeBuildTxt","waitSeconds","dirExclusionRegExp","_buildPathToModuleIndex","addSemiColon","text","config","skipSemiColonInsertion","test","endsWithSlash","dirName","charAt","length","endsWithNewLine","makeWriteFile","namespace","writeFile","name","contents","trace","file","saveUtf8File","asModule","moduleName","fileName","toTransport","appendToFileContents","fileContents","singleContents","path","module","sourceMapGenerator","refPath","sourceMapPath","resourcePath","pluginId","sourceMapLineNumber","lineCount","parts","i","out","baseUrl","_buildPath","split","makeRelativeFilePath","shift","join","toUrl","addMapping","generated","line","column","original","source","setSourceContent","stringDotToObj","result","value","forEach","prop","mixConfig","target","skipArrays","isArray","targetValue","isFunction","isRegExp","concat","map","deepMix","mixin","logLevel","flattenWrapFile","keyName","absFilePath","wrap","keyFileName","keyMapName","env","absPath","makeAbsPath","fileText","readFile","push","cfg","undefined","Error","normalizeWrapConfig","start","end","__startMap","__endMap","wrapError","toString","nextTick","fn","_cacheReadAsync","encoding","d","_cachedRawText","resolve","promise","readFileAsync","then","args","buildFile","cmdConfig","errorMsg","errorStack","stackMatch","errorTree","j","errorMod","stackRegExp","error","indexOf","splice","convertArrayToObject","_run","e","err","moduleTree","exec","substring","index","stack","originalError","buildPaths","baseConfig","modules","srcPath","buildContext","destPath","moduleMap","parentModuleMap","context","resources","resource","plugin","pluginProcessed","buildFileContents","pluginCollector","createConfig","dir","keepBuildDir","exists","deleteFile","cssIn","copyDir","replace","dirBaseUrl","isDirectory","copyFile","packagePaths","packages","s","contexts","_","_sourcePath","nameToUrl","create","rawText","allowSourceOverwrites","css","actions","normalize","traceDependencies","serial","exclude","excludeLayers","found","findBuildModule","excludeModule","excludeLayer","buildFileToModule","buildFilePaths","filePath","removeModulePath","excludeShallow","excludeShallowModule","buildPathMap","flattenModule","builtModule","finalText","_buildText","_buildSourceMap","pop","buildText","outOrigSourceMap","bundlesConfig","bundlesConfigOutFile","entryConfig","finalPath","renameFile","bundleContents","excludeMap","parsedIds","getAllNamedDefines","apply","removeCombined","isLayer","some","mod","relPath","onModuleBundleComplete","onCompleteData","modifyConfig","bundles","eachProp","deleteEmptyDirs","js","include","jsFile","getFilteredFileList","override","moduleIndex","skipDirOptimize","normalizeDirDefines","cjsTranslate","shim","convert","onBuildRead","onBuildWrite","createOverrideConfig","makeModuleMap","plugins","prefix","id","defined","cssFile","info","objProps","pragmasOnSave","has","hasOnSave","uglify","uglify2","closure","throwWhen","hasDotPropMatch","dotProp","ary","needArray","insertRequire","stubModules","deps","mainConfigFile","wrap.startFile","wrap.endFile","separatorI","ndex","separatorIndex","backSlashRegExp","makeAbsObject","props","makeAbsConfig","originalBaseUrl","targetPath","dotLength","finalParts","targetParts","targetName","refParts","hasEndSlash","dotParts","slice","nestedMix","buildFileConfig","mainConfig","mainConfigPath","buildBaseConfig","parent","trim","eval","configFile","findConfig","configError","lastIndexOf","main","generateSourceMaps","cssPrefix","_byName","fileExclusionRegExp","exclusionRegExp","RegExp","_depsInclude","jQuery","enforceDefine","urlArgs","baseLoaderConfig","rawTextByIds","syncChecks","rhino","node","xpconnect","deferred","includeFinished","hasError","checkForErrors","reject","_buildReset","_layer","url","__requireJsBuild","idParts","pluginResources","errMessage","failedPluginMap","failedPluginIds","errIds","errUrlMap","errUrlConflicts","hasErrUrl","hasUndefined","registry","populateErrUrlMap","errUrl","skipNew","enabled","modulesWithNames","oride","sourceMapBase","reqIndex","currContents","fileForSourceMap","packageName","builder","writeApi","namespaceWithDot","stubModulesByName","onLayerEnds","onLayerEndAdded","pkgsMainMap","included","existingRequireUrl","unshift","pkgs","wrapFunction","onLayerEnd","write","input","useSourceUrl","hasPackageName","getNamedDefine","shimDeps","shortPath","skipModuleInsertion","wrapShim","makeJsArrayString","exportsFn","JSON","stringify","toJSON","item","jsEscape","options","needsId","foundId"],"mappings":"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","file":"../build.js","sourcesContent":["/*jslint plusplus: true, nomen: true, regexp: true  */\n/*global define, requirejs, java, process, console */\n\n\ndefine([\n    \"./rjs\",\n    \"./lang\",\n    \"./prim\",\n    \"./logger\",\n    ///\"env!env/file\",\n    \"./parse\",\n    \"./optimize\",\n    \"./pragma\",\n    \"./transform\",\n    \"./requirePatch\",\n    ///\"env\",\n    \"./commonJs\",\n    \"./source-map\"\n],function (\n    require,\n    lang,\n    prim,\n    logger,\n    parse,\n    optimize,\n    pragma,\n    transform,\n    requirePatch,\n    commonJs,\n    sourceMap\n\n) {\n    'use strict';\n\n    var build,\n        ///lang = require('lang'),\n        ///prim = require('prim'),\n        ///logger = require('logger'),\n        ///file = require('env!env/file'),\n        ///parse = require('parse'),\n        ///optimize = require('optimize'),\n        ///pragma = require('pragma'),\n        ///transform = require('transform'),\n        ///requirePatch = require('requirePatch'),\n        ///env = require('env'),\n        ///commonJs = require('commonJs'),\n        ///SourceMapGenerator = require('source-map').SourceMapGenerator,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        hasProp = lang.hasProp,\n        getOwn = lang.getOwn,\n        falseProp = lang.falseProp,\n        endsWithSemiColonRegExp = /;\\s*$/,\n        endsWithSlashRegExp = /[\\/\\\\]$/,\n        resourceIsModuleIdRegExp = /^[\\w\\/\\\\\\.]+$/,\n        deepCopyProps = {\n            layer: true\n        };\n\n    //Deep copy a config object, but do not copy over the \"layer\" property,\n    //as it can be a deeply nested structure with a full requirejs context.\n    function copyConfig(obj) {\n        return lang.deeplikeCopy(obj, deepCopyProps);\n    }\n\n    prim.nextTick = function (fn) {\n        fn();\n    };\n\n    //Now map require to the outermost requirejs, now that we have\n    //local dependencies for this module. The rest of the require use is\n    //manipulating the requirejs loader.\n    ///require = requirejs;\n\n    //Caching function for performance. Attached to\n    //require so it can be reused in requirePatch.js. _cachedRawText\n    //set up by requirePatch.js\n    require._cacheReadAsync = function (path, encoding,fs) {\n        var d;\n\n        if (lang.hasProp(require._cachedRawText, path)) {\n            d = prim();\n            d.resolve(require._cachedRawText[path]);\n            return d.promise;\n        } else {\n            return fs.readFileAsync(path, encoding).then(function (text) {\n                require._cachedRawText[path] = text;\n                return text;\n            });\n        }\n    };\n\n    function makeBuildBaseConfig(fs) {\n        return {\n            appDir: \"\",\n            pragmas: {},\n            paths: {},\n            optimize: \"uglify\",\n            optimizeCss: \"standard.keepLines.keepWhitespace\",\n            inlineText: true,\n            isBuild: true,\n            optimizeAllPluginResources: false,\n            findNestedDependencies: false,\n            preserveLicenseComments: true,\n            writeBuildTxt: true,\n            //Some builds can take a while, up the default limit.\n            waitSeconds: 30,\n            //By default, all files/directories are copied, unless\n            //they match this regexp, by default just excludes .folders\n            dirExclusionRegExp: fs.dirExclusionRegExp,\n            _buildPathToModuleIndex: {}\n        };\n    }\n\n    /**\n     * Some JS may not be valid if concatenated with other JS, in particular\n     * the style of omitting semicolons and rely on ASI. Add a semicolon in\n     * those cases.\n     */\n    function addSemiColon(text, config) {\n        if (config.skipSemiColonInsertion || endsWithSemiColonRegExp.test(text)) {\n            return text;\n        } else {\n            return text + \";\";\n        }\n    }\n\n    function endsWithSlash(dirName) {\n        if (dirName.charAt(dirName.length - 1) !== \"/\") {\n            dirName += \"/\";\n        }\n        return dirName;\n    }\n\n    function endsWithNewLine(text) {\n        if (text.charAt(text.length - 1) !== \"\\n\") {\n            text += \"\\n\";\n        }\n        return text;\n    }\n\n    //Method used by plugin writeFile calls, defined up here to avoid\n    //jslint warning about \"making a function in a loop\".\n    function makeWriteFile(namespace, layer) {\n        function writeFile(name, contents) {\n            logger.trace('Saving plugin-optimized file: ' + name);\n            file.saveUtf8File(name, contents);\n        }\n\n        writeFile.asModule = function (moduleName, fileName, contents) {\n            writeFile(fileName,\n                build.toTransport(namespace, moduleName, fileName, contents, layer));\n        };\n\n        return writeFile;\n    }\n\n    /**\n     * Appends singleContents to fileContents and returns the result.  If a sourceMapGenerator\n     * is provided, adds singleContents to the source map.\n     *\n     * @param {string} fileContents - The file contents to which to append singleContents\n     * @param {string} singleContents - The additional contents to append to fileContents\n     * @param {string} path - An absolute path of a file whose name to use in the source map.\n     * The file need not actually exist if the code in singleContents is generated.\n     * @param {{out: ?string, baseUrl: ?string}} config - The build configuration object.\n     * @param {?{_buildPath: ?string}} module - An object with module information.\n     * @param {?SourceMapGenerator} sourceMapGenerator - An instance of Mozilla's SourceMapGenerator,\n     * or null if no source map is being generated.\n     * @returns {string} fileContents with singleContents appended\n     */\n    function appendToFileContents(fileContents, singleContents, path, config, module, sourceMapGenerator) {\n        var refPath, sourceMapPath, resourcePath, pluginId, sourceMapLineNumber, lineCount, parts, i;\n        if (sourceMapGenerator) {\n            if (config.out) {\n                refPath = config.baseUrl;\n            } else if (module && module._buildPath) {\n                refPath = module._buildPath;\n            } else {\n                refPath = \"\";\n            }\n            parts = path.split('!');\n            if (parts.length === 1) {\n                //Not a plugin resource, fix the path\n                sourceMapPath = build.makeRelativeFilePath(refPath, path);\n            } else {\n                //Plugin resource. If it looks like just a plugin\n                //followed by a module ID, pull off the plugin\n                //and put it at the end of the name, otherwise\n                //just leave it alone.\n                pluginId = parts.shift();\n                resourcePath = parts.join('!');\n                if (resourceIsModuleIdRegExp.test(resourcePath)) {\n                    sourceMapPath = build.makeRelativeFilePath(refPath, require.toUrl(resourcePath)) +\n                                    '!' + pluginId;\n                } else {\n                    sourceMapPath = path;\n                }\n            }\n\n            sourceMapLineNumber = fileContents.split('\\n').length - 1;\n            lineCount = singleContents.split('\\n').length;\n            for (i = 1; i <= lineCount; i += 1) {\n                sourceMapGenerator.addMapping({\n                    generated: {\n                        line: sourceMapLineNumber + i,\n                        column: 0\n                    },\n                    original: {\n                        line: i,\n                        column: 0\n                    },\n                    source: sourceMapPath\n                });\n            }\n\n            //Store the content of the original in the source\n            //map since other transforms later like minification\n            //can mess up translating back to the original\n            //source.\n            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);\n        }\n        fileContents += singleContents;\n        return fileContents;\n    }\n\n    /**\n     * Main API entry point into the build. The args argument can either be\n     * an array of arguments (like the onese passed on a command-line),\n     * or it can be a JavaScript object that has the format of a build profile\n     * file.\n     *\n     * If it is an object, then in addition to the normal properties allowed in\n     * a build profile file, the object should contain one other property:\n     *\n     * The object could also contain a \"buildFile\" property, which is a string\n     * that is the file path to a build profile that contains the rest\n     * of the build profile directives.\n     *\n     * This function does not return a status, it should throw an error if\n     * there is a problem completing the build.\n     */\n    build = function (args) {\n        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,\n            i, j, errorMod,\n            stackRegExp = /( {4}at[^\\n]+)\\n/,\n            standardIndent = '  ';\n\n        return prim().start(function () {\n            if (!args || lang.isArray(args)) {\n                if (!args || args.length < 1) {\n                    logger.error(\"build.js buildProfile.js\\n\" +\n                          \"where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).\");\n                    return undefined;\n                }\n\n                //Next args can include a build file path as well as other build args.\n                //build file path comes first. If it does not contain an = then it is\n                //a build file path. Otherwise, just all build args.\n                if (args[0].indexOf(\"=\") === -1) {\n                    buildFile = args[0];\n                    args.splice(0, 1);\n                }\n\n                //Remaining args are options to the build\n                cmdConfig = build.convertArrayToObject(args);\n                cmdConfig.buildFile = buildFile;\n            } else {\n                cmdConfig = args;\n            }\n\n            return build._run(cmdConfig);\n        }).then(null, function (e) {\n            var err;\n\n            errorMsg = e.toString();\n            errorTree = e.moduleTree;\n            stackMatch = stackRegExp.exec(errorMsg);\n\n            if (stackMatch) {\n                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);\n            }\n\n            //If a module tree that shows what module triggered the error,\n            //print it out.\n            if (errorTree && errorTree.length > 0) {\n                errorMsg += '\\nIn module tree:\\n';\n\n                for (i = errorTree.length - 1; i > -1; i--) {\n                    errorMod = errorTree[i];\n                    if (errorMod) {\n                        for (j = errorTree.length - i; j > -1; j--) {\n                            errorMsg += standardIndent;\n                        }\n                        errorMsg += errorMod + '\\n';\n                    }\n                }\n\n                logger.error(errorMsg);\n            }\n\n            errorStack = e.stack;\n\n            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {\n                errorMsg += '\\n' + errorStack;\n            } else {\n                if (!stackMatch && errorStack) {\n                    //Just trim out the first \"at\" in the stack.\n                    stackMatch = stackRegExp.exec(errorStack);\n                    if (stackMatch) {\n                        errorMsg += '\\n' + stackMatch[0] || '';\n                    }\n                }\n            }\n\n            err = new Error(errorMsg);\n            err.originalError = e;\n            throw err;\n        });\n    };\n\n    build._run = function (cmdConfig) {\n        var buildPaths, fileName, fileNames,\n            paths, i,\n            baseConfig, config,\n            modules, srcPath, buildContext,\n            destPath, moduleMap, parentModuleMap, context,\n            resources, resource, plugin, fileContents,\n            pluginProcessed = {},\n            buildFileContents = \"\",\n            pluginCollector = {},\n            fs;\n\n        return prim().start(function () {\n            var prop;\n\n            //Can now run the patches to require.js to allow it to be used for\n            //build generation. Do it here instead of at the top of the module\n            //because we want normal require behavior to load the build tool\n            //then want to switch to build mode.\n\n            config = build.createConfig(cmdConfig);\n            paths = config.paths;\n            fs = config.env.fs;\n\n            requirePatch(config);\n\n\n            //Remove the previous build dir, in case it contains source transforms,\n            //like the ones done with onBuildRead and onBuildWrite.\n            if (config.dir && !config.keepBuildDir && fs.exists(config.dir)) {\n                fs.deleteFile(config.dir);\n            }\n\n            if (!config.out && !config.cssIn) {\n                //This is not just a one-off file build but a full build profile, with\n                //lots of files to process.\n\n                //First copy all the baseUrl content\n                fs.copyDir((config.appDir || config.baseUrl), config.dir, /\\w/, true);\n\n                //Adjust baseUrl if config.appDir is in play, and set up build output paths.\n                buildPaths = {};\n                if (config.appDir) {\n                    //All the paths should be inside the appDir, so just adjust\n                    //the paths to use the dirBaseUrl\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);\n                        }\n                    }\n                } else {\n                    //If no appDir, then make sure to copy the other paths to this directory.\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            //Set up build path for each path prefix, but only do so\n                            //if the path falls out of the current baseUrl\n                            if (paths[prop].indexOf(config.baseUrl) === 0) {\n                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);\n                            } else {\n                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop;\n\n                                //Make sure source path is fully formed with baseUrl,\n                                //if it is a relative URL.\n                                srcPath = paths[prop];\n                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {\n                                    srcPath = config.baseUrl + srcPath;\n                                }\n\n                                destPath = config.dirBaseUrl + buildPaths[prop];\n\n                                //Skip empty: paths\n                                if (srcPath !== 'empty:') {\n                                    //If the srcPath is a directory, copy the whole directory.\n                                    if (fs.exists(srcPath) && fs.isDirectory(srcPath)) {\n                                        //Copy files to build area. Copy all files (the /\\w/ regexp)\n                                        fs.copyDir(srcPath, destPath, /\\w/, true);\n                                    } else {\n                                        //Try a .js extension\n                                        srcPath += '.js';\n                                        destPath += '.js';\n                                        fs.copyFile(srcPath, destPath);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            //Figure out source file location for each module layer. Do this by seeding require\n            //with source area configuration. This is needed so that later the module layers\n            //can be manually copied over to the source area, since the build may be\n            //require multiple times and the above copyDir call only copies newer files.\n            require({\n                baseUrl: config.baseUrl,\n                paths: paths,\n                packagePaths: config.packagePaths,\n                packages: config.packages\n            });\n            buildContext = require.s.contexts._;\n            modules = config.modules;\n\n            if (modules) {\n                modules.forEach(function (module) {\n                    if (module.name) {\n                        module._sourcePath = buildContext.nameToUrl(module.name);\n                        //If the module does not exist, and this is not a \"new\" module layer,\n                        //as indicated by a true \"create\" property on the module, and\n                        //it is not a plugin-loaded resource, and there is no\n                        //'rawText' containing the module's source then throw an error.\n                        if (!fs.exists(module._sourcePath) && !module.create &&\n                                module.name.indexOf('!') === -1 &&\n                                (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                            throw new Error(\"ERROR: module path does not exist: \" +\n                                            module._sourcePath + \" for module named: \" + module.name +\n                                            \". Path is relative to: \" + fs.absPath('.'));\n                        }\n                    }\n                });\n            }\n\n            if (config.out) {\n                //Just set up the _buildPath for the module layer.\n                require(config);\n                if (!config.cssIn) {\n                    config.modules[0]._buildPath = typeof config.out === 'function' ?\n                                                   'FUNCTION' : config.out;\n                }\n            } else if (!config.cssIn) {\n                //Now set up the config for require to use the build area, and calculate the\n                //build file locations. Pass along any config info too.\n                baseConfig = {\n                    baseUrl: config.dirBaseUrl,\n                    paths: buildPaths\n                };\n\n                lang.mixin(baseConfig, config);\n                require(baseConfig);\n\n                if (modules) {\n                    modules.forEach(function (module) {\n                        if (module.name) {\n                            module._buildPath = buildContext.nameToUrl(module.name, null);\n\n                            //If buildPath and sourcePath are the same, throw since this\n                            //would result in modifying source. This condition can happen\n                            //with some more tricky paths: config and appDir/baseUrl\n                            //setting, which is a sign of incorrect config.\n                            if (module._buildPath === module._sourcePath &&\n                                !config.allowSourceOverwrites) {\n                                throw new Error('Module ID \\'' + module.name  +\n                                                '\\' has a source path that is same as output path: ' +\n                                                module._sourcePath +\n                                                '. Stopping, config is malformed.');\n                            }\n\n                            // Copy the file, but only if it is not provided in rawText.\n                            if (!module.create && (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                                fs.copyFile(module._sourcePath, module._buildPath);\n                            }\n                        }\n                    });\n                }\n            }\n\n            //Run CSS optimizations before doing JS module tracing, to allow\n            //things like text loader plugins loading CSS to get the optimized\n            //CSS.\n            if (config.optimizeCss && config.optimizeCss !== \"none\" && config.dir) {\n                buildFileContents += optimize.css(config.dir, config);\n            }\n        }).then(function() {\n            baseConfig = copyConfig(require.s.contexts._.config);\n        }).then(function () {\n            var actions = [];\n\n            if (modules) {\n                actions = modules.map(function (module, i) {\n                    return function () {\n                        //Save off buildPath to module index in a hash for quicker\n                        //lookup later.\n                        config._buildPathToModuleIndex[fs.normalize(module._buildPath)] = i;\n\n                        //Call require to calculate dependencies.\n                        return build.traceDependencies(module, config, baseConfig)\n                            .then(function (layer) {\n                                module.layer = layer;\n                            });\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            var actions;\n\n            if (modules) {\n                //Now build up shadow layers for anything that should be excluded.\n                //Do this after tracing dependencies for each module, in case one\n                //of those modules end up being one of the excluded values.\n                actions = modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            module.excludeLayers = [];\n                            return prim.serial(module.exclude.map(function (exclude, i) {\n                                return function () {\n                                    //See if it is already in the list of modules.\n                                    //If not trace dependencies for it.\n                                    var found = build.findBuildModule(exclude, modules);\n                                    if (found) {\n                                        module.excludeLayers[i] = found;\n                                    } else {\n                                        return build.traceDependencies({name: exclude}, config, baseConfig)\n                                            .then(function (layer) {\n                                                module.excludeLayers[i] = { layer: layer };\n                                            });\n                                    }\n                                };\n                            }));\n                        }\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            if (modules) {\n                return prim.serial(modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            //module.exclude is an array of module names. For each one,\n                            //get the nested dependencies for it via a matching entry\n                            //in the module.excludeLayers array.\n                            module.exclude.forEach(function (excludeModule, i) {\n                                var excludeLayer = module.excludeLayers[i].layer,\n                                    map = excludeLayer.buildFileToModule;\n                                excludeLayer.buildFilePaths.forEach(function(filePath){\n                                    build.removeModulePath(map[filePath], filePath, module.layer);\n                                });\n                            });\n                        }\n                        if (module.excludeShallow) {\n                            //module.excludeShallow is an array of module names.\n                            //shallow exclusions are just that module itself, and not\n                            //its nested dependencies.\n                            module.excludeShallow.forEach(function (excludeShallowModule) {\n                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);\n                                if (path) {\n                                    build.removeModulePath(excludeShallowModule, path, module.layer);\n                                }\n                            });\n                        }\n\n                        //Flatten them and collect the build output for each module.\n                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {\n                            var finalText, baseName;\n                            //Save it to a temp file for now, in case there are other layers that\n                            //contain optimized content that should not be included in later\n                            //layer optimizations. See issue #56.\n                            if (module._buildPath === 'FUNCTION') {\n                                module._buildText = builtModule.text;\n                                module._buildSourceMap = builtModule.sourceMap;\n                            } else {\n                                finalText = builtModule.text;\n                                if (builtModule.sourceMap) {\n                                    baseName = module._buildPath.split('/');\n                                    baseName = baseName.pop();\n                                    finalText += '\\n//# sourceMappingURL=' + baseName + '.map';\n                                    fs.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);\n                                }\n                                fs.saveUtf8File(module._buildPath + '-temp', finalText);\n\n                            }\n                            buildFileContents += builtModule.buildText;\n                        });\n                    };\n                }));\n            }\n        }).then(function () {\n            var moduleName, outOrigSourceMap,\n                bundlesConfig = {},\n                bundlesConfigOutFile = config.bundlesConfigOutFile;\n\n            if (modules) {\n                //Now move the build layers to their final position.\n                modules.forEach(function (module) {\n                    var entryConfig,\n                        finalPath = module._buildPath;\n\n                    if (finalPath !== 'FUNCTION') {\n                        if (fs.exists(finalPath)) {\n                            fs.deleteFile(finalPath);\n                        }\n                        fs.renameFile(finalPath + '-temp', finalPath);\n\n                        //If bundles config should be written out, scan the\n                        //built file for module IDs. Favor doing this reparse\n                        //since tracking the IDs as the file is built has some\n                        //edge cases around files that had more than one ID in\n                        //them already, and likely loader plugin-written contents.\n                        if (bundlesConfigOutFile) {\n                            entryConfig = bundlesConfig[module.name] = [];\n                            var bundleContents = fs.readFile(finalPath);\n                            var excludeMap = {};\n                            excludeMap[module.name] = true;\n                            var parsedIds = parse.getAllNamedDefines(bundleContents, excludeMap);\n                            entryConfig.push.apply(entryConfig, parsedIds);\n                        }\n\n                        //And finally, if removeCombined is specified, remove\n                        //any of the files that were used in this layer.\n                        //Be sure not to remove other build layers.\n                        if (config.removeCombined && !config.out) {\n                            module.layer.buildFilePaths.forEach(function (path) {\n                                var isLayer = modules.some(function (mod) {\n                                        return mod._buildPath === path;\n                                    }),\n                                    relPath = build.makeRelativeFilePath(config.dir, path);\n\n                                if (fs.exists(path) &&\n                                    // not a build layer target\n                                    !isLayer &&\n                                    // not outside the build directory\n                                    relPath.indexOf('..') !== 0) {\n                                    fs.deleteFile(path);\n                                }\n                            });\n                        }\n                    }\n\n                    //Signal layer is done\n                    if (config.onModuleBundleComplete) {\n                        config.onModuleBundleComplete(module.onCompleteData);\n                    }\n                });\n\n                //Write out bundles config, if it is wanted.\n                if (bundlesConfigOutFile) {\n                    var text = fs.readFile(bundlesConfigOutFile);\n                    text = transform.modifyConfig(text, function (config) {\n                        if (!config.bundles) {\n                            config.bundles = {};\n                        }\n\n                        lang.eachProp(bundlesConfig, function (value, prop) {\n                            config.bundles[prop] = value;\n                        });\n\n                        return config;\n                    });\n\n                    fs.saveUtf8File(bundlesConfigOutFile, text);\n                }\n            }\n\n            //If removeCombined in play, remove any empty directories that\n            //may now exist because of its use\n            if (config.removeCombined && !config.out && config.dir) {\n                fs.deleteEmptyDirs(config.dir);\n            }\n\n            //Do other optimizations.\n            if (config.out && !config.cssIn) {\n                //Just need to worry about one JS file.\n                fileName = config.modules[0]._buildPath;\n                if (fileName === 'FUNCTION') {\n                    outOrigSourceMap = config.modules[0]._buildSourceMap;\n                    config._buildSourceMap = outOrigSourceMap;\n                    config.modules[0]._buildText = optimize.js((config.modules[0].name ||\n                                                                config.modules[0].include[0] ||\n                                                                fileName) + '.build.js',\n                                                               config.modules[0]._buildText,\n                                                               null,\n                                                               config);\n                    if (config._buildSourceMap && config._buildSourceMap !== outOrigSourceMap) {\n                        config.modules[0]._buildSourceMap = config._buildSourceMap;\n                        config._buildSourceMap = null;\n                    }\n                } else {\n                    optimize.jsFile(fileName, null, fileName, config);\n                }\n            } else if (!config.cssIn) {\n                //Normal optimizations across modules.\n\n                //JS optimizations.\n                fileNames = fs.getFilteredFileList(config.dir, /\\.js$/, true);\n                fileNames.forEach(function (fileName) {\n                    var cfg, override, moduleIndex;\n\n                    //Generate the module name from the config.dir root.\n                    moduleName = fileName.replace(config.dir, '');\n                    //Get rid of the extension\n                    moduleName = moduleName.substring(0, moduleName.length - 3);\n\n                    //If there is an override for a specific layer build module,\n                    //and this file is that module, mix in the override for use\n                    //by optimize.jsFile.\n                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);\n                    //Normalize, since getOwn could have returned undefined\n                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;\n\n                    //Try to avoid extra work if the other files do not need to\n                    //be read. Build layers should be processed at the very\n                    //least for optimization.\n                    if (moduleIndex > -1 || !config.skipDirOptimize ||\n                            config.normalizeDirDefines === \"all\" ||\n                            config.cjsTranslate) {\n                        //Convert the file to transport format, but without a name\n                        //inserted (by passing null for moduleName) since the files are\n                        //standalone, one module per file.\n                        fileContents = fs.readFile(fileName);\n\n\n                        //For builds, if wanting cjs translation, do it now, so that\n                        //the individual modules can be loaded cross domain via\n                        //plain script tags.\n                        if (config.cjsTranslate &&\n                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                            fileContents = commonJs.convert(fileName, fileContents);\n                        }\n\n                        if (moduleIndex === -1) {\n                            if (config.onBuildRead) {\n                                fileContents = config.onBuildRead(moduleName,\n                                                                  fileName,\n                                                                  fileContents);\n                            }\n\n                            //Only do transport normalization if this is not a build\n                            //layer (since it was already normalized) and if\n                            //normalizeDirDefines indicated all should be done.\n                            if (config.normalizeDirDefines === \"all\") {\n                                fileContents = build.toTransport(config.namespace,\n                                                             null,\n                                                             fileName,\n                                                             fileContents);\n                            }\n\n                            if (config.onBuildWrite) {\n                                fileContents = config.onBuildWrite(moduleName,\n                                                                   fileName,\n                                                                   fileContents);\n                            }\n                        }\n\n                        override = moduleIndex > -1 ?\n                                   config.modules[moduleIndex].override : null;\n                        if (override) {\n                            cfg = build.createOverrideConfig(config, override);\n                        } else {\n                            cfg = config;\n                        }\n\n                        if (moduleIndex > -1 || !config.skipDirOptimize) {\n                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);\n                        }\n                    }\n                });\n\n                //Normalize all the plugin resources.\n                context = require.s.contexts._;\n\n                for (moduleName in pluginCollector) {\n                    if (hasProp(pluginCollector, moduleName)) {\n                        parentModuleMap = context.makeModuleMap(moduleName);\n                        resources = pluginCollector[moduleName];\n                        for (i = 0; i < resources.length; i++) {\n                            resource = resources[i];\n                            moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            if (falseProp(context.plugins, moduleMap.prefix)) {\n                                //Set the value in context.plugins so it\n                                //will be evaluated as a full plugin.\n                                context.plugins[moduleMap.prefix] = true;\n\n                                //Do not bother if the plugin is not available.\n                                if (!fs.exists(require.toUrl(moduleMap.prefix + '.js'))) {\n                                    continue;\n                                }\n\n                                //Rely on the require in the build environment\n                                //to be synchronous\n                                context.require([moduleMap.prefix]);\n\n                                //Now that the plugin is loaded, redo the moduleMap\n                                //since the plugin will need to normalize part of the path.\n                                moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            }\n\n                            //Only bother with plugin resources that can be handled\n                            //processed by the plugin, via support of the writeFile\n                            //method.\n                            if (falseProp(pluginProcessed, moduleMap.id)) {\n                                //Only do the work if the plugin was really loaded.\n                                //Using an internal access because the file may\n                                //not really be loaded.\n                                plugin = getOwn(context.defined, moduleMap.prefix);\n                                if (plugin && plugin.writeFile) {\n                                    plugin.writeFile(\n                                        moduleMap.prefix,\n                                        moduleMap.name,\n                                        require,\n                                        makeWriteFile(\n                                            config.namespace\n                                        ),\n                                        context.config\n                                    );\n                                }\n\n                                pluginProcessed[moduleMap.id] = true;\n                            }\n                        }\n\n                    }\n                }\n\n                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, \"  \"));\n\n\n                //All module layers are done, write out the build.txt file.\n                if (config.writeBuildTxt) {\n                    fs.saveUtf8File(config.dir + \"build.txt\", buildFileContents);\n                }\n            }\n\n            //If just have one CSS file to optimize, do that here.\n            if (config.cssIn) {\n                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;\n            }\n\n            if (typeof config.out === 'function') {\n                config.out(config.modules[0]._buildText, config.modules[0]._buildSourceMap);\n            }\n\n            //Print out what was built into which layers.\n            if (buildFileContents) {\n                logger.info(buildFileContents);\n                return buildFileContents;\n            }\n\n            return '';\n        });\n    };\n\n    /**\n     * Converts command line args like \"paths.foo=../some/path\"\n     * result.paths = { foo: '../some/path' } where prop = paths,\n     * name = paths.foo and value = ../some/path, so it assumes the\n     * name=value splitting has already happened.\n     */\n    function stringDotToObj(result, name, value) {\n        var parts = name.split('.');\n\n        parts.forEach(function (prop, i) {\n            if (i === parts.length - 1) {\n                result[prop] = value;\n            } else {\n                if (falseProp(result, prop)) {\n                    result[prop] = {};\n                }\n                result = result[prop];\n            }\n\n        });\n    }\n\n    build.objProps = {\n        paths: true,\n        wrap: true,\n        pragmas: true,\n        pragmasOnSave: true,\n        has: true,\n        hasOnSave: true,\n        uglify: true,\n        uglify2: true,\n        closure: true,\n        map: true,\n        throwWhen: true,\n        rawText: true\n    };\n\n    build.hasDotPropMatch = function (prop) {\n        var dotProp,\n            index = prop.indexOf('.');\n\n        if (index !== -1) {\n            dotProp = prop.substring(0, index);\n            return hasProp(build.objProps, dotProp);\n        }\n        return false;\n    };\n\n    /**\n     * Converts an array that has String members of \"name=value\"\n     * into an object, where the properties on the object are the names in the array.\n     * Also converts the strings \"true\" and \"false\" to booleans for the values.\n     * member name/value pairs, and converts some comma-separated lists into\n     * arrays.\n     * @param {Array} ary\n     */\n    build.convertArrayToObject = function (ary) {\n        var result = {}, i, separatorIndex, prop, value,\n            needArray = {\n                \"include\": true,\n                \"exclude\": true,\n                \"excludeShallow\": true,\n                \"insertRequire\": true,\n                \"stubModules\": true,\n                \"deps\": true,\n                \"mainConfigFile\": true,\n                \"wrap.startFile\": true,\n                \"wrap.endFile\": true\n            };\n\n        for (i = 0; i < ary.length; i++) {\n            separatorI.ndex = ary[i].indexOf(\"=\");\n            if (separatorIndex === -1) {\n                throw \"Malformed name/value pair: [\" + ary[i] + \"]. Format should be name=value\";\n            }\n\n            value = ary[i].substring(separatorIndex + 1, ary[i].length);\n            if (value === \"true\") {\n                value = true;\n            } else if (value === \"false\") {\n                value = false;\n            }\n\n            prop = ary[i].substring(0, separatorIndex);\n\n            //Convert to array if necessary\n            if (getOwn(needArray, prop)) {\n                value = value.split(\",\");\n            }\n\n            if (build.hasDotPropMatch(prop)) {\n                stringDotToObj(result, prop, value);\n            } else {\n                result[prop] = value;\n            }\n        }\n        return result; //Object\n    };\n\n    build.makeAbsPath = function (path, absFilePath,fs) {\n        if (!absFilePath) {\n            return path;\n        }\n\n        //Add abspath if necessary. If path starts with a slash or has a colon,\n        //then already is an abolute path.\n        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {\n            path = absFilePath +\n                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +\n                   path;\n            path = fs.normalize(path);\n        }\n        return path.replace(lang.backSlashRegExp, '/');\n    };\n\n    build.makeAbsObject = function (props, obj, absFilePath,fs) {\n        var i, prop;\n        if (obj) {\n            for (i = 0; i < props.length; i++) {\n                prop = props[i];\n                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {\n                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath,fs);\n                }\n            }\n        }\n    };\n\n    /**\n     * For any path in a possible config, make it absolute relative\n     * to the absFilePath passed in.\n     */\n    build.makeAbsConfig = function (config, absFilePath,fs) {\n        var props, prop, i;\n\n        props = [\"appDir\", \"dir\", \"baseUrl\"];\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n\n            if (getOwn(config, prop)) {\n                //Add abspath if necessary, make sure these paths end in\n                //slashes\n                if (prop === \"baseUrl\") {\n                    config.originalBaseUrl = config.baseUrl;\n                    if (config.appDir) {\n                        //If baseUrl with an appDir, the baseUrl is relative to\n                        //the appDir, *not* the absFilePath. appDir and dir are\n                        //made absolute before baseUrl, so this will work.\n                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir,fs);\n                    } else {\n                        //The dir output baseUrl is same as regular baseUrl, both\n                        //relative to the absFilePath.\n                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath,fs);\n                    }\n                } else {\n                    config[prop] = build.makeAbsPath(config[prop], absFilePath,fs);\n                }\n\n                config[prop] = endsWithSlash(config[prop]);\n            }\n        }\n\n        build.makeAbsObject((config.out === \"stdout\" ? [\"cssIn\"] : [\"out\", \"cssIn\"]),\n                            config, absFilePath,fs);\n        build.makeAbsObject([\"startFile\", \"endFile\"], config.wrap, absFilePath,fs);\n        build.makeAbsObject([\"externExportsPath\"], config.closure, absFilePath,fs);\n    };\n\n    /**\n     * Creates a relative path to targetPath from refPath.\n     * Only deals with file paths, not folders. If folders,\n     * make sure paths end in a trailing '/'.\n     */\n    build.makeRelativeFilePath = function (refPath, targetPath,fs) {\n        var i, dotLength, finalParts, length, targetParts, targetName,\n            refParts = refPath.split('/'),\n            hasEndSlash = endsWithSlashRegExp.test(targetPath),\n            dotParts = [];\n\n        targetPath = fs.normalize(targetPath);\n        if (hasEndSlash && !endsWithSlashRegExp.test(targetPath)) {\n            targetPath += '/';\n        }\n        targetParts = targetPath.split('/');\n        //Pull off file name\n        targetName = targetParts.pop();\n\n        //Also pop off the ref file name to make the matches against\n        //targetParts equivalent.\n        refParts.pop();\n\n        length = refParts.length;\n\n        for (i = 0; i < length; i += 1) {\n            if (refParts[i] !== targetParts[i]) {\n                break;\n            }\n        }\n\n        //Now i is the index in which they diverge.\n        finalParts = targetParts.slice(i);\n\n        dotLength = length - i;\n        for (i = 0; i > -1 && i < dotLength; i += 1) {\n            dotParts.push('..');\n        }\n\n        return dotParts.join('/') + (dotParts.length ? '/' : '') +\n               finalParts.join('/') + (finalParts.length ? '/' : '') +\n               targetName;\n    };\n\n    build.nestedMix = {\n        paths: true,\n        has: true,\n        hasOnSave: true,\n        pragmas: true,\n        pragmasOnSave: true\n    };\n\n    /**\n     * Mixes additional source config into target config, and merges some\n     * nested config, like paths, correctly.\n     */\n    function mixConfig(target, source, skipArrays) {\n        var prop, value, isArray, targetValue;\n\n        for (prop in source) {\n            if (hasProp(source, prop)) {\n                //If the value of the property is a plain object, then\n                //allow a one-level-deep mixing of it.\n                value = source[prop];\n                isArray = lang.isArray(value);\n                if (typeof value === 'object' && value &&\n                        !isArray && !lang.isFunction(value) &&\n                        !lang.isRegExp(value)) {\n\n                    // TODO: need to generalize this work, maybe also reuse\n                    // the work done in requirejs configure, perhaps move to\n                    // just a deep copy/merge overall. However, given the\n                    // amount of observable change, wait for a dot release.\n                    // This change is in relation to #645\n                    if (prop === 'map') {\n                        if (!target.map) {\n                            target.map = {};\n                        }\n                        lang.deepMix(target.map, source.map);\n                    } else {\n                        target[prop] = lang.mixin({}, target[prop], value, true);\n                    }\n                } else if (isArray) {\n                    if (!skipArrays) {\n                        // Some config, like packages, are arrays. For those,\n                        // just merge the results.\n                        targetValue = target[prop];\n                        if (lang.isArray(targetValue)) {\n                            target[prop] = targetValue.concat(value);\n                        } else {\n                            target[prop] = value;\n                        }\n                    }\n                } else {\n                    target[prop] = value;\n                }\n            }\n        }\n\n        //Set up log level since it can affect if errors are thrown\n        //or caught and passed to errbacks while doing config setup.\n        if (lang.hasProp(target, 'logLevel')) {\n            logger.logLevel(target.logLevel);\n        }\n    }\n\n    /**\n     * Converts a wrap.startFile or endFile to be start/end as a string.\n     * the startFile/endFile values can be arrays.\n     */\n    function flattenWrapFile(config, keyName, absFilePath) {\n        var wrap = config.wrap,\n            keyFileName = keyName + 'File',\n            keyMapName = '__' + keyName + 'Map',\n            fs = config.env.fs;\n\n        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {\n            wrap[keyName] = '';\n            if (typeof wrap[keyFileName] === 'string') {\n                wrap[keyFileName] = [wrap[keyFileName]];\n            }\n            wrap[keyMapName] = [];\n            wrap[keyFileName].forEach(function (fileName) {\n                var absPath = build.makeAbsPath(fileName, absFilePath,fs),\n                    fileText = endsWithNewLine(fs.readFile(absPath));\n                wrap[keyMapName].push(function (fileContents, cfg, sourceMapGenerator) {\n                    return appendToFileContents(fileContents, fileText, absPath, cfg, null, sourceMapGenerator);\n                });\n                wrap[keyName] += fileText;\n            });\n        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {\n            //Allow missing one, just set to empty string.\n            wrap[keyName] = '';\n        } else if (typeof wrap[keyName] === 'string') {\n            wrap[keyName] = endsWithNewLine(wrap[keyName]);\n            wrap[keyMapName] = [\n                function (fileContents, cfg, sourceMapGenerator) {\n                    var absPath = build.makeAbsPath(\"config-wrap-\" + keyName + \"-default.js\", absFilePath,fs);\n                    return appendToFileContents(fileContents, wrap[keyName], absPath, cfg, null, sourceMapGenerator);\n                }\n            ];\n        } else {\n            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');\n        }\n    }\n\n    function normalizeWrapConfig(config, absFilePath) {\n        //Get any wrap text.\n        var fs = config.env.fs;\n        try {\n            if (config.wrap) {\n                if (config.wrap === true) {\n                    //Use default values.\n                    config.wrap = {\n                        start: '(function () {\\n',\n                        end: '}());',\n                        __startMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"(function () {\\n\",\n                                                            build.makeAbsPath(\"config-wrap-start-default.js\",\n                                                                              absFilePath,fs), cfg, null,\n                                                            sourceMapGenerator);\n                            }\n                        ],\n                        __endMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"}());\",\n                                                            build.makeAbsPath(\"config-wrap-end-default.js\", absFilePath,fs),\n                                                            cfg, null, sourceMapGenerator);\n                            }\n                        ]\n                    };\n                } else {\n                    flattenWrapFile(config, 'start', absFilePath);\n                    flattenWrapFile(config, 'end', absFilePath);\n                }\n            }\n        } catch (wrapError) {\n            throw new Error('Malformed wrap config: ' + wrapError.toString());\n        }\n    }\n\n    /**\n     * Creates a config object for an optimization build.\n     * It will also read the build profile if it is available, to create\n     * the configuration.\n     *\n     * @param {Object} cfg config options that take priority\n     * over defaults and ones in the build file. These options could\n     * be from a command line, for instance.\n     *\n     * @param {Object} the created config object.\n     */\n    build.createConfig = function (cfg) {\n        /*jslint evil: true */\n        var fs = cfg.env.fs;\n\n        var buildFileContents, buildFileConfig, mainConfig,\n            mainConfigFile, mainConfigPath, buildFile, absFilePath,\n            config = {},\n            buildBaseConfig = makeBuildBaseConfig(fs);\n\n\n        //Make sure all paths are relative to current directory.\n\n        absFilePath = fs.absPath('.');\n        build.makeAbsConfig(cfg, absFilePath,fs);\n        build.makeAbsConfig(buildBaseConfig, absFilePath,fs);\n\n        lang.mixin(config, buildBaseConfig);\n        lang.mixin(config, cfg, true);\n\n\n        //Set up log level early since it can affect if errors are thrown\n        //or caught and passed to errbacks, even while constructing config.\n        if (lang.hasProp(config, 'logLevel')) {\n            logger.logLevel(config.logLevel);\n        }\n\n        if (config.buildFile) {\n            //A build file exists, load it to get more config.\n            buildFile = fs.absPath(config.buildFile);\n\n            //Find the build file, and make sure it exists, if this is a build\n            //that has a build profile, and not just command line args with an in=path\n            if (!fs.exists(buildFile)) {\n                throw new Error(\"ERROR: build file does not exist: \" + buildFile);\n            }\n\n            absFilePath = config.baseUrl = fs.absPath(fs.parent(buildFile));\n\n            //Load build file options.\n            buildFileContents = fs.readFile(buildFile);\n            try {\n                //Be a bit lenient in the file ending in a ; or ending with\n                //a //# sourceMappingUrl comment, mostly for compiled languages\n                //that create a config, like typescript.\n                buildFileContents = buildFileContents\n                                    .replace(/\\/\\/\\#[^\\n\\r]+[\\n\\r]*$/, '')\n                                    .trim()\n                                    .replace(/;$/, '');\n\n                buildFileConfig = eval(\"(\" + buildFileContents + \")\");\n                build.makeAbsConfig(buildFileConfig, absFilePath,fs);\n\n                //Mix in the config now so that items in mainConfigFile can\n                //be resolved relative to them if necessary, like if appDir\n                //is set here, but the baseUrl is in mainConfigFile. Will\n                //re-mix in the same build config later after mainConfigFile\n                //is processed, since build config should take priority.\n                mixConfig(config, buildFileConfig);\n            } catch (e) {\n                throw new Error(\"Build file \" + buildFile + \" is malformed: \" + e);\n            }\n        }\n\n        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);\n        if (mainConfigFile) {\n            if (typeof mainConfigFile === 'string') {\n                mainConfigFile = [mainConfigFile];\n            }\n\n            mainConfigFile.forEach(function (configFile) {\n                configFile = build.makeAbsPath(configFile, absFilePath,fs);\n                if (!fs.exists(configFile)) {\n                    throw new Error(configFile + ' does not exist.');\n                }\n                try {\n                    mainConfig = parse.findConfig(fs.readFile(configFile)).config;\n                } catch (configError) {\n                    throw new Error('The config in mainConfigFile ' +\n                            configFile +\n                            ' cannot be used because it cannot be evaluated' +\n                            ' correctly while running in the optimizer. Try only' +\n                            ' using a config that is also valid JSON, or do not use' +\n                            ' mainConfigFile and instead copy the config values needed' +\n                            ' into a build file or command line arguments given to the optimizer.\\n' +\n                            'Source error from parsing: ' + configFile + ': ' + configError);\n                }\n                if (mainConfig) {\n                    mainConfigPath = configFile.substring(0, configFile.lastIndexOf('/'));\n\n                    //Add in some existing config, like appDir, since they can be\n                    //used inside the configFile -- paths and baseUrl are\n                    //relative to them.\n                    if (config.appDir && !mainConfig.appDir) {\n                        mainConfig.appDir = config.appDir;\n                    }\n\n                    //If no baseUrl, then use the directory holding the main config.\n                    if (!mainConfig.baseUrl) {\n                        mainConfig.baseUrl = mainConfigPath;\n                    }\n\n                    build.makeAbsConfig(mainConfig, mainConfigPath,fs);\n                    mixConfig(config, mainConfig);\n                }\n            });\n        }\n\n        //Mix in build file config, but only after mainConfig has been mixed in.\n        //Since this is a re-application, skip array merging.\n        if (buildFileConfig) {\n            mixConfig(config, buildFileConfig, true);\n        }\n\n        //Re-apply the override config values. Command line\n        //args should take precedence over build file values.\n        //Since this is a re-application, skip array merging.\n        mixConfig(config, cfg, true);\n\n        //Fix paths to full paths so that they can be adjusted consistently\n        //lately to be in the output area.\n        lang.eachProp(config.paths, function (value, prop) {\n            if (lang.isArray(value)) {\n                throw new Error('paths fallback not supported in optimizer. ' +\n                                'Please provide a build config path override ' +\n                                'for ' + prop);\n            }\n            config.paths[prop] = build.makeAbsPath(value, config.baseUrl,fs);\n        });\n\n        //Set final output dir\n        if (hasProp(config, \"baseUrl\")) {\n            if (config.appDir) {\n                if (!config.originalBaseUrl) {\n                    throw new Error('Please set a baseUrl in the build config');\n                }\n                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir,fs);\n            } else {\n                config.dirBaseUrl = config.dir || config.baseUrl;\n            }\n            //Make sure dirBaseUrl ends in a slash, since it is\n            //concatenated with other strings.\n            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);\n        }\n\n        if (config.bundlesConfigOutFile) {\n            if (!config.dir) {\n                throw new Error('bundlesConfigOutFile can only be used with optimizations ' +\n                                'that use \"dir\".');\n            }\n            config.bundlesConfigOutFile = build.makeAbsPath(config.bundlesConfigOutFile, config.dir,fs);\n        }\n\n        //If out=stdout, write output to STDOUT instead of a file.\n        ///if (config.out && config.out === 'stdout') {\n        ///    config.out = function (content) {\n        ///        var e = env.get();\n        ///        if (e === 'rhino') {\n        ///            var out = new java.io.PrintStream(java.lang.System.out, true, 'UTF-8');\n        ///            out.println(content);\n        ///        } else if (e === 'node') {\n        ///            process.stdout.write(content, 'utf8');\n        ///        } else {\n        ///            console.log(content);\n        ///        }\n        ///    };\n        ///}\n\n        //Check for errors in config\n        if (config.main) {\n            throw new Error('\"main\" passed as an option, but the ' +\n                            'supported option is called \"name\".');\n        }\n        if (config.out && !config.name && !config.modules && !config.include &&\n                !config.cssIn) {\n            throw new Error('Missing either a \"name\", \"include\" or \"modules\" ' +\n                            'option');\n        }\n        if (config.cssIn) {\n            if (config.dir || config.appDir) {\n                throw new Error('cssIn is only for the output of single file ' +\n                    'CSS optimizations and is not compatible with \"dir\" or \"appDir\" configuration.');\n            }\n            if (!config.out) {\n                throw new Error('\"out\" option missing.');\n            }\n        }\n        if (!config.cssIn && !config.baseUrl) {\n            //Just use the current directory as the baseUrl\n            config.baseUrl = './';\n        }\n        if (!config.out && !config.dir) {\n            throw new Error('Missing either an \"out\" or \"dir\" config value. ' +\n                            'If using \"appDir\" for a full project optimization, ' +\n                            'use \"dir\". If you want to optimize to one file, ' +\n                            'use \"out\".');\n        }\n        if (config.appDir && config.out) {\n            throw new Error('\"appDir\" is not compatible with \"out\". Use \"dir\" ' +\n                            'instead. appDir is used to copy whole projects, ' +\n                            'where \"out\" with \"baseUrl\" is used to just ' +\n                            'optimize to one file.');\n        }\n        if (config.out && config.dir) {\n            throw new Error('The \"out\" and \"dir\" options are incompatible.' +\n                            ' Use \"out\" if you are targeting a single file' +\n                            ' for optimization, and \"dir\" if you want the appDir' +\n                            ' or baseUrl directories optimized.');\n        }\n\n\n        if (config.dir) {\n            // Make sure the output dir is not set to a parent of the\n            // source dir or the same dir, as it will result in source\n            // code deletion.\n            if (!config.allowSourceOverwrites && (config.dir === config.baseUrl ||\n                config.dir === config.appDir ||\n                (config.baseUrl && build.makeRelativeFilePath(config.dir,\n                                           config.baseUrl,fs).indexOf('..') !== 0) ||\n                (config.appDir &&\n                    build.makeRelativeFilePath(config.dir, config.appDir,fs).indexOf('..') !== 0))) {\n                throw new Error('\"dir\" is set to a parent or same directory as' +\n                                ' \"appDir\" or \"baseUrl\". This can result in' +\n                                ' the deletion of source code. Stopping. If' +\n                                ' you want to allow possible overwriting of' +\n                                ' source code, set \"allowSourceOverwrites\"' +\n                                ' to true in the build config, but do so at' +\n                                ' your own risk. In that case, you may want' +\n                                ' to also set \"keepBuildDir\" to true.');\n            }\n        }\n\n        if (config.insertRequire && !lang.isArray(config.insertRequire)) {\n            throw new Error('insertRequire should be a list of module IDs' +\n                            ' to insert in to a require([]) call.');\n        }\n\n        //Support older configs with uglify2 settings, but now that uglify1 has\n        //been removed, just translate it to 'uglify' settings.\n        if (config.optimize === 'uglify2') {\n            config.optimize = 'uglify';\n        }\n        if (config.uglify2) {\n            config.uglify = config.uglify2;\n            delete config.uglify2;\n        }\n\n        if (config.generateSourceMaps) {\n            if (config.preserveLicenseComments && !(config.optimize === 'none' || config.optimize === 'uglify')) {\n                throw new Error('Cannot use preserveLicenseComments and ' +\n                    'generateSourceMaps together, unless optimize is set ' +\n                    'to \\'uglify\\'. Either explicitly set preserveLicenseComments ' +\n                    'to false (default is true) or turn off generateSourceMaps. ' +\n                    'If you want source maps with license comments, see: ' +\n                    'http://requirejs.org/docs/errors.html#sourcemapcomments');\n            } else if (config.optimize !== 'none' &&\n                       config.optimize !== 'closure' &&\n                       config.optimize !== 'uglify') {\n                //Allow optimize: none to pass, since it is useful when toggling\n                //minification on and off to debug something, and it implicitly\n                //works, since it does not need a source map.\n                throw new Error('optimize: \"' + config.optimize +\n                    '\" does not support generateSourceMaps.');\n            }\n        }\n\n        if ((config.name || config.include) && !config.modules) {\n            //Just need to build one file, but may be part of a whole appDir/\n            //baseUrl copy, but specified on the command line, so cannot do\n            //the modules array setup. So create a modules section in that\n            //case.\n            config.modules = [\n                {\n                    name: config.name,\n                    out: config.out,\n                    create: config.create,\n                    include: config.include,\n                    exclude: config.exclude,\n                    excludeShallow: config.excludeShallow,\n                    insertRequire: config.insertRequire,\n                    stubModules: config.stubModules\n                }\n            ];\n            delete config.stubModules;\n        } else if (config.modules && config.out) {\n            throw new Error('If the \"modules\" option is used, then there ' +\n                            'should be a \"dir\" option set and \"out\" should ' +\n                            'not be used since \"out\" is only for single file ' +\n                            'optimization output.');\n        } else if (config.modules && config.name) {\n            throw new Error('\"name\" and \"modules\" options are incompatible. ' +\n                            'Either use \"name\" if doing a single file ' +\n                            'optimization, or \"modules\" if you want to target ' +\n                            'more than one file for optimization.');\n        }\n\n        if (config.out && !config.cssIn) {\n            //Just one file to optimize.\n\n            //Does not have a build file, so set up some defaults.\n            //Optimizing CSS should not be allowed, unless explicitly\n            //asked for on command line. In that case the only task is\n            //to optimize a CSS file.\n            if (!cfg.optimizeCss) {\n                config.optimizeCss = \"none\";\n            }\n        }\n\n        //Normalize cssPrefix\n        if (config.cssPrefix) {\n            //Make sure cssPrefix ends in a slash\n            config.cssPrefix = endsWithSlash(config.cssPrefix);\n        } else {\n            config.cssPrefix = '';\n        }\n\n        //Cycle through modules and normalize\n        if (config.modules && config.modules.length) {\n            config.modules.forEach(function (mod) {\n                if (lang.isArray(mod) || typeof mod === 'string' || !mod) {\n                    throw new Error('modules config item is malformed: it should' +\n                                    ' be an object with a \\'name\\' property.');\n                }\n\n                //Combine any local stubModules with global values.\n                if (config.stubModules) {\n                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);\n                }\n\n                //Create a hash lookup for the stubModules config to make lookup\n                //cheaper later.\n                if (mod.stubModules) {\n                    mod.stubModules._byName = {};\n                    mod.stubModules.forEach(function (id) {\n                        mod.stubModules._byName[id] = true;\n                    });\n                }\n\n                // Legacy command support, which allowed a single string ID\n                // for include.\n                if (typeof mod.include === 'string') {\n                    mod.include = [mod.include];\n                }\n\n                //Allow wrap config in overrides, but normalize it.\n                if (mod.override) {\n                    normalizeWrapConfig(mod.override, absFilePath);\n                }\n            });\n        }\n\n        normalizeWrapConfig(config, absFilePath);\n\n        //Do final input verification\n        if (config.context) {\n            throw new Error('The build argument \"context\" is not supported' +\n                            ' in a build. It should only be used in web' +\n                            ' pages.');\n        }\n\n        //Set up normalizeDirDefines. If not explicitly set, if optimize \"none\",\n        //set to \"skip\" otherwise set to \"all\".\n        if (!hasProp(config, 'normalizeDirDefines')) {\n            if (config.optimize === 'none' || config.skipDirOptimize) {\n                config.normalizeDirDefines = 'skip';\n            } else {\n                config.normalizeDirDefines = 'all';\n            }\n        }\n\n        //Set fs.fileExclusionRegExp if desired\n        if (hasProp(config, 'fileExclusionRegExp')) {\n            if (typeof config.fileExclusionRegExp === \"string\") {\n                fs.exclusionRegExp = new RegExp(config.fileExclusionRegExp);\n            } else {\n                fs.exclusionRegExp = config.fileExclusionRegExp;\n            }\n        } else if (hasProp(config, 'dirExclusionRegExp')) {\n            //Set fs.dirExclusionRegExp if desired, this is the old\n            //name for fileExclusionRegExp before 1.0.2. Support for backwards\n            //compatibility\n            fs.exclusionRegExp = config.dirExclusionRegExp;\n        }\n\n        //Track the deps, but in a different key, so that they are not loaded\n        //as part of config seeding before all config is in play (#648). Was\n        //going to merge this in with \"include\", but include is added after\n        //the \"name\" target. To preserve what r.js has done previously, make\n        //sure \"deps\" comes before the \"name\".\n        if (config.deps) {\n            config._depsInclude = config.deps;\n        }\n\n\n        //Remove things that may cause problems in the build.\n        //deps already merged above\n        delete config.deps;\n        delete config.jQuery;\n        delete config.enforceDefine;\n        delete config.urlArgs;\n\n        return config;\n    };\n\n    /**\n     * finds the module being built/optimized with the given moduleName,\n     * or returns null.\n     * @param {String} moduleName\n     * @param {Array} modules\n     * @returns {Object} the module object from the build profile, or null.\n     */\n    build.findBuildModule = function (moduleName, modules) {\n        var i, module;\n        for (i = 0; i < modules.length; i++) {\n            module = modules[i];\n            if (module.name === moduleName) {\n                return module;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Removes a module name and path from a layer, if it is supposed to be\n     * excluded from the layer.\n     * @param {String} moduleName the name of the module\n     * @param {String} path the file path for the module\n     * @param {Object} layer the layer to remove the module/path from\n     */\n    build.removeModulePath = function (module, path, layer) {\n        var index = layer.buildFilePaths.indexOf(path);\n        if (index !== -1) {\n            layer.buildFilePaths.splice(index, 1);\n        }\n    };\n\n    /**\n     * Uses the module build config object to trace the dependencies for the\n     * given module.\n     *\n     * @param {Object} module the module object from the build config info.\n     * @param {Object} config the build config object.\n     * @param {Object} [baseLoaderConfig] the base loader config to use for env resets.\n     *\n     * @returns {Object} layer information about what paths and modules should\n     * be in the flattened module.\n     */\n    build.traceDependencies = function (module, config, baseLoaderConfig) {\n        var include, override, layer, context, oldContext,\n            rawTextByIds,\n            syncChecks = {\n                rhino: true,\n                node: true,\n                xpconnect: true\n            },\n            deferred = prim();\n\n        //Reset some state set up in requirePatch.js, and clean up require's\n        //current context.\n        oldContext = require._buildReset();\n\n        //Grab the reset layer and context after the reset, but keep the\n        //old config to reuse in the new context.\n        layer = require._layer;\n        context = layer.context;\n\n        //Put back basic config, use a fresh object for it.\n        if (baseLoaderConfig) {\n            require(copyConfig(baseLoaderConfig));\n        }\n\n        logger.trace(\"\\nTracing dependencies for: \" + (module.name ||\n                     (typeof module.out === 'function' ? 'FUNCTION' : module.out)));\n        include = config._depsInclude ||  [];\n        include = include.concat(module.name && !module.create ? [module.name] : []);\n        if (module.include) {\n            include = include.concat(module.include);\n        }\n\n        //If there are overrides to basic config, set that up now.;\n        if (module.override) {\n            if (baseLoaderConfig) {\n                override = build.createOverrideConfig(baseLoaderConfig, module.override);\n            } else {\n                override = copyConfig(module.override);\n            }\n            require(override);\n        }\n\n        //Now, populate the rawText cache with any values explicitly passed in\n        //via config.\n        rawTextByIds = require.s.contexts._.config.rawText;\n        if (rawTextByIds) {\n            lang.eachProp(rawTextByIds, function (contents, id) {\n                var url = require.toUrl(id) + '.js';\n                require._cachedRawText[url] = contents;\n            });\n        }\n\n\n        //Configure the callbacks to be called.\n        deferred.reject.__requireJsBuild = true;\n\n        //Use a wrapping function so can check for errors.\n        function includeFinished(value) {\n            //If a sync build environment, check for errors here, instead of\n            //in the then callback below, since some errors, like two IDs pointed\n            //to same URL but only one anon ID will leave the loader in an\n            //unresolved state since a setTimeout cannot be used to check for\n            //timeout.\n            var hasError = false;\n            if (syncChecks[config.env.name]) {\n                try {\n                    build.checkForErrors(context, layer);\n                } catch (e) {\n                    hasError = true;\n                    deferred.reject(e);\n                }\n            }\n\n            if (!hasError) {\n                deferred.resolve(value);\n            }\n        }\n        includeFinished.__requireJsBuild = true;\n\n        //Figure out module layer dependencies by calling require to do the work.\n        require(include, includeFinished, deferred.reject);\n\n        // If a sync env, then with the \"two IDs to same anon module path\"\n        // issue, the require never completes, need to check for errors\n        // here.\n        if (syncChecks[config.env.name]) {\n            build.checkForErrors(context, layer);\n        }\n\n        return deferred.promise.then(function () {\n            //Reset config\n            if (module.override && baseLoaderConfig) {\n                require(copyConfig(baseLoaderConfig));\n            }\n\n            build.checkForErrors(context, layer);\n\n            return layer;\n        });\n    };\n\n    build.checkForErrors = function (context, layer) {\n        //Check to see if it all loaded. If not, then throw, and give\n        //a message on what is left.\n        var id, prop, mod, idParts, pluginId, pluginResources,\n            errMessage = '',\n            failedPluginMap = {},\n            failedPluginIds = [],\n            errIds = [],\n            errUrlMap = {},\n            errUrlConflicts = {},\n            hasErrUrl = false,\n            hasUndefined = false,\n            defined = context.defined,\n            registry = context.registry;\n\n        function populateErrUrlMap(id, errUrl, skipNew) {\n            // Loader plugins do not have an errUrl, so skip them.\n            if (!errUrl) {\n                return;\n            }\n\n            if (!skipNew) {\n                errIds.push(id);\n            }\n\n            if (errUrlMap[errUrl]) {\n                hasErrUrl = true;\n                //This error module has the same URL as another\n                //error module, could be misconfiguration.\n                if (!errUrlConflicts[errUrl]) {\n                    errUrlConflicts[errUrl] = [];\n                    //Store the original module that had the same URL.\n                    errUrlConflicts[errUrl].push(errUrlMap[errUrl]);\n                }\n                errUrlConflicts[errUrl].push(id);\n            } else if (!skipNew) {\n                errUrlMap[errUrl] = id;\n            }\n        }\n\n        for (id in registry) {\n            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {\n                hasUndefined = true;\n                mod = getOwn(registry, id);\n                idParts = id.split('!');\n                pluginId = idParts[0];\n\n                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {\n                    populateErrUrlMap(id, mod.map.url);\n                }\n\n                //Look for plugins that did not call load()\n                //But skip plugin IDs that were already inlined and called\n                //define() with a name.\n                if (!hasProp(layer.modulesWithNames, id) && idParts.length > 1) {\n                    if (falseProp(failedPluginMap, pluginId)) {\n                        failedPluginIds.push(pluginId);\n                    }\n                    pluginResources = failedPluginMap[pluginId];\n                    if (!pluginResources) {\n                        pluginResources = failedPluginMap[pluginId] = [];\n                    }\n                    pluginResources.push(id + (mod.error ? ': ' + mod.error : ''));\n                }\n            }\n        }\n\n        // If have some modules that are not defined/stuck in the registry,\n        // then check defined modules for URL overlap.\n        if (hasUndefined) {\n            for (id in defined) {\n                if (hasProp(defined, id) && id.indexOf('!') === -1) {\n                    populateErrUrlMap(id, require.toUrl(id) + '.js', true);\n                }\n            }\n        }\n\n        if (errIds.length || failedPluginIds.length) {\n            if (failedPluginIds.length) {\n                errMessage += 'Loader plugin' +\n                    (failedPluginIds.length === 1 ? '' : 's') +\n                    ' did not call ' +\n                    'the load callback in the build:\\n' +\n                    failedPluginIds.map(function (pluginId) {\n                        var pluginResources = failedPluginMap[pluginId];\n                        return pluginId + ':\\n  ' + pluginResources.join('\\n  ');\n                    }).join('\\n') + '\\n';\n            }\n            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');\n\n            if (hasErrUrl) {\n                errMessage += '\\nThe following modules share the same URL. This ' +\n                              'could be a misconfiguration if that URL only has ' +\n                              'one anonymous module in it:';\n                for (prop in errUrlConflicts) {\n                    if (hasProp(errUrlConflicts, prop)) {\n                        errMessage += '\\n' + prop + ': ' +\n                                      errUrlConflicts[prop].join(', ');\n                    }\n                }\n            }\n            throw new Error(errMessage);\n        }\n    };\n\n    build.createOverrideConfig = function (config, override) {\n        var cfg = copyConfig(config),\n            oride = copyConfig(override);\n\n        lang.eachProp(oride, function (value, prop) {\n            if (hasProp(build.objProps, prop)) {\n                //An object property, merge keys. Start a new object\n                //so that source object in config does not get modified.\n                cfg[prop] = {};\n                lang.mixin(cfg[prop], config[prop], true);\n                lang.mixin(cfg[prop], override[prop], true);\n            } else {\n                cfg[prop] = override[prop];\n            }\n        });\n\n        return cfg;\n    };\n\n    /**\n     * Uses the module build config object to create an flattened version\n     * of the module, with deep dependencies included.\n     *\n     * @param {Object} module the module object from the build config info.\n     *\n     * @param {Object} layer the layer object returned from build.traceDependencies.\n     *\n     * @param {Object} the build config object.\n     *\n     * @returns {Object} with two properties: \"text\", the text of the flattened\n     * module, and \"buildText\", a string of text representing which files were\n     * included in the flattened module text.\n     */\n    build.flattenModule = function (module, layer, config) {\n        var fileContents, sourceMapGenerator,\n            sourceMapBase,\n            buildFileContents = '',\n            fs = config.env.fs;\n\n        return prim().start(function () {\n            var reqIndex, currContents, fileForSourceMap,\n                moduleName, shim, packageName,\n                parts, builder, writeApi,\n                namespace, namespaceWithDot, stubModulesByName,\n                context = layer.context,\n                onLayerEnds = [],\n                onLayerEndAdded = {},\n                pkgsMainMap = {};\n\n            //Use override settings, particularly for pragmas\n            //Do this before the var readings since it reads config values.\n            if (module.override) {\n                config = build.createOverrideConfig(config, module.override);\n            }\n\n            namespace = config.namespace || '';\n            namespaceWithDot = namespace ? namespace + '.' : '';\n            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};\n\n            //Start build output for the module.\n            module.onCompleteData = {\n                name: module.name,\n                path: (config.dir ? module._buildPath.replace(config.dir, \"\") : module._buildPath),\n                included: []\n            };\n\n            buildFileContents += \"\\n\" +\n                                  module.onCompleteData.path +\n                                 \"\\n----------------\\n\";\n\n            //If there was an existing file with require in it, hoist to the top.\n            if (layer.existingRequireUrl) {\n                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);\n                if (reqIndex !== -1) {\n                    layer.buildFilePaths.splice(reqIndex, 1);\n                    layer.buildFilePaths.unshift(layer.existingRequireUrl);\n                }\n            }\n\n            if (config.generateSourceMaps) {\n                sourceMapBase = config.dir || config.baseUrl;\n                if (module._buildPath === 'FUNCTION') {\n                    fileForSourceMap = (module.name || module.include[0] || 'FUNCTION') + '.build.js';\n                } else if (config.out) {\n                    fileForSourceMap = module._buildPath.split('/').pop();\n                } else {\n                    fileForSourceMap = module._buildPath.replace(sourceMapBase, '');\n                }\n                sourceMapGenerator = new SourceMapGenerator({\n                    file: fileForSourceMap\n                });\n            }\n\n            //Create a reverse lookup for packages main module IDs to their package\n            //names, useful for knowing when to write out define() package main ID\n            //adapters.\n            lang.eachProp(layer.context.config.pkgs, function(value, prop) {\n                pkgsMainMap[value] = prop;\n            });\n\n            //Write the built module to disk, and build up the build output.\n            fileContents = \"\";\n            if (config.wrap && config.wrap.__startMap) {\n                config.wrap.__startMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n\n            return prim.serial(layer.buildFilePaths.map(function (path) {\n                return function () {\n                    var singleContents = '';\n\n                    moduleName = layer.buildFileToModule[path];\n\n                    //If the moduleName is a package main, then hold on to the\n                    //packageName in case an adapter needs to be written.\n                    packageName = getOwn(pkgsMainMap, moduleName);\n\n                    return prim().start(function () {\n                        //Figure out if the module is a result of a build plugin, and if so,\n                        //then delegate to that plugin.\n                        parts = context.makeModuleMap(moduleName);\n                        builder = parts.prefix && getOwn(context.defined, parts.prefix);\n                        if (builder) {\n                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {\n                                onLayerEnds.push(builder);\n                                onLayerEndAdded[parts.prefix] = true;\n                            }\n\n                            if (builder.write) {\n                                writeApi = function (input) {\n                                    singleContents += \"\\n\" + addSemiColon(input, config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n                                writeApi.asModule = function (moduleName, input) {\n                                    singleContents += \"\\n\" +\n                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {\n                                            useSourceUrl: layer.context.config.useSourceUrl\n                                        }), config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n\n                                builder.write(parts.prefix, parts.name, writeApi, {\n                                    name: module.onCompleteData.name,\n                                    path: module.onCompleteData.path\n                                });\n                            }\n                            return;\n                        } else {\n                            return prim().start(function () {\n                                if (hasProp(stubModulesByName, moduleName)) {\n                                    //Just want to insert a simple module definition instead\n                                    //of the source module. Useful for plugins that inline\n                                    //all their resources.\n                                    if (hasProp(layer.context.plugins, moduleName)) {\n                                        //Slightly different content for plugins, to indicate\n                                        //that dynamic loading will not work.\n                                        return 'define({load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});';\n                                    } else {\n                                        return 'define({});';\n                                    }\n                                } else {\n                                    return require._cacheReadAsync(path,undefined,fs);\n                                }\n                            }).then(function (text) {\n                                var hasPackageName;\n\n                                currContents = text;\n\n                                if (config.cjsTranslate &&\n                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                                    currContents = commonJs.convert(path, currContents);\n                                }\n\n                                if (config.onBuildRead) {\n                                    currContents = config.onBuildRead(moduleName, path, currContents);\n                                }\n\n                                if (packageName) {\n                                    hasPackageName = (packageName === parse.getNamedDefine(currContents));\n                                }\n\n                                if (namespace) {\n                                    currContents = pragma.namespace(currContents, namespace);\n                                }\n\n                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {\n                                    useSourceUrl: config.useSourceUrl\n                                });\n\n                                if (packageName && !hasPackageName) {\n                                    currContents = addSemiColon(currContents, config) + '\\n';\n                                    currContents += namespaceWithDot + \"define('\" +\n                                                    packageName + \"', ['\" + moduleName +\n                                                    \"'], function (main) { return main; });\\n\";\n                                }\n\n                                if (config.onBuildWrite) {\n                                    currContents = config.onBuildWrite(moduleName, path, currContents);\n                                }\n\n                                //Semicolon is for files that are not well formed when\n                                //concatenated with other content.\n                                singleContents += addSemiColon(currContents, config);\n                            });\n                        }\n                    }).then(function () {\n                        var shimDeps, shortPath = path.replace(config.dir, \"\");\n\n                        module.onCompleteData.included.push(shortPath);\n                        buildFileContents += shortPath + \"\\n\";\n\n                        //Some files may not have declared a require module, and if so,\n                        //put in a placeholder call so the require does not try to load them\n                        //after the module is processed.\n                        //If we have a name, but no defined module, then add in the placeholder.\n                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {\n                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageName && getOwn(config.shim, packageName)));\n                            if (shim) {\n                                shimDeps = lang.isArray(shim) ? shim : shim.deps;\n                                if (config.wrapShim) {\n\n                                    singleContents = '(function(root) {\\n' +\n                                                     namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '[], ') +\n                                                    'function() {\\n' +\n                                                    '  return (function() {\\n' +\n                                                             singleContents +\n                                                             // Start with a \\n in case last line is a comment\n                                                             // in the singleContents, like a sourceURL comment.\n                                                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                                                             '\\n' +\n                                                    '  }).apply(root, arguments);\\n' +\n                                                    '});\\n' +\n                                                    '}(this));\\n';\n                                } else {\n                                    singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '') +\n                                                     (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                                                     ');\\n';\n                                }\n                            } else {\n                                singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", function(){});\\n';\n                            }\n                        }\n\n                        //Add line break at end of file, instead of at beginning,\n                        //so source map line numbers stay correct, but still allow\n                        //for some space separation between files in case ASI issues\n                        //for concatenation would cause an error otherwise.\n                        singleContents += '\\n';\n\n                        //Add to the source map and to the final contents\n                        fileContents = appendToFileContents(fileContents, singleContents, path, config, module,\n                                                            sourceMapGenerator);\n                    });\n                };\n            })).then(function () {\n                if (onLayerEnds.length) {\n                    onLayerEnds.forEach(function (builder, index) {\n                        var path;\n                        if (typeof module.out === 'string') {\n                            path = module.out;\n                        } else if (typeof module._buildPath === 'string') {\n                            path = module._buildPath;\n                        }\n                        builder.onLayerEnd(function (input) {\n                            fileContents =\n                                appendToFileContents(fileContents, \"\\n\" + addSemiColon(input, config),\n                                                     'onLayerEnd' + index + '.js', config, module, sourceMapGenerator);\n                        }, {\n                            name: module.name,\n                            path: path\n                        });\n                    });\n                }\n\n                if (module.create) {\n                    //The ID is for a created layer. Write out\n                    //a module definition for it in case the\n                    //built file is used with enforceDefine\n                    //(#432)\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'define(\"' + module.name +\n                                                           '\", function(){});\\n', 'module-create.js', config, module,\n                                             sourceMapGenerator);\n                }\n\n                //Add a require at the end to kick start module execution, if that\n                //was desired. Usually this is only specified when using small shim\n                //loaders like almond.\n                if (module.insertRequire) {\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'require([\"' + module.insertRequire.join('\", \"') +\n                                                           '\"]);\\n', 'module-insertRequire.js', config, module,\n                                             sourceMapGenerator);\n                }\n            });\n        }).then(function () {\n            if (config.wrap && config.wrap.__endMap) {\n                config.wrap.__endMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n            return {\n                text: fileContents,\n                buildText: buildFileContents,\n                sourceMap: sourceMapGenerator ?\n                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :\n                              undefined\n            };\n        });\n    };\n\n    //Converts an JS array of strings to a string representation.\n    //Not using JSON.stringify() for Rhino's sake.\n    build.makeJsArrayString = function (ary) {\n        return '[\"' + ary.map(function (item) {\n            //Escape any double quotes, backslashes\n            return lang.jsEscape(item);\n        }).join('\",\"') + '\"]';\n    };\n\n    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {\n        var baseUrl = layer && layer.context.config.baseUrl;\n\n        function onFound(info) {\n            //Only mark this module as having a name if not a named module,\n            //or if a named module and the name matches expectations.\n            if (layer && (info.needsId || info.foundId === moduleName)) {\n                layer.modulesWithNames[moduleName] = true;\n            }\n        }\n\n        //Convert path to be a local one to the baseUrl, useful for\n        //useSourceUrl.\n        if (baseUrl) {\n            path = path.replace(baseUrl, '');\n        }\n\n        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);\n    };\n\n    return require.build = build;\n});\n"]}