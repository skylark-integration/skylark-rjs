{"version":3,"sources":["optimize.js"],"names":["define","lang","logger","parse","pragma","uglify","sourceMap","optimize","cssImportRegExp","cssCommentImportRegExp","cssUrlRegExp","protocolRegExp","SourceMapGenerator","SourceMapConsumer","cleanCssUrlQuotes","url","replace","charAt","substring","length","fixCssUrlPaths","fileName","path","contents","cssPrefix","fullMatch","urlMatch","firstChar","hasProtocol","parts","i","fixedUrlMatch","backSlashRegExp","test","trace","split","splice","join","jsFile","fileContents","outFileName","config","pluginCollector","fs","env","readFile","js","saveUtf8File","optFunc","optConfig","String","optimizerName","keepLines","licenseContents","process","optimizers","Error","generateSourceMaps","_buildSourceMap","preserveLicenseComments","getLicenseComments","e","toString","preamble","throwWhen","error","cssFile","startIndex","endIndex","buildText","comment","originalFileContents","flat","flattenCss","cssImportIgnore","included","topLevel","lastIndexOf","filePath","importList","skippedList","urlStart","importFileName","urlEnd","mediaTypes","push","indexOf","importEndIndex","fullImportFileName","importContents","apply","warn","optimizeCss","dir","map","css","startDir","result","fileList","shouldRemove","removeCombined","getFilteredFileList","pop","concat","forEach","exists","deleteFile","existingMap","resultMap","uconfig","existingMapPath","baseName","mixin","output","outSourceMap","JSON","inSourceMap","minify","saveFile","code","errorString","isSyntaxError"],"mappings":"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","file":"../optimize.js","sourcesContent":["/*jslint plusplus: true, nomen: true, regexp: true */\n/*global define: false */\n\ndefine([ \n    './lang', \n    './logger', \n///    'env!env/optimize', \n///    'env!env/file', \n    './parse',\n    './pragma', \n    './uglifyjs',\n    './source-map'\n],function (\n    lang,\n    logger,\n///     envOptimize, \n///     file, \n     parse,\n     pragma, \n     uglify,\n     sourceMap\n) {\n    'use strict';\n\n    var optimize,\n        cssImportRegExp = /\\@import\\s+(url\\()?\\s*([^);]+)\\s*(\\))?([\\w, ]*)(;)?/ig,\n        cssCommentImportRegExp = /\\/\\*[^\\*]*@import[^\\*]*\\*\\//g,\n        cssUrlRegExp = /\\url\\(\\s*([^\\)]+)\\s*\\)?/g,\n        protocolRegExp = /^\\w+:/,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        SourceMapConsumer = sourceMap.SourceMapConsumer,\n        es5PlusGuidance = 'If the source uses ES2015 or later syntax, please pass \"optimize: \\'none\\'\" to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.';\n\n    /**\n     * If an URL from a CSS url value contains start/end quotes, remove them.\n     * This is not done in the regexp, since my regexp fu is not that strong,\n     * and the CSS spec allows for ' and \" in the URL if they are backslash escaped.\n     * @param {String} url\n     */\n    function cleanCssUrlQuotes(url) {\n        //Make sure we are not ending in whitespace.\n        //Not very confident of the css regexps above that there will not be ending\n        //whitespace.\n        url = url.replace(/\\s+$/, \"\");\n\n        if (url.charAt(0) === \"'\" || url.charAt(0) === \"\\\"\") {\n            url = url.substring(1, url.length - 1);\n        }\n\n        return url;\n    }\n\n    function fixCssUrlPaths(fileName, path, contents, cssPrefix) {\n        return contents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {\n            var firstChar, hasProtocol, parts, i,\n                fixedUrlMatch = cleanCssUrlQuotes(urlMatch);\n\n            fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, \"/\");\n\n            //Only do the work for relative URLs. Skip things that start with / or #, or have\n            //a protocol.\n            firstChar = fixedUrlMatch.charAt(0);\n            hasProtocol = protocolRegExp.test(fixedUrlMatch);\n            if (firstChar !== \"/\" && firstChar !== \"#\" && !hasProtocol) {\n                //It is a relative URL, tack on the cssPrefix and path prefix\n                urlMatch = cssPrefix + path + fixedUrlMatch;\n            } else if (!hasProtocol) {\n                logger.trace(fileName + \"\\n  URL not a relative URL, skipping: \" + urlMatch);\n            }\n\n            //Collapse .. and .\n            parts = urlMatch.split(\"/\");\n            for (i = parts.length - 1; i > 0; i--) {\n                if (parts[i] === \".\") {\n                    parts.splice(i, 1);\n                } else if (parts[i] === \"..\") {\n                    if (i !== 0 && parts[i - 1] !== \"..\") {\n                        parts.splice(i - 1, 2);\n                        i -= 1;\n                    }\n                }\n            }\n\n            return \"url(\" + parts.join(\"/\") + \")\";\n        });\n    }\n\n    /**\n     * Inlines nested stylesheets that have @import calls in them.\n     * @param {String} fileName the file name\n     * @param {String} fileContents the file contents\n     * @param {String} cssImportIgnore comma delimited string of files to ignore\n     * @param {String} cssPrefix string to be prefixed before relative URLs\n     * @param {Object} included an object used to track the files already imported\n     */\n    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included, topLevel,config) {\n        //Find the last slash in the name.\n        fileName = fileName.replace(lang.backSlashRegExp, \"/\");\n        var endIndex = fileName.lastIndexOf(\"/\"),\n            //Make a file path based on the last slash.\n            //If no slash, so must be just a file name. Use empty string then.\n            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : \"\",\n            //store a list of merged files\n            importList = [],\n            skippedList = [],\n            fs = config.env.fs;\n\n        //First make a pass by removing any commented out @import calls.\n        fileContents = fileContents.replace(cssCommentImportRegExp, '');\n\n        //Make sure we have a delimited ignore list to make matching faster\n        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== \",\") {\n            cssImportIgnore += \",\";\n        }\n\n        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {\n            //Only process media type \"all\" or empty media type rules.\n            if (mediaTypes && ((mediaTypes.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')) !== \"all\")) {\n                skippedList.push(fileName);\n                return fullMatch;\n            }\n\n            importFileName = cleanCssUrlQuotes(importFileName);\n\n            //Ignore the file import if it is part of an ignore list.\n            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + \",\") !== -1) {\n                return fullMatch;\n            }\n\n            //Make sure we have a unix path for the rest of the operation.\n            importFileName = importFileName.replace(lang.backSlashRegExp, \"/\");\n\n            try {\n                //if a relative path, then tack on the filePath.\n                //If it is not a relative path, then the readFile below will fail,\n                //and we will just skip that import.\n                var fullImportFileName = importFileName.charAt(0) === \"/\" ? importFileName : filePath + importFileName,\n                    importContents = fs.readFile(fullImportFileName),\n                    importEndIndex, importPath, flat;\n\n                //Skip the file if it has already been included.\n                if (included[fullImportFileName]) {\n                    return '';\n                }\n                included[fullImportFileName] = true;\n\n                //Make sure to flatten any nested imports.\n                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included,false,config);\n                importContents = flat.fileContents;\n\n                if (flat.importList.length) {\n                    importList.push.apply(importList, flat.importList);\n                }\n                if (flat.skippedList.length) {\n                    skippedList.push.apply(skippedList, flat.skippedList);\n                }\n\n                //Make the full import path\n                importEndIndex = importFileName.lastIndexOf(\"/\");\n\n                //Make a file path based on the last slash.\n                //If no slash, so must be just a file name. Use empty string then.\n                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : \"\";\n\n                //fix url() on relative import (#5)\n                importPath = importPath.replace(/^\\.\\//, '');\n\n                //Modify URL paths to match the path represented by this file.\n                importContents = fixCssUrlPaths(importFileName, importPath, importContents, cssPrefix);\n\n                importList.push(fullImportFileName);\n                return importContents;\n            } catch (e) {\n                logger.warn(fileName + \"\\n  Cannot inline css import, skipping: \" + importFileName);\n                return fullMatch;\n            }\n        });\n\n        if (cssPrefix && topLevel) {\n            //Modify URL paths to match the path represented by this file.\n            fileContents = fixCssUrlPaths(fileName, '', fileContents, cssPrefix);\n        }\n\n        return {\n            importList : importList,\n            skippedList: skippedList,\n            fileContents : fileContents\n        };\n    }\n\n    optimize = {\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file to optimize\n         * @param {String} fileContents the contents to optimize. If this is\n         * a null value, then fileName will be used to read the fileContents.\n         * @param {String} outFileName the name of the file to use for the\n         * saved optimized content.\n         * @param {Object} config the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var fs = config.env.fs;\n            if (!fileContents) {\n                fileContents = fs.readFile(fileName);\n            }\n\n            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);\n\n            fs.saveUtf8File(outFileName, fileContents);\n        },\n\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file that matches the\n         * fileContents.\n         * @param {String} fileContents the string of JS to optimize.\n         * @param {Object} [config] the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        js: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var optFunc, optConfig,\n                parts = (String(config.optimize)).split('.'),\n                optimizerName = parts[0],\n                keepLines = parts[1] === 'keepLines',\n                licenseContents = '';\n\n            config = config || {};\n\n            //Apply pragmas/namespace renaming\n            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n\n            //Optimize the JS files if asked.\n            if (optimizerName && optimizerName !== 'none') {\n                ///optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n                optFunc = optimize.optimizers[optimizerName];\n                if (!optFunc) {\n                    throw new Error('optimizer with name of \"' +\n                                    optimizerName +\n                                    '\" not found for this environment');\n                }\n\n                optConfig = config[optimizerName] || {};\n                if (config.generateSourceMaps) {\n                    optConfig.generateSourceMaps = !!config.generateSourceMaps;\n                    optConfig._buildSourceMap = config._buildSourceMap;\n                }\n                ///optConfig.env = config.env;\n\n                try {\n                    if (config.preserveLicenseComments) {\n                        //Pull out any license comments for prepending after optimization.\n                        try {\n                            licenseContents = parse.getLicenseComments(fileName, fileContents);\n                        } catch (e) {\n                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n                        }\n                    }\n\n                    if (config.generateSourceMaps && licenseContents) {\n                        optConfig.preamble = licenseContents;\n                        licenseContents = '';\n                    }\n\n                    fileContents = licenseContents + optFunc(fileName,\n                                                             fileContents,\n                                                             outFileName,\n                                                             keepLines,\n                                                             optConfig,\n                                                             config.env.fs);\n                    if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n                        config._buildSourceMap = optConfig._buildSourceMap;\n                    }\n                } catch (e) {\n                    if (config.throwWhen && config.throwWhen.optimize) {\n                        throw e;\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            } else {\n                if (config._buildSourceMap) {\n                    config._buildSourceMap = null;\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * Optimizes one CSS file, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} fileName the path to the CSS file to optimize\n         * @param {String} outFileName the path to save the optimized file.\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        cssFile: function (fileName, outFileName, config) {\n            var fs = config.env.fs;\n            //Read in the file. Make sure we have a JS string.\n            var originalFileContents = fs.readFile(fileName),\n                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}, true,config),\n                //Do not use the flattened CSS if there was one that was skipped.\n                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,\n                startIndex, endIndex, buildText, comment;\n\n            if (flat.skippedList.length) {\n                logger.warn('Cannot inline @imports for ' + fileName +\n                            ',\\nthe following files had media queries in them:\\n' +\n                            flat.skippedList.join('\\n'));\n            }\n\n            //Do comment removal.\n            try {\n                if (config.optimizeCss.indexOf(\".keepComments\") === -1) {\n                    startIndex = 0;\n                    //Get rid of comments.\n                    while ((startIndex = fileContents.indexOf(\"/*\", startIndex)) !== -1) {\n                        endIndex = fileContents.indexOf(\"*/\", startIndex + 2);\n                        if (endIndex === -1) {\n                            throw \"Improper comment in CSS file: \" + fileName;\n                        }\n                        comment = fileContents.substring(startIndex, endIndex);\n\n                        if (config.preserveLicenseComments &&\n                            (comment.indexOf('license') !== -1 ||\n                             comment.indexOf('opyright') !== -1 ||\n                             comment.indexOf('(c)') !== -1)) {\n                            //Keep the comment, just increment the startIndex\n                            startIndex = endIndex;\n                        } else {\n                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);\n                            startIndex = 0;\n                        }\n                    }\n                }\n                //Get rid of newlines.\n                if (config.optimizeCss.indexOf(\".keepLines\") === -1) {\n                    fileContents = fileContents.replace(/[\\r\\n]/g, \" \");\n                    fileContents = fileContents.replace(/\\s+/g, \" \");\n                    fileContents = fileContents.replace(/\\{\\s/g, \"{\");\n                    fileContents = fileContents.replace(/\\s\\}/g, \"}\");\n                } else {\n                    //Remove multiple empty lines.\n                    fileContents = fileContents.replace(/(\\r\\n)+/g, \"\\r\\n\");\n                    fileContents = fileContents.replace(/(\\n)+/g, \"\\n\");\n                }\n                //Remove unnecessary whitespace\n                if (config.optimizeCss.indexOf(\".keepWhitespace\") === -1) {\n                    //Remove leading and trailing whitespace from lines\n                    fileContents = fileContents.replace(/^[ \\t]+/gm, \"\");\n                    fileContents = fileContents.replace(/[ \\t]+$/gm, \"\");\n                    //Remove whitespace after semicolon, colon, curly brackets and commas\n                    fileContents = fileContents.replace(/(;|:|\\{|}|,)[ \\t]+/g, \"$1\");\n                    //Remove whitespace before opening curly brackets\n                    fileContents = fileContents.replace(/[ \\t]+(\\{)/g, \"$1\");\n                    //Truncate double whitespace\n                    fileContents = fileContents.replace(/([ \\t])+/g, \"$1\");\n                    //Remove empty lines\n                    fileContents = fileContents.replace(/^[ \\t]*[\\r\\n]/gm,'');\n                }\n            } catch (e) {\n                fileContents = originalFileContents;\n                logger.error(\"Could not optimized CSS file: \" + fileName + \", error: \" + e);\n            }\n\n            fs.saveUtf8File(outFileName, fileContents);\n\n            //text output to stdout and/or written to build.txt file\n            buildText = \"\\n\"+ outFileName.replace(config.dir, \"\") +\"\\n----------------\\n\";\n            flat.importList.push(fileName);\n            buildText += flat.importList.map(function(path){\n                return path.replace(config.dir, \"\");\n            }).join(\"\\n\");\n\n            return {\n                importList: flat.importList,\n                buildText: buildText +\"\\n\"\n            };\n        },\n\n        /**\n         * Optimizes CSS files, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} startDir the path to the top level directory\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        css: function (startDir, config) {\n            var buildText = \"\",\n                importList = [],\n                shouldRemove = config.dir && config.removeCombined,\n                i, fileName, result, fileList,\n                fs = config.env.fs;\n\n            if (config.optimizeCss.indexOf(\"standard\") !== -1) {\n                fileList = fs.getFilteredFileList(startDir, /\\.css$/, true);\n                if (fileList) {\n                    for (i = 0; i < fileList.length; i++) {\n                        fileName = fileList[i];\n                        logger.trace(\"Optimizing (\" + config.optimizeCss + \") CSS file: \" + fileName);\n                        result = optimize.cssFile(fileName, fileName, config);\n                        buildText += result.buildText;\n                        if (shouldRemove) {\n                            result.importList.pop();\n                            importList = importList.concat(result.importList);\n                        }\n                    }\n                }\n\n                if (shouldRemove) {\n                    importList.forEach(function (path) {\n                        if (fs.exists(path)) {\n                            fs.deleteFile(path);\n                        }\n                    });\n                }\n            }\n            return buildText;\n        },\n\n        optimizers: {\n            uglify: function (fileName, fileContents, outFileName, keepLines, config,fs) {\n                var result, existingMap, resultMap, finalMap, sourceIndex,\n                    uconfig = {},\n                    existingMapPath = outFileName + '.map',\n                    baseName = fileName && fileName.split('/').pop();\n\n                config = config || {};\n\n                lang.mixin(uconfig, config, true);\n\n                ///uconfig.fromString = true;  // uglify 2 -> 3\n\n                if (config.preamble) {\n                    uconfig.output = {preamble: config.preamble};\n                }\n\n                ///var fs = config.env.fs;\n\n                if (config.generateSourceMaps && (outFileName || config._buildSourceMap)) {\n                    uconfig.outSourceMap = baseName + '.map';\n\n                    if (config._buildSourceMap) {\n                        existingMap = JSON.parse(config._buildSourceMap);\n                        uconfig.inSourceMap = existingMap;\n                    } else if (fs.exists(existingMapPath)) {\n                        uconfig.inSourceMap = existingMapPath;\n                        existingMap = JSON.parse(fs.readFile(existingMapPath));\n                    }\n                }\n\n                logger.trace(\"Uglify file: \" + fileName);\n\n                try {\n                    //var tempContents = fileContents.replace(/\\/\\/\\# sourceMappingURL=.*$/, '');\n                    result = uglify.minify(fileContents, uconfig, baseName + '.src.js');\n                    if (uconfig.outSourceMap && result.map) {\n                        resultMap = result.map;\n                        if (!existingMap && !config._buildSourceMap) {\n                            fs.saveFile(outFileName + '.src.js', fileContents);\n                        }\n\n                        fileContents = result.code;\n\n                        if (config._buildSourceMap) {\n                            config._buildSourceMap = resultMap;\n                        } else {\n                            fs.saveFile(outFileName + '.map', resultMap);\n                        }\n                    } else {\n                        fileContents = result.code;\n                    }\n                } catch (e) {\n                    var errorString = e.toString();\n                    var isSyntaxError = /SyntaxError/.test(errorString);\n                    throw new Error('Cannot uglify file: ' + fileName +\n                                    '. Skipping it. Error is:\\n' + errorString +\n                                  (isSyntaxError ? '\\n\\n' + es5PlusGuidance : ''));\n                }\n                return fileContents;\n            }\n        }\n    };\n\n    return optimize;\n});\n"]}