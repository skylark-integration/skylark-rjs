{"version":3,"sources":["transform.js"],"names":["define","esprima","parse","logger","lang","transform","baseIndentRegExp","indentRegExp","keyRegExp","bulkIndentRegExps","\n","\r\n","toTransport","namespace","moduleName","path","contents","onFound","options","applySourceUrl","useSourceUrl","jsEscape","indexOf","astRoot","contentLines","modLine","foundAnon","scanCount","scanReset","defineInfos","loc","e","trace","toString","traverse","node","args","firstArgLoc","factoryNode","needsId","depAction","range","namespaceExists","type","id","name","init","callee","arguments","length","value","object","property","isDefineNodeWithArgs","firstArg","isFnExpression","operator","argument","foundId","defineLoc","sourceUrlData","push","reverse","split","contentInsertion","startIndex","start","column","lineIndex","line","substring","forEach","info","deps","depString","getAnonDepsFromNode","map","dep","join","modifyConfig","fileContents","onConfig","details","findConfig","config","serializeConfig","quote","end","indent","baseIndent","startString","existingConfigString","lineReturn","lastReturnIndex","lastIndexOf","match","exec","outDentRegExp","RegExp","configString","objectToString","replace","obj","totalIndent","startBrace","endBrace","first","nextIndent","undefined","isArray","each","item","i","isFunction","isRegExp","eachProp","v","prop","test"],"mappings":"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","file":"../transform.js","sourcesContent":["/*global define */\n\ndefine([ \n    './esprima', \n    './parse', \n    './logger', \n    './lang'\n],\nfunction (esprima, parse, logger, lang) {\n    'use strict';\n    var transform,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                logger.trace('toTransport skipping ' + path + ': ' +\n                             e.toString());\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            logger.trace(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n"]}