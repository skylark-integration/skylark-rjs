{"version":3,"sources":["requirePatch.js"],"names":["define","pragma","parse","lang","logger","commonJs","prim","allowRun","hasProp","falseProp","getOwn","useStrictRegExp","absoluteUrlRegExp","hideResolutionConflict","config","fs","layer","pluginBuilderRegExp","oldNewContext","oldDef","exports","module","normalizeUrlWithBase","context","moduleName","url","require","jsExtRegExp","test","dir","dirBaseUrl","env","s","newContext","_cacheReset","_cachedRawText","_cachedFileContents","_cachedDefinesRequireUrls","_isSupportedBuildUrl","indexOf","ignoredUrls","info","name","oldEnable","enable","moduleProto","Module","prototype","oldInit","init","oldCallPlugin","callPlugin","nextTick","fn","needFullExec","fullExec","plugins","buildShimExports","makeShimExports","value","wrapShim","str","toString","replace","depMap","parent","id","parentId","map","mod","registry","defined","undef","apply","arguments","load","contents","pluginBuilderMatch","builderName","shim","shimExports","urlFetched","buildPathMap","buildFileToModule","start","_cacheReadAsync","undefined","then","text","cjsTranslate","convert","onBuildRead","process","existingRequireUrl","definesRequire","e1","Error","exec","makeModuleMap","nameToUrl","insertNeedsDefine","has","findNestedDependencies","e2","eval","completeLoad","e","moduleTree","push","eOuter","fileName","end","execCb","cb","args","__requireJsBuild","depMaps","this","each","bind","isDefine","parentMap","pluginMap","prefix","pluginId","pluginMod","contexts","_","_buildReset","oldContext","_layer","buildFilePaths","pathAdded","modulesWithNames","needsDefine","amd","_readFile","readFile","_fileExists","path","exists","onResourceLoad","eachProp","prop","unnormalized","originalName"],"mappings":"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","file":"../requirePatch.js","sourcesContent":["/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine([ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n"]}