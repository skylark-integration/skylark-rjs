{"version":3,"sources":["skylark-rjs.js"],"names":["define","skylark","require","attach","lang","isJavaObj","hasOwn","Object","prototype","hasOwnProperty","hasProp","obj","prop","call","java","importPackage","backSlashRegExp","ostring","toString","isArray","Array","it","isFunction","isRegExp","RegExp","falseProp","getOwn","_mixin","dest","source","override","name","mixin","i","l","parameters","slice","arguments","length","pop","deepMix","eachProp","value","deeplikeCopy","ignoredProps","type","result","forEach","push","undefined","key","delegate","TMP","props","tmp","each","ary","func","bind","fn","apply","jsEscape","content","replace","op","check","p","prim","hideResolutionConflict","Error","JSON","stringify","notify","nextTick","item","ok","fail","callback","yes","no","errback","v","e","finished","rejected","resolve","reject","start","promise","then","next","err","e2","end","serial","setImmediate","process","setTimeout","logger","TRACE","INFO","WARN","ERROR","SILENT","level","logPrefix","logLevel","this","trace","message","_print","info","warn","error","_sysPrint","msg","console","log","esprima","arrayToString","output","argPropName","emptyScope","traverse","object","visitor","child","keys","traverseBroad","getValidDeps","node","elements","deps","some","elem","isFnExpression","parse","moduleName","fileName","fileContents","options","moduleCall","depString","moduleDeps","moduleList","needsDefine","astRoot","recurse","callName","config","factoryIdentifier","fnExpScope","concat","findNestedDependencies","insertNeedsDefine","onMatch","params","param","tempObject","hasHas","has","test","consequent","alternate","parseNode","expression","callee","argument","definesRequire","foundDefine","foundDefineAmd","body","bodyNode","decls","declarations","hasVarDefine","declNode","id","hasDefineAmd","getAnonDeps","defFunc","findAnonDefineFactory","getAnonDepsFromNode","funcArgLength","findRequireDepNames","isDefineNodeWithArgs","match","arg0","arg1","findConfig","jsConfig","foundConfig","stringData","foundRange","quote","quoteMatch","quoteRegExp","loc","arg","requireType","hasRequire","getRequireObjectLiteral","nodeToString","range","exec","eval","init","renameNamespace","ns","lines","locs","split","reverse","startIndex","column","lineIndex","line","substring","join","findDependencies","dependencies","findCjsDependencies","hasDefDefine","left","property","refsDefineAmd","c","hasDefine","getNamedDefine","getAllNamedDefines","excludeMap","names","usesAmdOrRequireJs","uses","usesCommonJs","assignsExports","exp","cjsDeps","factory","refsDefine","args","isUmd","contents","extracted","firstLine","preamble","getLicenseComments","commentNode","refNode","subNode","j","ast","comment","existsMap","lineEnd","indexOf","comments","Temp","create","temp","pragma","conditionalRegExp","useStrictRegExp","hasRegExp","configRegExp","nsWrapRegExp","apiDefRegExp","defineCheckRegExp","defineStringCheckRegExp","defineTypeFirstCheckRegExp","defineJQueryRegExp","defineHasRegExp","defineTernaryRegExp","defineExistsRegExp","defineExistsAndAmdRegExp","amdefineRegExp","removeStrict","useStrict","namespace","onLifecycleName","pluginCollector","foundIndex","lineEndIndex","conditionLine","matches","marker","condition","isTrue","endRegExp","endMatches","endMarkerIndex","shouldInclude","startLength","lifecycleHas","dep","collectorMod","lifecyclePragmas","pragmas","hasConfig","kwArgs","skipPragmas","lastIndex","optimizeAllPluginResources","eDep","keepAmdefine","uglifyjs","sourcemap","uglify","sourceMap","optimize","cssImportRegExp","cssCommentImportRegExp","cssUrlRegExp","protocolRegExp","SourceMapGenerator","SourceMapConsumer","cleanCssUrlQuotes","url","charAt","fixCssUrlPaths","path","cssPrefix","fullMatch","urlMatch","firstChar","hasProtocol","parts","fixedUrlMatch","splice","jsFile","outFileName","fs","env","readFile","js","saveUtf8File","optFunc","optConfig","String","optimizerName","keepLines","licenseContents","optimizers","generateSourceMaps","_buildSourceMap","preserveLicenseComments","throwWhen","cssFile","endIndex","buildText","originalFileContents","flat","flattenCss","cssImportIgnore","included","topLevel","lastIndexOf","filePath","importList","skippedList","urlStart","importFileName","urlEnd","mediaTypes","importEndIndex","importPath","fullImportFileName","importContents","optimizeCss","dir","map","css","startDir","fileList","shouldRemove","removeCombined","getFilteredFileList","exists","deleteFile","existingMap","resultMap","uconfig","existingMapPath","baseName","outSourceMap","inSourceMap","minify","saveFile","code","errorString","isSyntaxError","transform","baseIndentRegExp","indentRegExp","keyRegExp","bulkIndentRegExps","\n","\r\n","toTransport","onFound","contentLines","modLine","foundAnon","scanCount","scanReset","defineInfos","applySourceUrl","useSourceUrl","firstArg","firstArgLoc","factoryNode","needsId","depAction","namespaceExists","operator","foundId","defineLoc","sourceUrlData","contentInsertion","modifyConfig","onConfig","details","serializeConfig","indent","configString","outDentRegExp","baseIndent","startString","existingConfigString","lineReturn","lastReturnIndex","str","regExp","applyIndent","objectToString","totalIndent","startBrace","endBrace","nextIndent","first","commonJs","useLog","convertDir","commonJsPath","savePath","convertedFileName","jsFileRegExp","convert","copyFile","commonJsProps","dirname","filename","allowRun","absoluteUrlRegExp","layer","pluginBuilderRegExp","oldNewContext","s","newContext","oldDef","exports","module","_cacheReset","_cachedRawText","_cachedFileContents","_cachedDefinesRequireUrls","_isSupportedBuildUrl","ignoredUrls","context","oldEnable","enable","moduleProto","Module","oldInit","oldCallPlugin","callPlugin","needFullExec","fullExec","plugins","buildShimExports","makeShimExports","wrapShim","depMap","parent","parentId","mod","registry","defined","undef","load","pluginBuilderMatch","builderName","shim","shimExports","urlFetched","normalizeUrlWithBase","buildPathMap","buildFileToModule","_cacheReadAsync","text","cjsTranslate","onBuildRead","existingRequireUrl","e1","makeModuleMap","nameToUrl","completeLoad","moduleTree","eOuter","execCb","cb","__requireJsBuild","depMaps","isDefine","parentMap","pluginMap","prefix","pluginId","pluginMod","contexts","_","_buildReset","oldContext","_layer","buildFilePaths","pathAdded","modulesWithNames","amd","_readFile","_fileExists","onResourceLoad","unnormalized","originalName","jsExtRegExp","dirBaseUrl","requirePatch","build","endsWithSemiColonRegExp","endsWithSlashRegExp","resourceIsModuleIdRegExp","deepCopyProps","copyConfig","makeBuildBaseConfig","appDir","paths","inlineText","isBuild","writeBuildTxt","waitSeconds","dirExclusionRegExp","_buildPathToModuleIndex","addSemiColon","skipSemiColonInsertion","endsWithSlash","dirName","endsWithNewLine","makeWriteFile","writeFile","file","asModule","appendToFileContents","singleContents","sourceMapGenerator","refPath","sourceMapPath","resourcePath","sourceMapLineNumber","lineCount","out","baseUrl","_buildPath","makeRelativeFilePath","shift","toUrl","addMapping","generated","original","setSourceContent","stringDotToObj","mixConfig","target","skipArrays","targetValue","flattenWrapFile","keyName","absFilePath","wrap","keyFileName","keyMapName","absPath","makeAbsPath","fileText","cfg","normalizeWrapConfig","__startMap","__endMap","wrapError","encoding","d","readFileAsync","buildFile","cmdConfig","errorMsg","errorStack","stackMatch","errorTree","errorMod","stackRegExp","convertArrayToObject","_run","index","stack","originalError","buildPaths","baseConfig","modules","srcPath","buildContext","destPath","moduleMap","parentModuleMap","resources","resource","plugin","pluginProcessed","buildFileContents","createConfig","keepBuildDir","cssIn","copyDir","isDirectory","packagePaths","packages","_sourcePath","rawText","allowSourceOverwrites","actions","normalize","traceDependencies","exclude","excludeLayers","found","findBuildModule","excludeModule","excludeLayer","removeModulePath","excludeShallow","excludeShallowModule","flattenModule","builtModule","finalText","_buildText","outOrigSourceMap","bundlesConfig","bundlesConfigOutFile","entryConfig","finalPath","renameFile","bundleContents","parsedIds","isLayer","relPath","onModuleBundleComplete","onCompleteData","bundles","deleteEmptyDirs","include","moduleIndex","skipDirOptimize","normalizeDirDefines","onBuildWrite","createOverrideConfig","objProps","pragmasOnSave","hasOnSave","uglify2","closure","hasDotPropMatch","dotProp","needArray","insertRequire","stubModules","mainConfigFile","wrap.startFile","wrap.endFile","separatorI","ndex","separatorIndex","makeAbsObject","makeAbsConfig","originalBaseUrl","targetPath","dotLength","finalParts","targetParts","targetName","refParts","hasEndSlash","dotParts","nestedMix","buildFileConfig","mainConfig","mainConfigPath","buildBaseConfig","trim","configFile","configError","main","_byName","fileExclusionRegExp","exclusionRegExp","_depsInclude","jQuery","enforceDefine","urlArgs","baseLoaderConfig","rawTextByIds","syncChecks","rhino","xpconnect","deferred","includeFinished","hasError","checkForErrors","idParts","pluginResources","errMessage","failedPluginMap","failedPluginIds","errIds","errUrlMap","errUrlConflicts","hasErrUrl","hasUndefined","populateErrUrlMap","errUrl","skipNew","enabled","oride","sourceMapBase","reqIndex","currContents","fileForSourceMap","packageName","builder","writeApi","namespaceWithDot","stubModulesByName","onLayerEnds","onLayerEndAdded","pkgsMainMap","unshift","pkgs","wrapFunction","onLayerEnd","write","input","hasPackageName","shimDeps","shortPath","skipModuleInsertion","makeJsArrayString","exportsFn","toJSON","rjs","createRjsApi"],"mappings":"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","file":"../skylark-rjs.js","sourcesContent":["define('skylark-rjs/rjs',[\r\n    \"skylark-langx-ns\",\r\n],function(skylark){\r\n    require.define = define;\r\n\r\n\treturn skylark.attach(\"intg.rjs\",require);\r\n});\n/*jslint plusplus: true */\n/*global define, java */\n\ndefine('skylark-rjs/lang',[],function () {\n    'use strict';\n\n    var lang, isJavaObj,\n        hasOwn = Object.prototype.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    isJavaObj = function () {\n        return false;\n    };\n\n    //Rhino, but not Nashorn (detected by importPackage not existing)\n    //Can have some strange foreign objects.\n    if (typeof java !== 'undefined' && java.lang && java.lang.Object && typeof importPackage !== 'undefined') {\n        isJavaObj = function (obj) {\n            return obj instanceof java.lang.Object;\n        };\n    }\n\n    lang = {\n        backSlashRegExp: /\\\\/g,\n        ostring: Object.prototype.toString,\n\n        isArray: Array.isArray || function (it) {\n            return lang.ostring.call(it) === \"[object Array]\";\n        },\n\n        isFunction: function(it) {\n            return lang.ostring.call(it) === \"[object Function]\";\n        },\n\n        isRegExp: function(it) {\n            return it && it instanceof RegExp;\n        },\n\n        hasProp: hasProp,\n\n        //returns true if the object does not have an own property prop,\n        //or if it does, it is a falsy value.\n        falseProp: function (obj, prop) {\n            return !hasProp(obj, prop) || !obj[prop];\n        },\n\n        //gets own property value for given prop on object\n        getOwn: function (obj, prop) {\n            return hasProp(obj, prop) && obj[prop];\n        },\n\n        _mixin: function(dest, source, override){\n            var name;\n            for (name in source) {\n                if(source.hasOwnProperty(name) &&\n                    (override || !dest.hasOwnProperty(name))) {\n                    dest[name] = source[name];\n                }\n            }\n\n            return dest; // Object\n        },\n\n        /**\n         * mixin({}, obj1, obj2) is allowed. If the last argument is a boolean,\n         * then the source objects properties are force copied over to dest.\n         */\n        mixin: function(dest){\n            var parameters = Array.prototype.slice.call(arguments),\n                override, i, l;\n\n            if (!dest) { dest = {}; }\n\n            if (parameters.length > 2 && typeof arguments[parameters.length-1] === 'boolean') {\n                override = parameters.pop();\n            }\n\n            for (i = 1, l = parameters.length; i < l; i++) {\n                lang._mixin(dest, parameters[i], override);\n            }\n            return dest; // Object\n        },\n\n        /**\n         * Does a deep mix of source into dest, where source values override\n         * dest values if a winner is needed.\n         * @param  {Object} dest destination object that receives the mixed\n         * values.\n         * @param  {Object} source source object contributing properties to mix\n         * in.\n         * @return {[Object]} returns dest object with the modification.\n         */\n        deepMix: function(dest, source) {\n            lang.eachProp(source, function (value, prop) {\n                if (typeof value === 'object' && value &&\n                    !lang.isArray(value) && !lang.isFunction(value) &&\n                    !(value instanceof RegExp)) {\n\n                    if (!dest[prop]) {\n                        dest[prop] = {};\n                    }\n                    lang.deepMix(dest[prop], value);\n                } else {\n                    dest[prop] = value;\n                }\n            });\n            return dest;\n        },\n\n        /**\n         * Does a type of deep copy. Do not give it anything fancy, best\n         * for basic object copies of objects that also work well as\n         * JSON-serialized things, or has properties pointing to functions.\n         * For non-array/object values, just returns the same object.\n         * @param  {Object} obj      copy properties from this object\n         * @param  {Object} [ignoredProps] optional object whose own properties\n         * are keys that should be ignored.\n         * @return {Object}\n         */\n        deeplikeCopy: function (obj, ignoredProps) {\n            var type, result;\n\n            if (lang.isArray(obj)) {\n                result = [];\n                obj.forEach(function(value) {\n                    result.push(lang.deeplikeCopy(value, ignoredProps));\n                });\n                return result;\n            }\n\n            type = typeof obj;\n            if (obj === null || obj === undefined || type === 'boolean' ||\n                type === 'string' || type === 'number' || lang.isFunction(obj) ||\n                lang.isRegExp(obj)|| isJavaObj(obj)) {\n                return obj;\n            }\n\n            //Anything else is an object, hopefully.\n            result = {};\n            lang.eachProp(obj, function(value, key) {\n                if (!ignoredProps || !hasProp(ignoredProps, key)) {\n                    result[key] = lang.deeplikeCopy(value, ignoredProps);\n                }\n            });\n            return result;\n        },\n\n        delegate: (function () {\n            // boodman/crockford delegation w/ cornford optimization\n            function TMP() {}\n            return function (obj, props) {\n                TMP.prototype = obj;\n                var tmp = new TMP();\n                TMP.prototype = null;\n                if (props) {\n                    lang.mixin(tmp, props);\n                }\n                return tmp; // Object\n            };\n        }()),\n\n        /**\n         * Helper function for iterating over an array. If the func returns\n         * a true value, it will break out of the loop.\n         */\n        each: function each(ary, func) {\n            if (ary) {\n                var i;\n                for (i = 0; i < ary.length; i += 1) {\n                    if (func(ary[i], i, ary)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Cycles over properties in an object and calls a function for each\n         * property value. If the function returns a truthy value, then the\n         * iteration is stopped.\n         */\n        eachProp: function eachProp(obj, func) {\n            var prop;\n            for (prop in obj) {\n                if (hasProp(obj, prop)) {\n                    if (func(obj[prop], prop)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        //Similar to Function.prototype.bind, but the \"this\" object is specified\n        //first, since it is easier to read/figure out what \"this\" will be.\n        bind: function bind(obj, fn) {\n            return function () {\n                return fn.apply(obj, arguments);\n            };\n        },\n\n        //Escapes a content string to be be a string that has characters escaped\n        //for inclusion as part of a JS string.\n        jsEscape: function (content) {\n            return content.replace(/([\"'\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\");\n        }\n    };\n    return lang;\n});\n\n/**\n * prim 0.0.1 Copyright (c) 2012-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/prim for details\n */\n\n/*global setImmediate, process, setTimeout, define, module */\n\n//Set prime.hideResolutionConflict = true to allow \"resolution-races\"\n//in promise-tests to pass.\n//Since the goal of prim is to be a small impl for trusted code, it is\n//more important to normally throw in this case so that we can find\n//logic errors quicker.\n\ndefine('skylark-rjs/prim',[],function () {\n    'use strict';\n    var op = Object.prototype,\n        hasOwn = op.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i]) {\n                    func(ary[i], i, ary);\n                }\n            }\n        }\n    }\n\n    function check(p) {\n        if (hasProp(p, 'e') || hasProp(p, 'v')) {\n            if (!prim.hideResolutionConflict) {\n                throw new Error('Prim promise already resolved: ' +\n                                JSON.stringify(p));\n            }\n            return false;\n        }\n        return true;\n    }\n\n    function notify(ary, value) {\n        prim.nextTick(function () {\n            each(ary, function (item) {\n                item(value);\n            });\n        });\n    }\n\n    function prim() {\n        var p,\n            ok = [],\n            fail = [];\n\n        return (p = {\n            callback: function (yes, no) {\n                if (no) {\n                    p.errback(no);\n                }\n\n                if (hasProp(p, 'v')) {\n                    prim.nextTick(function () {\n                        yes(p.v);\n                    });\n                } else {\n                    ok.push(yes);\n                }\n            },\n\n            errback: function (no) {\n                if (hasProp(p, 'e')) {\n                    prim.nextTick(function () {\n                        no(p.e);\n                    });\n                } else {\n                    fail.push(no);\n                }\n            },\n\n            finished: function () {\n                return hasProp(p, 'e') || hasProp(p, 'v');\n            },\n\n            rejected: function () {\n                return hasProp(p, 'e');\n            },\n\n            resolve: function (v) {\n                if (check(p)) {\n                    p.v = v;\n                    notify(ok, v);\n                }\n                return p;\n            },\n            reject: function (e) {\n                if (check(p)) {\n                    p.e = e;\n                    notify(fail, e);\n                }\n                return p;\n            },\n\n            start: function (fn) {\n                p.resolve();\n                return p.promise.then(fn);\n            },\n\n            promise: {\n                then: function (yes, no) {\n                    var next = prim();\n\n                    p.callback(function (v) {\n                        try {\n                            if (yes && typeof yes === 'function') {\n                                v = yes(v);\n                            }\n\n                            if (v && v.then) {\n                                v.then(next.resolve, next.reject);\n                            } else {\n                                next.resolve(v);\n                            }\n                        } catch (e) {\n                            next.reject(e);\n                        }\n                    }, function (e) {\n                        var err;\n\n                        try {\n                            if (!no || typeof no !== 'function') {\n                                next.reject(e);\n                            } else {\n                                err = no(e);\n\n                                if (err && err.then) {\n                                    err.then(next.resolve, next.reject);\n                                } else {\n                                    next.resolve(err);\n                                }\n                            }\n                        } catch (e2) {\n                            next.reject(e2);\n                        }\n                    });\n\n                    return next.promise;\n                },\n\n                fail: function (no) {\n                    return p.promise.then(null, no);\n                },\n\n                end: function () {\n                    p.errback(function (e) {\n                        throw e;\n                    });\n                }\n            }\n        });\n    };\n\n    prim.serial = function (ary) {\n        var result = prim().resolve().promise;\n        each(ary, function (item) {\n            result = result.then(function () {\n                return item();\n            });\n        });\n        return result;\n    };\n\n    prim.nextTick = typeof setImmediate === 'function' ? setImmediate :\n        (typeof process !== 'undefined' && process.nextTick ?\n            process.nextTick : (typeof setTimeout !== 'undefined' ?\n                function (fn) {\n                setTimeout(fn, 0);\n            } : function (fn) {\n        fn();\n    }));\n\n    return prim;\n});\n/*jslint nomen: false, strict: false */\n/*global define: false */\n\ndefine('skylark-rjs/logger',[],function () {\n    function print(msg,e) {\n        console.log(msg,e);\n    }\n\n    var logger = {\n        TRACE: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        SILENT: 4,\n        level: 0,\n        logPrefix: \"\",\n\n        logLevel: function( level ) {\n            this.level = level;\n        },\n\n        trace: function (message) {\n            if (this.level <= this.TRACE) {\n                this._print(message);\n            }\n        },\n\n        info: function (message) {\n            if (this.level <= this.INFO) {\n                this._print(message);\n            }\n        },\n\n        warn: function (message) {\n            if (this.level <= this.WARN) {\n                this._print(message);\n            }\n        },\n\n        error: function (message) {\n            if (this.level <= this.ERROR) {\n                this._print(message);\n            }\n        },\n\n        _print: function (message) {\n            this._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n        },\n\n        _sysPrint: function (message) {\n            print(message);\n        }\n    };\n\n    return logger;\n});\n\n/*global define, Reflect */\n\n/*\n * xpcshell has a smaller stack on linux and windows (1MB vs 9MB on mac),\n * and the recursive nature of esprima can cause it to overflow pretty\n * quickly. So favor it built in Reflect parser:\n * https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n */\ndefine('skylark-rjs/esprima',['skylark-espree'], function (esprima) {\n    return esprima;\n});\n\n/*jslint plusplus: true */\n/*global define: false */\n\ndefine('skylark-rjs/parse',[\n    './esprima', \n    './lang'\n], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n\n/*jslint regexp: true, plusplus: true  */\n/*global define: false */\n\ndefine('skylark-rjs/pragma',[\n    './parse', \n    './logger'\n], function (parse, logger) {\n    'use strict';\n    function Temp() {}\n\n    function create(obj, mixin) {\n        Temp.prototype = obj;\n        var temp = new Temp(), prop;\n\n        //Avoid any extra memory hanging around\n        Temp.prototype = null;\n\n        if (mixin) {\n            for (prop in mixin) {\n                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {\n                    temp[prop] = mixin[prop];\n                }\n            }\n        }\n\n        return temp; // Object\n    }\n\n    var pragma = {\n        conditionalRegExp: /(exclude|include)Start\\s*\\(\\s*[\"'](\\w+)[\"']\\s*,(.*)\\)/,\n        useStrictRegExp: /(^|[^{]\\r?\\n)['\"]use strict['\"];/g,\n        hasRegExp: /has\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n        configRegExp: /(^|[^\\.])(requirejs|require)(\\.config)\\s*\\(/g,\n        nsWrapRegExp: /\\/\\*requirejs namespace: true \\*\\//,\n        apiDefRegExp: /var requirejs,\\s*require,\\s*define;/,\n        defineCheckRegExp: /typeof(\\s+|\\s*\\(\\s*)define(\\s*\\))?\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineStringCheckRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\[\\s*[\"']amd[\"']\\s*\\]/g,\n        defineTypeFirstCheckRegExp: /\\s*[\"']function[\"']\\s*==(=?)\\s*typeof\\s+define\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineJQueryRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\.\\s*jQuery/g,\n        defineHasRegExp: /typeof\\s+define\\s*==(=)?\\s*['\"]function['\"]\\s*&&\\s*typeof\\s+define\\.amd\\s*==(=)?\\s*['\"]object['\"]\\s*&&\\s*define\\.amd/g,\n        defineTernaryRegExp: /typeof\\s+define\\s*===?\\s*['\"]function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\?\\s*define/,\n        defineExistsRegExp: /\\s+typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*/,\n        defineExistsAndAmdRegExp: /typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*/,\n        amdefineRegExp: /if\\s*\\(\\s*typeof define\\s*\\!==\\s*['\"]function['\"]\\s*\\)\\s*\\{\\s*[^\\{\\}]+amdefine[^\\{\\}]+\\}/g,\n\n        removeStrict: function (contents, config) {\n            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '$1');\n        },\n\n        namespace: function (fileContents, ns, onLifecycleName) {\n            if (ns) {\n                //Namespace require/define calls\n                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');\n\n\n                fileContents = parse.renameNamespace(fileContents, ns);\n\n                //Namespace define ternary use:\n                fileContents = fileContents.replace(pragma.defineTernaryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd ? \" + ns + \".define\");\n\n                //Namespace define jquery use:\n                fileContents = fileContents.replace(pragma.defineJQueryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd && \" + ns + \".define.amd.jQuery\");\n\n                //Namespace has.js define use:\n                fileContents = fileContents.replace(pragma.defineHasRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && typeof \" + ns + \".define.amd === 'object' && \" + ns + \".define.amd\");\n\n                //Namespace async.js define use:\n                fileContents = fileContents.replace(pragma.defineExistsAndAmdRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined' && \" + ns + \".define.amd\");\n\n                //Namespace define checks.\n                //Do these ones last, since they are a subset of the more specific\n                //checks above.\n                fileContents = fileContents.replace(pragma.defineCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define['amd']\");\n                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,\n                                                    \"'function' === typeof \" + ns + \".define && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineExistsRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined'\");\n\n                //Check for require.js with the require/define definitions\n                if (pragma.apiDefRegExp.test(fileContents) &&\n                    fileContents.indexOf(\"if (!\" + ns + \" || !\" + ns + \".requirejs)\") === -1) {\n                    //Wrap the file contents in a typeof check, and a function\n                    //to contain the API globals.\n                    fileContents = \"var \" + ns + \";(function () { if (!\" + ns + \" || !\" + ns + \".requirejs) {\\n\" +\n                                    \"if (!\" + ns + \") { \" + ns + ' = {}; } else { require = ' + ns + '; }\\n' +\n                                    fileContents +\n                                    \"\\n\" +\n                                    ns + \".requirejs = requirejs;\" +\n                                    ns + \".require = require;\" +\n                                    ns + \".define = define;\\n\" +\n                                    \"}\\n}());\";\n                }\n\n                //Finally, if the file wants a special wrapper because it ties\n                //in to the requirejs internals in a way that would not fit\n                //the above matches, do that. Look for /*requirejs namespace: true*/\n                if (pragma.nsWrapRegExp.test(fileContents)) {\n                    //Remove the pragma.\n                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');\n\n                    //Alter the contents.\n                    fileContents = '(function () {\\n' +\n                                   'var require = ' + ns + '.require,' +\n                                   'requirejs = ' + ns + '.requirejs,' +\n                                   'define = ' + ns + '.define;\\n' +\n                                   fileContents +\n                                   '\\n}());';\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * processes the fileContents for some //>> conditional statements\n         */\n        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {\n            /*jslint evil: true */\n            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,\n                matches, type, marker, condition, isTrue, endRegExp, endMatches,\n                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,\n                i, dep, moduleName, collectorMod,\n                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,\n                //Legacy arg defined to help in dojo conversion script. Remove later\n                //when dojo no longer needs conversion:\n                kwArgs = pragmas;\n\n            //Mix in a specific lifecycle scoped object, to allow targeting\n            //some pragmas/has tests to only when files are saved, or at different\n            //lifecycle events. Do not bother with kwArgs in this section, since\n            //the old dojo kwArgs were for all points in the build lifecycle.\n            if (onLifecycleName) {\n                lifecyclePragmas = config['pragmas' + onLifecycleName];\n                lifecycleHas = config['has' + onLifecycleName];\n\n                if (lifecyclePragmas) {\n                    pragmas = create(pragmas || {}, lifecyclePragmas);\n                }\n\n                if (lifecycleHas) {\n                    hasConfig = create(hasConfig || {}, lifecycleHas);\n                }\n            }\n\n            //Replace has references if desired\n            if (hasConfig) {\n                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {\n                    if (hasConfig.hasOwnProperty(test)) {\n                        return !!hasConfig[test];\n                    }\n                    return match;\n                });\n            }\n\n            if (!config.skipPragmas) {\n\n                while ((foundIndex = fileContents.indexOf(\"//>>\", startIndex)) !== -1) {\n                    //Found a conditional. Get the conditional line.\n                    lineEndIndex = fileContents.indexOf(\"\\n\", foundIndex);\n                    if (lineEndIndex === -1) {\n                        lineEndIndex = fileContents.length - 1;\n                    }\n\n                    //Increment startIndex past the line so the next conditional search can be done.\n                    startIndex = lineEndIndex + 1;\n\n                    //Break apart the conditional.\n                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);\n                    matches = conditionLine.match(pragma.conditionalRegExp);\n                    if (matches) {\n                        type = matches[1];\n                        marker = matches[2];\n                        condition = matches[3];\n                        isTrue = false;\n                        //See if the condition is true.\n                        try {\n                            isTrue = !!eval(\"(\" + condition + \")\");\n                        } catch (e) {\n                            throw \"Error in file: \" +\n                                   fileName +\n                                   \". Conditional comment: \" +\n                                   conditionLine +\n                                   \" failed with this error: \" + e;\n                        }\n\n                        //Find the endpoint marker.\n                        endRegExp = new RegExp('\\\\/\\\\/\\\\>\\\\>\\\\s*' + type + 'End\\\\(\\\\s*[\\'\"]' + marker + '[\\'\"]\\\\s*\\\\)', \"g\");\n                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));\n                        if (endMatches) {\n                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;\n\n                            //Find the next line return based on the match position.\n                            lineEndIndex = fileContents.indexOf(\"\\n\", endMarkerIndex);\n                            if (lineEndIndex === -1) {\n                                lineEndIndex = fileContents.length - 1;\n                            }\n\n                            //Should we include the segment?\n                            shouldInclude = ((type === \"exclude\" && !isTrue) || (type === \"include\" && isTrue));\n\n                            //Remove the conditional comments, and optionally remove the content inside\n                            //the conditional comments.\n                            startLength = startIndex - foundIndex;\n                            fileContents = fileContents.substring(0, foundIndex) +\n                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : \"\") +\n                                fileContents.substring(lineEndIndex + 1, fileContents.length);\n\n                            //Move startIndex to foundIndex, since that is the new position in the file\n                            //where we need to look for more conditionals in the next while loop pass.\n                            startIndex = foundIndex;\n                        } else {\n                            throw \"Error in file: \" +\n                                  fileName +\n                                  \". Cannot find end marker for conditional comment: \" +\n                                  conditionLine;\n\n                        }\n                    }\n                }\n            }\n\n            //If need to find all plugin resources to optimize, do that now,\n            //before namespacing, since the namespacing will change the API\n            //names.\n            //If there is a plugin collector, scan the file for plugin resources.\n            if (config.optimizeAllPluginResources && pluginCollector) {\n                try {\n                    deps = parse.findDependencies(fileName, fileContents);\n                    if (deps.length) {\n                        for (i = 0; i < deps.length; i++) {\n                            dep = deps[i];\n                            if (dep.indexOf('!') !== -1) {\n                                moduleName = dep.split('!')[0];\n                                collectorMod = pluginCollector[moduleName];\n                                if (!collectorMod) {\n                                 collectorMod = pluginCollector[moduleName] = [];\n                                }\n                                collectorMod.push(dep);\n                            }\n                        }\n                    }\n                } catch (eDep) {\n                    logger.error('Parse error looking for plugin resources in ' +\n                                 fileName + ', skipping.');\n                }\n            }\n\n            //Strip amdefine use for node-shared modules.\n            if (!config.keepAmdefine) {\n                fileContents = fileContents.replace(pragma.amdefineRegExp, '');\n            }\n\n            //Do namespacing\n            if (onLifecycleName === 'OnSave' && config.namespace) {\n                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);\n            }\n\n\n            return pragma.removeStrict(fileContents, config);\n        }\n    };\n\n    return pragma;\n});\n\n//Distributed under the BSD license:\n//Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\ndefine('skylark-rjs/uglifyjs',['skylark-uglifyjs'], function (uglifyjs) {\n    return uglifyjs;\n});\n\ndefine('skylark-rjs/source-map',['skylark-sourcemap'], function (sourcemap) {\n    return sourcemap;\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true */\n/*global define: false */\n\ndefine('skylark-rjs/optimize',[ \n    './lang', \n    './logger', \n///    'env!env/optimize', \n///    'env!env/file', \n    './parse',\n    './pragma', \n    './uglifyjs',\n    './source-map'\n],function (\n    lang,\n    logger,\n///     envOptimize, \n///     file, \n     parse,\n     pragma, \n     uglify,\n     sourceMap\n) {\n    'use strict';\n\n    var optimize,\n        cssImportRegExp = /\\@import\\s+(url\\()?\\s*([^);]+)\\s*(\\))?([\\w, ]*)(;)?/ig,\n        cssCommentImportRegExp = /\\/\\*[^\\*]*@import[^\\*]*\\*\\//g,\n        cssUrlRegExp = /\\url\\(\\s*([^\\)]+)\\s*\\)?/g,\n        protocolRegExp = /^\\w+:/,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        SourceMapConsumer = sourceMap.SourceMapConsumer,\n        es5PlusGuidance = 'If the source uses ES2015 or later syntax, please pass \"optimize: \\'none\\'\" to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.';\n\n    /**\n     * If an URL from a CSS url value contains start/end quotes, remove them.\n     * This is not done in the regexp, since my regexp fu is not that strong,\n     * and the CSS spec allows for ' and \" in the URL if they are backslash escaped.\n     * @param {String} url\n     */\n    function cleanCssUrlQuotes(url) {\n        //Make sure we are not ending in whitespace.\n        //Not very confident of the css regexps above that there will not be ending\n        //whitespace.\n        url = url.replace(/\\s+$/, \"\");\n\n        if (url.charAt(0) === \"'\" || url.charAt(0) === \"\\\"\") {\n            url = url.substring(1, url.length - 1);\n        }\n\n        return url;\n    }\n\n    function fixCssUrlPaths(fileName, path, contents, cssPrefix) {\n        return contents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {\n            var firstChar, hasProtocol, parts, i,\n                fixedUrlMatch = cleanCssUrlQuotes(urlMatch);\n\n            fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, \"/\");\n\n            //Only do the work for relative URLs. Skip things that start with / or #, or have\n            //a protocol.\n            firstChar = fixedUrlMatch.charAt(0);\n            hasProtocol = protocolRegExp.test(fixedUrlMatch);\n            if (firstChar !== \"/\" && firstChar !== \"#\" && !hasProtocol) {\n                //It is a relative URL, tack on the cssPrefix and path prefix\n                urlMatch = cssPrefix + path + fixedUrlMatch;\n            } else if (!hasProtocol) {\n                logger.trace(fileName + \"\\n  URL not a relative URL, skipping: \" + urlMatch);\n            }\n\n            //Collapse .. and .\n            parts = urlMatch.split(\"/\");\n            for (i = parts.length - 1; i > 0; i--) {\n                if (parts[i] === \".\") {\n                    parts.splice(i, 1);\n                } else if (parts[i] === \"..\") {\n                    if (i !== 0 && parts[i - 1] !== \"..\") {\n                        parts.splice(i - 1, 2);\n                        i -= 1;\n                    }\n                }\n            }\n\n            return \"url(\" + parts.join(\"/\") + \")\";\n        });\n    }\n\n    /**\n     * Inlines nested stylesheets that have @import calls in them.\n     * @param {String} fileName the file name\n     * @param {String} fileContents the file contents\n     * @param {String} cssImportIgnore comma delimited string of files to ignore\n     * @param {String} cssPrefix string to be prefixed before relative URLs\n     * @param {Object} included an object used to track the files already imported\n     */\n    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included, topLevel,config) {\n        //Find the last slash in the name.\n        fileName = fileName.replace(lang.backSlashRegExp, \"/\");\n        var endIndex = fileName.lastIndexOf(\"/\"),\n            //Make a file path based on the last slash.\n            //If no slash, so must be just a file name. Use empty string then.\n            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : \"\",\n            //store a list of merged files\n            importList = [],\n            skippedList = [],\n            fs = config.env.fs;\n\n        //First make a pass by removing any commented out @import calls.\n        fileContents = fileContents.replace(cssCommentImportRegExp, '');\n\n        //Make sure we have a delimited ignore list to make matching faster\n        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== \",\") {\n            cssImportIgnore += \",\";\n        }\n\n        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {\n            //Only process media type \"all\" or empty media type rules.\n            if (mediaTypes && ((mediaTypes.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')) !== \"all\")) {\n                skippedList.push(fileName);\n                return fullMatch;\n            }\n\n            importFileName = cleanCssUrlQuotes(importFileName);\n\n            //Ignore the file import if it is part of an ignore list.\n            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + \",\") !== -1) {\n                return fullMatch;\n            }\n\n            //Make sure we have a unix path for the rest of the operation.\n            importFileName = importFileName.replace(lang.backSlashRegExp, \"/\");\n\n            try {\n                //if a relative path, then tack on the filePath.\n                //If it is not a relative path, then the readFile below will fail,\n                //and we will just skip that import.\n                var fullImportFileName = importFileName.charAt(0) === \"/\" ? importFileName : filePath + importFileName,\n                    importContents = fs.readFile(fullImportFileName),\n                    importEndIndex, importPath, flat;\n\n                //Skip the file if it has already been included.\n                if (included[fullImportFileName]) {\n                    return '';\n                }\n                included[fullImportFileName] = true;\n\n                //Make sure to flatten any nested imports.\n                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included,false,config);\n                importContents = flat.fileContents;\n\n                if (flat.importList.length) {\n                    importList.push.apply(importList, flat.importList);\n                }\n                if (flat.skippedList.length) {\n                    skippedList.push.apply(skippedList, flat.skippedList);\n                }\n\n                //Make the full import path\n                importEndIndex = importFileName.lastIndexOf(\"/\");\n\n                //Make a file path based on the last slash.\n                //If no slash, so must be just a file name. Use empty string then.\n                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : \"\";\n\n                //fix url() on relative import (#5)\n                importPath = importPath.replace(/^\\.\\//, '');\n\n                //Modify URL paths to match the path represented by this file.\n                importContents = fixCssUrlPaths(importFileName, importPath, importContents, cssPrefix);\n\n                importList.push(fullImportFileName);\n                return importContents;\n            } catch (e) {\n                logger.warn(fileName + \"\\n  Cannot inline css import, skipping: \" + importFileName);\n                return fullMatch;\n            }\n        });\n\n        if (cssPrefix && topLevel) {\n            //Modify URL paths to match the path represented by this file.\n            fileContents = fixCssUrlPaths(fileName, '', fileContents, cssPrefix);\n        }\n\n        return {\n            importList : importList,\n            skippedList: skippedList,\n            fileContents : fileContents\n        };\n    }\n\n    optimize = {\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file to optimize\n         * @param {String} fileContents the contents to optimize. If this is\n         * a null value, then fileName will be used to read the fileContents.\n         * @param {String} outFileName the name of the file to use for the\n         * saved optimized content.\n         * @param {Object} config the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var fs = config.env.fs;\n            if (!fileContents) {\n                fileContents = fs.readFile(fileName);\n            }\n\n            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);\n\n            fs.saveUtf8File(outFileName, fileContents);\n        },\n\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file that matches the\n         * fileContents.\n         * @param {String} fileContents the string of JS to optimize.\n         * @param {Object} [config] the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        js: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var optFunc, optConfig,\n                parts = (String(config.optimize)).split('.'),\n                optimizerName = parts[0],\n                keepLines = parts[1] === 'keepLines',\n                licenseContents = '';\n\n            config = config || {};\n\n            //Apply pragmas/namespace renaming\n            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n\n            //Optimize the JS files if asked.\n            if (optimizerName && optimizerName !== 'none') {\n                ///optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n                optFunc = optimize.optimizers[optimizerName];\n                if (!optFunc) {\n                    throw new Error('optimizer with name of \"' +\n                                    optimizerName +\n                                    '\" not found for this environment');\n                }\n\n                optConfig = config[optimizerName] || {};\n                if (config.generateSourceMaps) {\n                    optConfig.generateSourceMaps = !!config.generateSourceMaps;\n                    optConfig._buildSourceMap = config._buildSourceMap;\n                }\n                ///optConfig.env = config.env;\n\n                try {\n                    if (config.preserveLicenseComments) {\n                        //Pull out any license comments for prepending after optimization.\n                        try {\n                            licenseContents = parse.getLicenseComments(fileName, fileContents);\n                        } catch (e) {\n                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n                        }\n                    }\n\n                    if (config.generateSourceMaps && licenseContents) {\n                        optConfig.preamble = licenseContents;\n                        licenseContents = '';\n                    }\n\n                    fileContents = licenseContents + optFunc(fileName,\n                                                             fileContents,\n                                                             outFileName,\n                                                             keepLines,\n                                                             optConfig,\n                                                             config.env.fs);\n                    if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n                        config._buildSourceMap = optConfig._buildSourceMap;\n                    }\n                } catch (e) {\n                    if (config.throwWhen && config.throwWhen.optimize) {\n                        throw e;\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            } else {\n                if (config._buildSourceMap) {\n                    config._buildSourceMap = null;\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * Optimizes one CSS file, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} fileName the path to the CSS file to optimize\n         * @param {String} outFileName the path to save the optimized file.\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        cssFile: function (fileName, outFileName, config) {\n            var fs = config.env.fs;\n            //Read in the file. Make sure we have a JS string.\n            var originalFileContents = fs.readFile(fileName),\n                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}, true,config),\n                //Do not use the flattened CSS if there was one that was skipped.\n                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,\n                startIndex, endIndex, buildText, comment;\n\n            if (flat.skippedList.length) {\n                logger.warn('Cannot inline @imports for ' + fileName +\n                            ',\\nthe following files had media queries in them:\\n' +\n                            flat.skippedList.join('\\n'));\n            }\n\n            //Do comment removal.\n            try {\n                if (config.optimizeCss.indexOf(\".keepComments\") === -1) {\n                    startIndex = 0;\n                    //Get rid of comments.\n                    while ((startIndex = fileContents.indexOf(\"/*\", startIndex)) !== -1) {\n                        endIndex = fileContents.indexOf(\"*/\", startIndex + 2);\n                        if (endIndex === -1) {\n                            throw \"Improper comment in CSS file: \" + fileName;\n                        }\n                        comment = fileContents.substring(startIndex, endIndex);\n\n                        if (config.preserveLicenseComments &&\n                            (comment.indexOf('license') !== -1 ||\n                             comment.indexOf('opyright') !== -1 ||\n                             comment.indexOf('(c)') !== -1)) {\n                            //Keep the comment, just increment the startIndex\n                            startIndex = endIndex;\n                        } else {\n                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);\n                            startIndex = 0;\n                        }\n                    }\n                }\n                //Get rid of newlines.\n                if (config.optimizeCss.indexOf(\".keepLines\") === -1) {\n                    fileContents = fileContents.replace(/[\\r\\n]/g, \" \");\n                    fileContents = fileContents.replace(/\\s+/g, \" \");\n                    fileContents = fileContents.replace(/\\{\\s/g, \"{\");\n                    fileContents = fileContents.replace(/\\s\\}/g, \"}\");\n                } else {\n                    //Remove multiple empty lines.\n                    fileContents = fileContents.replace(/(\\r\\n)+/g, \"\\r\\n\");\n                    fileContents = fileContents.replace(/(\\n)+/g, \"\\n\");\n                }\n                //Remove unnecessary whitespace\n                if (config.optimizeCss.indexOf(\".keepWhitespace\") === -1) {\n                    //Remove leading and trailing whitespace from lines\n                    fileContents = fileContents.replace(/^[ \\t]+/gm, \"\");\n                    fileContents = fileContents.replace(/[ \\t]+$/gm, \"\");\n                    //Remove whitespace after semicolon, colon, curly brackets and commas\n                    fileContents = fileContents.replace(/(;|:|\\{|}|,)[ \\t]+/g, \"$1\");\n                    //Remove whitespace before opening curly brackets\n                    fileContents = fileContents.replace(/[ \\t]+(\\{)/g, \"$1\");\n                    //Truncate double whitespace\n                    fileContents = fileContents.replace(/([ \\t])+/g, \"$1\");\n                    //Remove empty lines\n                    fileContents = fileContents.replace(/^[ \\t]*[\\r\\n]/gm,'');\n                }\n            } catch (e) {\n                fileContents = originalFileContents;\n                logger.error(\"Could not optimized CSS file: \" + fileName + \", error: \" + e);\n            }\n\n            fs.saveUtf8File(outFileName, fileContents);\n\n            //text output to stdout and/or written to build.txt file\n            buildText = \"\\n\"+ outFileName.replace(config.dir, \"\") +\"\\n----------------\\n\";\n            flat.importList.push(fileName);\n            buildText += flat.importList.map(function(path){\n                return path.replace(config.dir, \"\");\n            }).join(\"\\n\");\n\n            return {\n                importList: flat.importList,\n                buildText: buildText +\"\\n\"\n            };\n        },\n\n        /**\n         * Optimizes CSS files, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} startDir the path to the top level directory\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        css: function (startDir, config) {\n            var buildText = \"\",\n                importList = [],\n                shouldRemove = config.dir && config.removeCombined,\n                i, fileName, result, fileList,\n                fs = config.env.fs;\n\n            if (config.optimizeCss.indexOf(\"standard\") !== -1) {\n                fileList = fs.getFilteredFileList(startDir, /\\.css$/, true);\n                if (fileList) {\n                    for (i = 0; i < fileList.length; i++) {\n                        fileName = fileList[i];\n                        logger.trace(\"Optimizing (\" + config.optimizeCss + \") CSS file: \" + fileName);\n                        result = optimize.cssFile(fileName, fileName, config);\n                        buildText += result.buildText;\n                        if (shouldRemove) {\n                            result.importList.pop();\n                            importList = importList.concat(result.importList);\n                        }\n                    }\n                }\n\n                if (shouldRemove) {\n                    importList.forEach(function (path) {\n                        if (fs.exists(path)) {\n                            fs.deleteFile(path);\n                        }\n                    });\n                }\n            }\n            return buildText;\n        },\n\n        optimizers: {\n            uglify: function (fileName, fileContents, outFileName, keepLines, config,fs) {\n                var result, existingMap, resultMap, finalMap, sourceIndex,\n                    uconfig = {},\n                    existingMapPath = outFileName + '.map',\n                    baseName = fileName && fileName.split('/').pop();\n\n                config = config || {};\n\n                lang.mixin(uconfig, config, true);\n\n                ///uconfig.fromString = true;  // uglify 2 -> 3\n\n                if (config.preamble) {\n                    uconfig.output = {preamble: config.preamble};\n                }\n\n                ///var fs = config.env.fs;\n\n                if (config.generateSourceMaps && (outFileName || config._buildSourceMap)) {\n                    uconfig.outSourceMap = baseName + '.map';\n\n                    if (config._buildSourceMap) {\n                        existingMap = JSON.parse(config._buildSourceMap);\n                        uconfig.inSourceMap = existingMap;\n                    } else if (fs.exists(existingMapPath)) {\n                        uconfig.inSourceMap = existingMapPath;\n                        existingMap = JSON.parse(fs.readFile(existingMapPath));\n                    }\n                }\n\n                logger.trace(\"Uglify file: \" + fileName);\n\n                try {\n                    //var tempContents = fileContents.replace(/\\/\\/\\# sourceMappingURL=.*$/, '');\n                    result = uglify.minify(fileContents, uconfig, baseName + '.src.js');\n                    if (uconfig.outSourceMap && result.map) {\n                        resultMap = result.map;\n                        if (!existingMap && !config._buildSourceMap) {\n                            fs.saveFile(outFileName + '.src.js', fileContents);\n                        }\n\n                        fileContents = result.code;\n\n                        if (config._buildSourceMap) {\n                            config._buildSourceMap = resultMap;\n                        } else {\n                            fs.saveFile(outFileName + '.map', resultMap);\n                        }\n                    } else {\n                        fileContents = result.code;\n                    }\n                } catch (e) {\n                    var errorString = e.toString();\n                    var isSyntaxError = /SyntaxError/.test(errorString);\n                    console.error(e);\n                    throw new Error('Cannot uglify file: ' + fileName +\n                                    '. Skipping it. Error is:\\n' + errorString +\n                                  (isSyntaxError ? '\\n\\n' + es5PlusGuidance : ''));\n                }\n                return fileContents;\n            }\n        }\n    };\n\n    return optimize;\n});\n\n/*global define */\n\ndefine('skylark-rjs/transform',[ \n    './esprima', \n    './parse', \n    './logger', \n    './lang'\n],\nfunction (esprima, parse, logger, lang) {\n    'use strict';\n    var transform,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                logger.trace('toTransport skipping ' + path + ': ' +\n                             e.toString());\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            logger.trace(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n\n/*jslint */\n/*global define: false, console: false */\n\ndefine('skylark-rjs/commonJs',[\n    './parse'\n], function (\n    parse\n) {\n    'use strict';\n    var commonJs = {\n        //Set to false if you do not want this file to log. Useful in environments\n        //like node where you want the work to happen without noise.\n        useLog: true,\n\n        convertDir: function (commonJsPath, savePath,fs) {\n            var fileList, i,\n                jsFileRegExp = /\\.js$/,\n                fileName, convertedFileName, fileContents;\n\n            //Get list of files to convert.\n            fileList = fs.getFilteredFileList(commonJsPath, /\\w/, true);\n\n            //Normalize on front slashes and make sure the paths do not end in a slash.\n            commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n            savePath = savePath.replace(/\\\\/g, \"/\");\n            if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n                commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n            }\n            if (savePath.charAt(savePath.length - 1) === \"/\") {\n                savePath = savePath.substring(0, savePath.length - 1);\n            }\n\n            //Cycle through all the JS files and convert them.\n            if (!fileList || !fileList.length) {\n                if (commonJs.useLog) {\n                    if (commonJsPath === \"convert\") {\n                        //A request just to convert one file.\n                        console.log('\\n\\n' + commonJs.convert(savePath, fs.readFile(savePath),config));\n                    } else {\n                        console.log(\"No files to convert in directory: \" + commonJsPath);\n                    }\n                }\n            } else {\n                for (i = 0; i < fileList.length; i++) {\n                    fileName = fileList[i];\n                    convertedFileName = fileName.replace(commonJsPath, savePath);\n\n                    //Handle JS files.\n                    if (jsFileRegExp.test(fileName)) {\n                        fileContents = fs.readFile(fileName);\n                        fileContents = commonJs.convert(fileName, fileContents,config);\n                        fs.saveUtf8File(convertedFileName, fileContents);\n                    } else {\n                        //Just copy the file over.\n                        fs.copyFile(fileName, convertedFileName, true);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Does the actual file conversion.\n         *\n         * @param {String} fileName the name of the file.\n         *\n         * @param {String} fileContents the contents of a file :)\n         *\n         * @returns {String} the converted contents\n         */\n        convert: function (fileName, fileContents) {\n            //Strip out comments.\n            try {\n                var preamble = '',\n                    commonJsProps = parse.usesCommonJs(fileName, fileContents);\n\n                //First see if the module is not already RequireJS-formatted.\n                if (parse.usesAmdOrRequireJs(fileName, fileContents) || !commonJsProps) {\n                    return fileContents;\n                }\n\n                if (commonJsProps.dirname || commonJsProps.filename) {\n                    preamble = 'var __filename = module.uri || \"\", ' +\n                               '__dirname = __filename.substring(0, __filename.lastIndexOf(\"/\") + 1); ';\n                }\n\n                //Construct the wrapper boilerplate.\n                fileContents = 'define(function (require, exports, module) {' +\n                    preamble +\n                    fileContents +\n                    '\\n});\\n';\n\n            } catch (e) {\n                console.log(\"commonJs.convert: COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n                return fileContents;\n            }\n\n            return fileContents;\n        }\n    };\n\n    return commonJs;\n});\n\n/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine('skylark-rjs/requirePatch',[ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true  */\n/*global define, requirejs, java, process, console */\n\n\ndefine('skylark-rjs/build',[\n    \"./rjs\",\n    \"./lang\",\n    \"./prim\",\n    \"./logger\",\n    ///\"env!env/file\",\n    \"./parse\",\n    \"./optimize\",\n    \"./pragma\",\n    \"./transform\",\n    \"./requirePatch\",\n    ///\"env\",\n    \"./commonJs\",\n    \"./source-map\"\n],function (\n    require,\n    lang,\n    prim,\n    logger,\n    parse,\n    optimize,\n    pragma,\n    transform,\n    requirePatch,\n    commonJs,\n    sourceMap\n\n) {\n    'use strict';\n\n    var build,\n        ///lang = require('lang'),\n        ///prim = require('prim'),\n        ///logger = require('logger'),\n        ///file = require('env!env/file'),\n        ///parse = require('parse'),\n        ///optimize = require('optimize'),\n        ///pragma = require('pragma'),\n        ///transform = require('transform'),\n        ///requirePatch = require('requirePatch'),\n        ///env = require('env'),\n        ///commonJs = require('commonJs'),\n        ///SourceMapGenerator = require('source-map').SourceMapGenerator,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        hasProp = lang.hasProp,\n        getOwn = lang.getOwn,\n        falseProp = lang.falseProp,\n        endsWithSemiColonRegExp = /;\\s*$/,\n        endsWithSlashRegExp = /[\\/\\\\]$/,\n        resourceIsModuleIdRegExp = /^[\\w\\/\\\\\\.]+$/,\n        deepCopyProps = {\n            layer: true\n        };\n\n    //Deep copy a config object, but do not copy over the \"layer\" property,\n    //as it can be a deeply nested structure with a full requirejs context.\n    function copyConfig(obj) {\n        return lang.deeplikeCopy(obj, deepCopyProps);\n    }\n\n    prim.nextTick = function (fn) {\n        fn();\n    };\n\n    //Now map require to the outermost requirejs, now that we have\n    //local dependencies for this module. The rest of the require use is\n    //manipulating the requirejs loader.\n    ///require = requirejs;\n\n    //Caching function for performance. Attached to\n    //require so it can be reused in requirePatch.js. _cachedRawText\n    //set up by requirePatch.js\n    require._cacheReadAsync = function (path, encoding,fs) {\n        var d;\n\n        if (lang.hasProp(require._cachedRawText, path)) {\n            d = prim();\n            d.resolve(require._cachedRawText[path]);\n            return d.promise;\n        } else {\n            return fs.readFileAsync(path, encoding).then(function (text) {\n                require._cachedRawText[path] = text;\n                return text;\n            });\n        }\n    };\n\n    function makeBuildBaseConfig(fs) {\n        return {\n            appDir: \"\",\n            pragmas: {},\n            paths: {},\n            optimize: \"uglify\",\n            optimizeCss: \"standard.keepLines.keepWhitespace\",\n            inlineText: true,\n            isBuild: true,\n            optimizeAllPluginResources: false,\n            findNestedDependencies: false,\n            preserveLicenseComments: true,\n            writeBuildTxt: true,\n            //Some builds can take a while, up the default limit.\n            waitSeconds: 30,\n            //By default, all files/directories are copied, unless\n            //they match this regexp, by default just excludes .folders\n            dirExclusionRegExp: fs.dirExclusionRegExp,\n            _buildPathToModuleIndex: {}\n        };\n    }\n\n    /**\n     * Some JS may not be valid if concatenated with other JS, in particular\n     * the style of omitting semicolons and rely on ASI. Add a semicolon in\n     * those cases.\n     */\n    function addSemiColon(text, config) {\n        if (config.skipSemiColonInsertion || endsWithSemiColonRegExp.test(text)) {\n            return text;\n        } else {\n            return text + \";\";\n        }\n    }\n\n    function endsWithSlash(dirName) {\n        if (dirName.charAt(dirName.length - 1) !== \"/\") {\n            dirName += \"/\";\n        }\n        return dirName;\n    }\n\n    function endsWithNewLine(text) {\n        if (text.charAt(text.length - 1) !== \"\\n\") {\n            text += \"\\n\";\n        }\n        return text;\n    }\n\n    //Method used by plugin writeFile calls, defined up here to avoid\n    //jslint warning about \"making a function in a loop\".\n    function makeWriteFile(namespace, layer) {\n        function writeFile(name, contents) {\n            logger.trace('Saving plugin-optimized file: ' + name);\n            file.saveUtf8File(name, contents);\n        }\n\n        writeFile.asModule = function (moduleName, fileName, contents) {\n            writeFile(fileName,\n                build.toTransport(namespace, moduleName, fileName, contents, layer));\n        };\n\n        return writeFile;\n    }\n\n    /**\n     * Appends singleContents to fileContents and returns the result.  If a sourceMapGenerator\n     * is provided, adds singleContents to the source map.\n     *\n     * @param {string} fileContents - The file contents to which to append singleContents\n     * @param {string} singleContents - The additional contents to append to fileContents\n     * @param {string} path - An absolute path of a file whose name to use in the source map.\n     * The file need not actually exist if the code in singleContents is generated.\n     * @param {{out: ?string, baseUrl: ?string}} config - The build configuration object.\n     * @param {?{_buildPath: ?string}} module - An object with module information.\n     * @param {?SourceMapGenerator} sourceMapGenerator - An instance of Mozilla's SourceMapGenerator,\n     * or null if no source map is being generated.\n     * @returns {string} fileContents with singleContents appended\n     */\n    function appendToFileContents(fileContents, singleContents, path, config, module, sourceMapGenerator) {\n        var refPath, sourceMapPath, resourcePath, pluginId, sourceMapLineNumber, lineCount, parts, i;\n        if (sourceMapGenerator) {\n            if (config.out) {\n                refPath = config.baseUrl;\n            } else if (module && module._buildPath) {\n                refPath = module._buildPath;\n            } else {\n                refPath = \"\";\n            }\n            parts = path.split('!');\n            if (parts.length === 1) {\n                //Not a plugin resource, fix the path\n                sourceMapPath = build.makeRelativeFilePath(refPath, path);\n            } else {\n                //Plugin resource. If it looks like just a plugin\n                //followed by a module ID, pull off the plugin\n                //and put it at the end of the name, otherwise\n                //just leave it alone.\n                pluginId = parts.shift();\n                resourcePath = parts.join('!');\n                if (resourceIsModuleIdRegExp.test(resourcePath)) {\n                    sourceMapPath = build.makeRelativeFilePath(refPath, require.toUrl(resourcePath)) +\n                                    '!' + pluginId;\n                } else {\n                    sourceMapPath = path;\n                }\n            }\n\n            sourceMapLineNumber = fileContents.split('\\n').length - 1;\n            lineCount = singleContents.split('\\n').length;\n            for (i = 1; i <= lineCount; i += 1) {\n                sourceMapGenerator.addMapping({\n                    generated: {\n                        line: sourceMapLineNumber + i,\n                        column: 0\n                    },\n                    original: {\n                        line: i,\n                        column: 0\n                    },\n                    source: sourceMapPath\n                });\n            }\n\n            //Store the content of the original in the source\n            //map since other transforms later like minification\n            //can mess up translating back to the original\n            //source.\n            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);\n        }\n        fileContents += singleContents;\n        return fileContents;\n    }\n\n    /**\n     * Main API entry point into the build. The args argument can either be\n     * an array of arguments (like the onese passed on a command-line),\n     * or it can be a JavaScript object that has the format of a build profile\n     * file.\n     *\n     * If it is an object, then in addition to the normal properties allowed in\n     * a build profile file, the object should contain one other property:\n     *\n     * The object could also contain a \"buildFile\" property, which is a string\n     * that is the file path to a build profile that contains the rest\n     * of the build profile directives.\n     *\n     * This function does not return a status, it should throw an error if\n     * there is a problem completing the build.\n     */\n    build = function (args) {\n        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,\n            i, j, errorMod,\n            stackRegExp = /( {4}at[^\\n]+)\\n/,\n            standardIndent = '  ';\n\n        return prim().start(function () {\n            if (!args || lang.isArray(args)) {\n                if (!args || args.length < 1) {\n                    logger.error(\"build.js buildProfile.js\\n\" +\n                          \"where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).\");\n                    return undefined;\n                }\n\n                //Next args can include a build file path as well as other build args.\n                //build file path comes first. If it does not contain an = then it is\n                //a build file path. Otherwise, just all build args.\n                if (args[0].indexOf(\"=\") === -1) {\n                    buildFile = args[0];\n                    args.splice(0, 1);\n                }\n\n                //Remaining args are options to the build\n                cmdConfig = build.convertArrayToObject(args);\n                cmdConfig.buildFile = buildFile;\n            } else {\n                cmdConfig = args;\n            }\n\n            return build._run(cmdConfig);\n        }).then(null, function (e) {\n            var err;\n\n            errorMsg = e.toString();\n            errorTree = e.moduleTree;\n            stackMatch = stackRegExp.exec(errorMsg);\n\n            if (stackMatch) {\n                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);\n            }\n\n            //If a module tree that shows what module triggered the error,\n            //print it out.\n            if (errorTree && errorTree.length > 0) {\n                errorMsg += '\\nIn module tree:\\n';\n\n                for (i = errorTree.length - 1; i > -1; i--) {\n                    errorMod = errorTree[i];\n                    if (errorMod) {\n                        for (j = errorTree.length - i; j > -1; j--) {\n                            errorMsg += standardIndent;\n                        }\n                        errorMsg += errorMod + '\\n';\n                    }\n                }\n\n                logger.error(errorMsg);\n            }\n\n            errorStack = e.stack;\n\n            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {\n                errorMsg += '\\n' + errorStack;\n            } else {\n                if (!stackMatch && errorStack) {\n                    //Just trim out the first \"at\" in the stack.\n                    stackMatch = stackRegExp.exec(errorStack);\n                    if (stackMatch) {\n                        errorMsg += '\\n' + stackMatch[0] || '';\n                    }\n                }\n            }\n\n            err = new Error(errorMsg);\n            err.originalError = e;\n            throw err;\n        });\n    };\n\n    build._run = function (cmdConfig) {\n        var buildPaths, fileName, fileNames,\n            paths, i,\n            baseConfig, config,\n            modules, srcPath, buildContext,\n            destPath, moduleMap, parentModuleMap, context,\n            resources, resource, plugin, fileContents,\n            pluginProcessed = {},\n            buildFileContents = \"\",\n            pluginCollector = {},\n            fs;\n\n        return prim().start(function () {\n            var prop;\n\n            //Can now run the patches to require.js to allow it to be used for\n            //build generation. Do it here instead of at the top of the module\n            //because we want normal require behavior to load the build tool\n            //then want to switch to build mode.\n\n            config = build.createConfig(cmdConfig);\n            paths = config.paths;\n            fs = config.env.fs;\n\n            requirePatch(config);\n\n\n            //Remove the previous build dir, in case it contains source transforms,\n            //like the ones done with onBuildRead and onBuildWrite.\n            if (config.dir && !config.keepBuildDir && fs.exists(config.dir)) {\n                fs.deleteFile(config.dir);\n            }\n\n            if (!config.out && !config.cssIn) {\n                //This is not just a one-off file build but a full build profile, with\n                //lots of files to process.\n\n                //First copy all the baseUrl content\n                fs.copyDir((config.appDir || config.baseUrl), config.dir, /\\w/, true);\n\n                //Adjust baseUrl if config.appDir is in play, and set up build output paths.\n                buildPaths = {};\n                if (config.appDir) {\n                    //All the paths should be inside the appDir, so just adjust\n                    //the paths to use the dirBaseUrl\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);\n                        }\n                    }\n                } else {\n                    //If no appDir, then make sure to copy the other paths to this directory.\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            //Set up build path for each path prefix, but only do so\n                            //if the path falls out of the current baseUrl\n                            if (paths[prop].indexOf(config.baseUrl) === 0) {\n                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);\n                            } else {\n                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop;\n\n                                //Make sure source path is fully formed with baseUrl,\n                                //if it is a relative URL.\n                                srcPath = paths[prop];\n                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {\n                                    srcPath = config.baseUrl + srcPath;\n                                }\n\n                                destPath = config.dirBaseUrl + buildPaths[prop];\n\n                                //Skip empty: paths\n                                if (srcPath !== 'empty:') {\n                                    //If the srcPath is a directory, copy the whole directory.\n                                    if (fs.exists(srcPath) && fs.isDirectory(srcPath)) {\n                                        //Copy files to build area. Copy all files (the /\\w/ regexp)\n                                        fs.copyDir(srcPath, destPath, /\\w/, true);\n                                    } else {\n                                        //Try a .js extension\n                                        srcPath += '.js';\n                                        destPath += '.js';\n                                        fs.copyFile(srcPath, destPath);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            //Figure out source file location for each module layer. Do this by seeding require\n            //with source area configuration. This is needed so that later the module layers\n            //can be manually copied over to the source area, since the build may be\n            //require multiple times and the above copyDir call only copies newer files.\n            require({\n                baseUrl: config.baseUrl,\n                paths: paths,\n                packagePaths: config.packagePaths,\n                packages: config.packages\n            });\n            buildContext = require.s.contexts._;\n            modules = config.modules;\n\n            if (modules) {\n                modules.forEach(function (module) {\n                    if (module.name) {\n                        module._sourcePath = buildContext.nameToUrl(module.name);\n                        //If the module does not exist, and this is not a \"new\" module layer,\n                        //as indicated by a true \"create\" property on the module, and\n                        //it is not a plugin-loaded resource, and there is no\n                        //'rawText' containing the module's source then throw an error.\n                        if (!fs.exists(module._sourcePath) && !module.create &&\n                                module.name.indexOf('!') === -1 &&\n                                (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                            throw new Error(\"ERROR: module path does not exist: \" +\n                                            module._sourcePath + \" for module named: \" + module.name +\n                                            \". Path is relative to: \" + fs.absPath('.'));\n                        }\n                    }\n                });\n            }\n\n            if (config.out) {\n                //Just set up the _buildPath for the module layer.\n                require(config);\n                if (!config.cssIn) {\n                    config.modules[0]._buildPath = typeof config.out === 'function' ?\n                                                   'FUNCTION' : config.out;\n                }\n            } else if (!config.cssIn) {\n                //Now set up the config for require to use the build area, and calculate the\n                //build file locations. Pass along any config info too.\n                baseConfig = {\n                    baseUrl: config.dirBaseUrl,\n                    paths: buildPaths\n                };\n\n                lang.mixin(baseConfig, config);\n                require(baseConfig);\n\n                if (modules) {\n                    modules.forEach(function (module) {\n                        if (module.name) {\n                            module._buildPath = buildContext.nameToUrl(module.name, null);\n\n                            //If buildPath and sourcePath are the same, throw since this\n                            //would result in modifying source. This condition can happen\n                            //with some more tricky paths: config and appDir/baseUrl\n                            //setting, which is a sign of incorrect config.\n                            if (module._buildPath === module._sourcePath &&\n                                !config.allowSourceOverwrites) {\n                                throw new Error('Module ID \\'' + module.name  +\n                                                '\\' has a source path that is same as output path: ' +\n                                                module._sourcePath +\n                                                '. Stopping, config is malformed.');\n                            }\n\n                            // Copy the file, but only if it is not provided in rawText.\n                            if (!module.create && (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                                fs.copyFile(module._sourcePath, module._buildPath);\n                            }\n                        }\n                    });\n                }\n            }\n\n            //Run CSS optimizations before doing JS module tracing, to allow\n            //things like text loader plugins loading CSS to get the optimized\n            //CSS.\n            if (config.optimizeCss && config.optimizeCss !== \"none\" && config.dir) {\n                buildFileContents += optimize.css(config.dir, config);\n            }\n        }).then(function() {\n            baseConfig = copyConfig(require.s.contexts._.config);\n        }).then(function () {\n            var actions = [];\n\n            if (modules) {\n                actions = modules.map(function (module, i) {\n                    return function () {\n                        //Save off buildPath to module index in a hash for quicker\n                        //lookup later.\n                        config._buildPathToModuleIndex[fs.normalize(module._buildPath)] = i;\n\n                        //Call require to calculate dependencies.\n                        return build.traceDependencies(module, config, baseConfig)\n                            .then(function (layer) {\n                                module.layer = layer;\n                            });\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            var actions;\n\n            if (modules) {\n                //Now build up shadow layers for anything that should be excluded.\n                //Do this after tracing dependencies for each module, in case one\n                //of those modules end up being one of the excluded values.\n                actions = modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            module.excludeLayers = [];\n                            return prim.serial(module.exclude.map(function (exclude, i) {\n                                return function () {\n                                    //See if it is already in the list of modules.\n                                    //If not trace dependencies for it.\n                                    var found = build.findBuildModule(exclude, modules);\n                                    if (found) {\n                                        module.excludeLayers[i] = found;\n                                    } else {\n                                        return build.traceDependencies({name: exclude}, config, baseConfig)\n                                            .then(function (layer) {\n                                                module.excludeLayers[i] = { layer: layer };\n                                            });\n                                    }\n                                };\n                            }));\n                        }\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            if (modules) {\n                return prim.serial(modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            //module.exclude is an array of module names. For each one,\n                            //get the nested dependencies for it via a matching entry\n                            //in the module.excludeLayers array.\n                            module.exclude.forEach(function (excludeModule, i) {\n                                var excludeLayer = module.excludeLayers[i].layer,\n                                    map = excludeLayer.buildFileToModule;\n                                excludeLayer.buildFilePaths.forEach(function(filePath){\n                                    build.removeModulePath(map[filePath], filePath, module.layer);\n                                });\n                            });\n                        }\n                        if (module.excludeShallow) {\n                            //module.excludeShallow is an array of module names.\n                            //shallow exclusions are just that module itself, and not\n                            //its nested dependencies.\n                            module.excludeShallow.forEach(function (excludeShallowModule) {\n                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);\n                                if (path) {\n                                    build.removeModulePath(excludeShallowModule, path, module.layer);\n                                }\n                            });\n                        }\n\n                        //Flatten them and collect the build output for each module.\n                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {\n                            var finalText, baseName;\n                            //Save it to a temp file for now, in case there are other layers that\n                            //contain optimized content that should not be included in later\n                            //layer optimizations. See issue #56.\n                            if (module._buildPath === 'FUNCTION') {\n                                module._buildText = builtModule.text;\n                                module._buildSourceMap = builtModule.sourceMap;\n                            } else {\n                                finalText = builtModule.text;\n                                if (builtModule.sourceMap) {\n                                    baseName = module._buildPath.split('/');\n                                    baseName = baseName.pop();\n                                    finalText += '\\n//# sourceMappingURL=' + baseName + '.map';\n                                    fs.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);\n                                }\n                                fs.saveUtf8File(module._buildPath + '-temp', finalText);\n\n                            }\n                            buildFileContents += builtModule.buildText;\n                        });\n                    };\n                }));\n            }\n        }).then(function () {\n            var moduleName, outOrigSourceMap,\n                bundlesConfig = {},\n                bundlesConfigOutFile = config.bundlesConfigOutFile;\n\n            if (modules) {\n                //Now move the build layers to their final position.\n                modules.forEach(function (module) {\n                    var entryConfig,\n                        finalPath = module._buildPath;\n\n                    if (finalPath !== 'FUNCTION') {\n                        if (fs.exists(finalPath)) {\n                            fs.deleteFile(finalPath);\n                        }\n                        fs.renameFile(finalPath + '-temp', finalPath);\n\n                        //If bundles config should be written out, scan the\n                        //built file for module IDs. Favor doing this reparse\n                        //since tracking the IDs as the file is built has some\n                        //edge cases around files that had more than one ID in\n                        //them already, and likely loader plugin-written contents.\n                        if (bundlesConfigOutFile) {\n                            entryConfig = bundlesConfig[module.name] = [];\n                            var bundleContents = fs.readFile(finalPath);\n                            var excludeMap = {};\n                            excludeMap[module.name] = true;\n                            var parsedIds = parse.getAllNamedDefines(bundleContents, excludeMap);\n                            entryConfig.push.apply(entryConfig, parsedIds);\n                        }\n\n                        //And finally, if removeCombined is specified, remove\n                        //any of the files that were used in this layer.\n                        //Be sure not to remove other build layers.\n                        if (config.removeCombined && !config.out) {\n                            module.layer.buildFilePaths.forEach(function (path) {\n                                var isLayer = modules.some(function (mod) {\n                                        return mod._buildPath === path;\n                                    }),\n                                    relPath = build.makeRelativeFilePath(config.dir, path);\n\n                                if (fs.exists(path) &&\n                                    // not a build layer target\n                                    !isLayer &&\n                                    // not outside the build directory\n                                    relPath.indexOf('..') !== 0) {\n                                    fs.deleteFile(path);\n                                }\n                            });\n                        }\n                    }\n\n                    //Signal layer is done\n                    if (config.onModuleBundleComplete) {\n                        config.onModuleBundleComplete(module.onCompleteData);\n                    }\n                });\n\n                //Write out bundles config, if it is wanted.\n                if (bundlesConfigOutFile) {\n                    var text = fs.readFile(bundlesConfigOutFile);\n                    text = transform.modifyConfig(text, function (config) {\n                        if (!config.bundles) {\n                            config.bundles = {};\n                        }\n\n                        lang.eachProp(bundlesConfig, function (value, prop) {\n                            config.bundles[prop] = value;\n                        });\n\n                        return config;\n                    });\n\n                    fs.saveUtf8File(bundlesConfigOutFile, text);\n                }\n            }\n\n            //If removeCombined in play, remove any empty directories that\n            //may now exist because of its use\n            if (config.removeCombined && !config.out && config.dir) {\n                fs.deleteEmptyDirs(config.dir);\n            }\n\n            //Do other optimizations.\n            if (config.out && !config.cssIn) {\n                //Just need to worry about one JS file.\n                fileName = config.modules[0]._buildPath;\n                if (fileName === 'FUNCTION') {\n                    outOrigSourceMap = config.modules[0]._buildSourceMap;\n                    config._buildSourceMap = outOrigSourceMap;\n                    config.modules[0]._buildText = optimize.js((config.modules[0].name ||\n                                                                config.modules[0].include[0] ||\n                                                                fileName) + '.build.js',\n                                                               config.modules[0]._buildText,\n                                                               null,\n                                                               config);\n                    if (config._buildSourceMap && config._buildSourceMap !== outOrigSourceMap) {\n                        config.modules[0]._buildSourceMap = config._buildSourceMap;\n                        config._buildSourceMap = null;\n                    }\n                } else {\n                    optimize.jsFile(fileName, null, fileName, config);\n                }\n            } else if (!config.cssIn) {\n                //Normal optimizations across modules.\n\n                //JS optimizations.\n                fileNames = fs.getFilteredFileList(config.dir, /\\.js$/, true);\n                fileNames.forEach(function (fileName) {\n                    var cfg, override, moduleIndex;\n\n                    //Generate the module name from the config.dir root.\n                    moduleName = fileName.replace(config.dir, '');\n                    //Get rid of the extension\n                    moduleName = moduleName.substring(0, moduleName.length - 3);\n\n                    //If there is an override for a specific layer build module,\n                    //and this file is that module, mix in the override for use\n                    //by optimize.jsFile.\n                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);\n                    //Normalize, since getOwn could have returned undefined\n                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;\n\n                    //Try to avoid extra work if the other files do not need to\n                    //be read. Build layers should be processed at the very\n                    //least for optimization.\n                    if (moduleIndex > -1 || !config.skipDirOptimize ||\n                            config.normalizeDirDefines === \"all\" ||\n                            config.cjsTranslate) {\n                        //Convert the file to transport format, but without a name\n                        //inserted (by passing null for moduleName) since the files are\n                        //standalone, one module per file.\n                        fileContents = fs.readFile(fileName);\n\n\n                        //For builds, if wanting cjs translation, do it now, so that\n                        //the individual modules can be loaded cross domain via\n                        //plain script tags.\n                        if (config.cjsTranslate &&\n                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                            fileContents = commonJs.convert(fileName, fileContents);\n                        }\n\n                        if (moduleIndex === -1) {\n                            if (config.onBuildRead) {\n                                fileContents = config.onBuildRead(moduleName,\n                                                                  fileName,\n                                                                  fileContents);\n                            }\n\n                            //Only do transport normalization if this is not a build\n                            //layer (since it was already normalized) and if\n                            //normalizeDirDefines indicated all should be done.\n                            if (config.normalizeDirDefines === \"all\") {\n                                fileContents = build.toTransport(config.namespace,\n                                                             null,\n                                                             fileName,\n                                                             fileContents);\n                            }\n\n                            if (config.onBuildWrite) {\n                                fileContents = config.onBuildWrite(moduleName,\n                                                                   fileName,\n                                                                   fileContents);\n                            }\n                        }\n\n                        override = moduleIndex > -1 ?\n                                   config.modules[moduleIndex].override : null;\n                        if (override) {\n                            cfg = build.createOverrideConfig(config, override);\n                        } else {\n                            cfg = config;\n                        }\n\n                        if (moduleIndex > -1 || !config.skipDirOptimize) {\n                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);\n                        }\n                    }\n                });\n\n                //Normalize all the plugin resources.\n                context = require.s.contexts._;\n\n                for (moduleName in pluginCollector) {\n                    if (hasProp(pluginCollector, moduleName)) {\n                        parentModuleMap = context.makeModuleMap(moduleName);\n                        resources = pluginCollector[moduleName];\n                        for (i = 0; i < resources.length; i++) {\n                            resource = resources[i];\n                            moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            if (falseProp(context.plugins, moduleMap.prefix)) {\n                                //Set the value in context.plugins so it\n                                //will be evaluated as a full plugin.\n                                context.plugins[moduleMap.prefix] = true;\n\n                                //Do not bother if the plugin is not available.\n                                if (!fs.exists(require.toUrl(moduleMap.prefix + '.js'))) {\n                                    continue;\n                                }\n\n                                //Rely on the require in the build environment\n                                //to be synchronous\n                                context.require([moduleMap.prefix]);\n\n                                //Now that the plugin is loaded, redo the moduleMap\n                                //since the plugin will need to normalize part of the path.\n                                moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            }\n\n                            //Only bother with plugin resources that can be handled\n                            //processed by the plugin, via support of the writeFile\n                            //method.\n                            if (falseProp(pluginProcessed, moduleMap.id)) {\n                                //Only do the work if the plugin was really loaded.\n                                //Using an internal access because the file may\n                                //not really be loaded.\n                                plugin = getOwn(context.defined, moduleMap.prefix);\n                                if (plugin && plugin.writeFile) {\n                                    plugin.writeFile(\n                                        moduleMap.prefix,\n                                        moduleMap.name,\n                                        require,\n                                        makeWriteFile(\n                                            config.namespace\n                                        ),\n                                        context.config\n                                    );\n                                }\n\n                                pluginProcessed[moduleMap.id] = true;\n                            }\n                        }\n\n                    }\n                }\n\n                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, \"  \"));\n\n\n                //All module layers are done, write out the build.txt file.\n                if (config.writeBuildTxt) {\n                    fs.saveUtf8File(config.dir + \"build.txt\", buildFileContents);\n                }\n            }\n\n            //If just have one CSS file to optimize, do that here.\n            if (config.cssIn) {\n                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;\n            }\n\n            if (typeof config.out === 'function') {\n                config.out(config.modules[0]._buildText, config.modules[0]._buildSourceMap);\n            }\n\n            //Print out what was built into which layers.\n            if (buildFileContents) {\n                logger.info(buildFileContents);\n                return buildFileContents;\n            }\n\n            return '';\n        });\n    };\n\n    /**\n     * Converts command line args like \"paths.foo=../some/path\"\n     * result.paths = { foo: '../some/path' } where prop = paths,\n     * name = paths.foo and value = ../some/path, so it assumes the\n     * name=value splitting has already happened.\n     */\n    function stringDotToObj(result, name, value) {\n        var parts = name.split('.');\n\n        parts.forEach(function (prop, i) {\n            if (i === parts.length - 1) {\n                result[prop] = value;\n            } else {\n                if (falseProp(result, prop)) {\n                    result[prop] = {};\n                }\n                result = result[prop];\n            }\n\n        });\n    }\n\n    build.objProps = {\n        paths: true,\n        wrap: true,\n        pragmas: true,\n        pragmasOnSave: true,\n        has: true,\n        hasOnSave: true,\n        uglify: true,\n        uglify2: true,\n        closure: true,\n        map: true,\n        throwWhen: true,\n        rawText: true\n    };\n\n    build.hasDotPropMatch = function (prop) {\n        var dotProp,\n            index = prop.indexOf('.');\n\n        if (index !== -1) {\n            dotProp = prop.substring(0, index);\n            return hasProp(build.objProps, dotProp);\n        }\n        return false;\n    };\n\n    /**\n     * Converts an array that has String members of \"name=value\"\n     * into an object, where the properties on the object are the names in the array.\n     * Also converts the strings \"true\" and \"false\" to booleans for the values.\n     * member name/value pairs, and converts some comma-separated lists into\n     * arrays.\n     * @param {Array} ary\n     */\n    build.convertArrayToObject = function (ary) {\n        var result = {}, i, separatorIndex, prop, value,\n            needArray = {\n                \"include\": true,\n                \"exclude\": true,\n                \"excludeShallow\": true,\n                \"insertRequire\": true,\n                \"stubModules\": true,\n                \"deps\": true,\n                \"mainConfigFile\": true,\n                \"wrap.startFile\": true,\n                \"wrap.endFile\": true\n            };\n\n        for (i = 0; i < ary.length; i++) {\n            separatorI.ndex = ary[i].indexOf(\"=\");\n            if (separatorIndex === -1) {\n                throw \"Malformed name/value pair: [\" + ary[i] + \"]. Format should be name=value\";\n            }\n\n            value = ary[i].substring(separatorIndex + 1, ary[i].length);\n            if (value === \"true\") {\n                value = true;\n            } else if (value === \"false\") {\n                value = false;\n            }\n\n            prop = ary[i].substring(0, separatorIndex);\n\n            //Convert to array if necessary\n            if (getOwn(needArray, prop)) {\n                value = value.split(\",\");\n            }\n\n            if (build.hasDotPropMatch(prop)) {\n                stringDotToObj(result, prop, value);\n            } else {\n                result[prop] = value;\n            }\n        }\n        return result; //Object\n    };\n\n    build.makeAbsPath = function (path, absFilePath,fs) {\n        if (!absFilePath) {\n            return path;\n        }\n\n        //Add abspath if necessary. If path starts with a slash or has a colon,\n        //then already is an abolute path.\n        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {\n            path = absFilePath +\n                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +\n                   path;\n            path = fs.normalize(path);\n        }\n        return path.replace(lang.backSlashRegExp, '/');\n    };\n\n    build.makeAbsObject = function (props, obj, absFilePath,fs) {\n        var i, prop;\n        if (obj) {\n            for (i = 0; i < props.length; i++) {\n                prop = props[i];\n                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {\n                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath,fs);\n                }\n            }\n        }\n    };\n\n    /**\n     * For any path in a possible config, make it absolute relative\n     * to the absFilePath passed in.\n     */\n    build.makeAbsConfig = function (config, absFilePath,fs) {\n        var props, prop, i;\n\n        props = [\"appDir\", \"dir\", \"baseUrl\"];\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n\n            if (getOwn(config, prop)) {\n                //Add abspath if necessary, make sure these paths end in\n                //slashes\n                if (prop === \"baseUrl\") {\n                    config.originalBaseUrl = config.baseUrl;\n                    if (config.appDir) {\n                        //If baseUrl with an appDir, the baseUrl is relative to\n                        //the appDir, *not* the absFilePath. appDir and dir are\n                        //made absolute before baseUrl, so this will work.\n                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir,fs);\n                    } else {\n                        //The dir output baseUrl is same as regular baseUrl, both\n                        //relative to the absFilePath.\n                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath,fs);\n                    }\n                } else {\n                    config[prop] = build.makeAbsPath(config[prop], absFilePath,fs);\n                }\n\n                config[prop] = endsWithSlash(config[prop]);\n            }\n        }\n\n        build.makeAbsObject((config.out === \"stdout\" ? [\"cssIn\"] : [\"out\", \"cssIn\"]),\n                            config, absFilePath,fs);\n        build.makeAbsObject([\"startFile\", \"endFile\"], config.wrap, absFilePath,fs);\n        build.makeAbsObject([\"externExportsPath\"], config.closure, absFilePath,fs);\n    };\n\n    /**\n     * Creates a relative path to targetPath from refPath.\n     * Only deals with file paths, not folders. If folders,\n     * make sure paths end in a trailing '/'.\n     */\n    build.makeRelativeFilePath = function (refPath, targetPath,fs) {\n        var i, dotLength, finalParts, length, targetParts, targetName,\n            refParts = refPath.split('/'),\n            hasEndSlash = endsWithSlashRegExp.test(targetPath),\n            dotParts = [];\n\n        targetPath = fs.normalize(targetPath);\n        if (hasEndSlash && !endsWithSlashRegExp.test(targetPath)) {\n            targetPath += '/';\n        }\n        targetParts = targetPath.split('/');\n        //Pull off file name\n        targetName = targetParts.pop();\n\n        //Also pop off the ref file name to make the matches against\n        //targetParts equivalent.\n        refParts.pop();\n\n        length = refParts.length;\n\n        for (i = 0; i < length; i += 1) {\n            if (refParts[i] !== targetParts[i]) {\n                break;\n            }\n        }\n\n        //Now i is the index in which they diverge.\n        finalParts = targetParts.slice(i);\n\n        dotLength = length - i;\n        for (i = 0; i > -1 && i < dotLength; i += 1) {\n            dotParts.push('..');\n        }\n\n        return dotParts.join('/') + (dotParts.length ? '/' : '') +\n               finalParts.join('/') + (finalParts.length ? '/' : '') +\n               targetName;\n    };\n\n    build.nestedMix = {\n        paths: true,\n        has: true,\n        hasOnSave: true,\n        pragmas: true,\n        pragmasOnSave: true\n    };\n\n    /**\n     * Mixes additional source config into target config, and merges some\n     * nested config, like paths, correctly.\n     */\n    function mixConfig(target, source, skipArrays) {\n        var prop, value, isArray, targetValue;\n\n        for (prop in source) {\n            if (hasProp(source, prop)) {\n                //If the value of the property is a plain object, then\n                //allow a one-level-deep mixing of it.\n                value = source[prop];\n                isArray = lang.isArray(value);\n                if (typeof value === 'object' && value &&\n                        !isArray && !lang.isFunction(value) &&\n                        !lang.isRegExp(value)) {\n\n                    // TODO: need to generalize this work, maybe also reuse\n                    // the work done in requirejs configure, perhaps move to\n                    // just a deep copy/merge overall. However, given the\n                    // amount of observable change, wait for a dot release.\n                    // This change is in relation to #645\n                    if (prop === 'map') {\n                        if (!target.map) {\n                            target.map = {};\n                        }\n                        lang.deepMix(target.map, source.map);\n                    } else {\n                        target[prop] = lang.mixin({}, target[prop], value, true);\n                    }\n                } else if (isArray) {\n                    if (!skipArrays) {\n                        // Some config, like packages, are arrays. For those,\n                        // just merge the results.\n                        targetValue = target[prop];\n                        if (lang.isArray(targetValue)) {\n                            target[prop] = targetValue.concat(value);\n                        } else {\n                            target[prop] = value;\n                        }\n                    }\n                } else {\n                    target[prop] = value;\n                }\n            }\n        }\n\n        //Set up log level since it can affect if errors are thrown\n        //or caught and passed to errbacks while doing config setup.\n        if (lang.hasProp(target, 'logLevel')) {\n            logger.logLevel(target.logLevel);\n        }\n    }\n\n    /**\n     * Converts a wrap.startFile or endFile to be start/end as a string.\n     * the startFile/endFile values can be arrays.\n     */\n    function flattenWrapFile(config, keyName, absFilePath) {\n        var wrap = config.wrap,\n            keyFileName = keyName + 'File',\n            keyMapName = '__' + keyName + 'Map',\n            fs = config.env.fs;\n\n        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {\n            wrap[keyName] = '';\n            if (typeof wrap[keyFileName] === 'string') {\n                wrap[keyFileName] = [wrap[keyFileName]];\n            }\n            wrap[keyMapName] = [];\n            wrap[keyFileName].forEach(function (fileName) {\n                var absPath = build.makeAbsPath(fileName, absFilePath,fs),\n                    fileText = endsWithNewLine(fs.readFile(absPath));\n                wrap[keyMapName].push(function (fileContents, cfg, sourceMapGenerator) {\n                    return appendToFileContents(fileContents, fileText, absPath, cfg, null, sourceMapGenerator);\n                });\n                wrap[keyName] += fileText;\n            });\n        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {\n            //Allow missing one, just set to empty string.\n            wrap[keyName] = '';\n        } else if (typeof wrap[keyName] === 'string') {\n            wrap[keyName] = endsWithNewLine(wrap[keyName]);\n            wrap[keyMapName] = [\n                function (fileContents, cfg, sourceMapGenerator) {\n                    var absPath = build.makeAbsPath(\"config-wrap-\" + keyName + \"-default.js\", absFilePath,fs);\n                    return appendToFileContents(fileContents, wrap[keyName], absPath, cfg, null, sourceMapGenerator);\n                }\n            ];\n        } else {\n            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');\n        }\n    }\n\n    function normalizeWrapConfig(config, absFilePath) {\n        //Get any wrap text.\n        var fs = config.env.fs;\n        try {\n            if (config.wrap) {\n                if (config.wrap === true) {\n                    //Use default values.\n                    config.wrap = {\n                        start: '(function () {\\n',\n                        end: '}());',\n                        __startMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"(function () {\\n\",\n                                                            build.makeAbsPath(\"config-wrap-start-default.js\",\n                                                                              absFilePath,fs), cfg, null,\n                                                            sourceMapGenerator);\n                            }\n                        ],\n                        __endMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"}());\",\n                                                            build.makeAbsPath(\"config-wrap-end-default.js\", absFilePath,fs),\n                                                            cfg, null, sourceMapGenerator);\n                            }\n                        ]\n                    };\n                } else {\n                    flattenWrapFile(config, 'start', absFilePath);\n                    flattenWrapFile(config, 'end', absFilePath);\n                }\n            }\n        } catch (wrapError) {\n            throw new Error('Malformed wrap config: ' + wrapError.toString());\n        }\n    }\n\n    /**\n     * Creates a config object for an optimization build.\n     * It will also read the build profile if it is available, to create\n     * the configuration.\n     *\n     * @param {Object} cfg config options that take priority\n     * over defaults and ones in the build file. These options could\n     * be from a command line, for instance.\n     *\n     * @param {Object} the created config object.\n     */\n    build.createConfig = function (cfg) {\n        /*jslint evil: true */\n        var fs = cfg.env.fs;\n\n        var buildFileContents, buildFileConfig, mainConfig,\n            mainConfigFile, mainConfigPath, buildFile, absFilePath,\n            config = {},\n            buildBaseConfig = makeBuildBaseConfig(fs);\n\n\n        //Make sure all paths are relative to current directory.\n\n        absFilePath = fs.absPath('.');\n        build.makeAbsConfig(cfg, absFilePath,fs);\n        build.makeAbsConfig(buildBaseConfig, absFilePath,fs);\n\n        lang.mixin(config, buildBaseConfig);\n        lang.mixin(config, cfg, true);\n\n\n        //Set up log level early since it can affect if errors are thrown\n        //or caught and passed to errbacks, even while constructing config.\n        if (lang.hasProp(config, 'logLevel')) {\n            logger.logLevel(config.logLevel);\n        }\n\n        if (config.buildFile) {\n            //A build file exists, load it to get more config.\n            buildFile = fs.absPath(config.buildFile);\n\n            //Find the build file, and make sure it exists, if this is a build\n            //that has a build profile, and not just command line args with an in=path\n            if (!fs.exists(buildFile)) {\n                throw new Error(\"ERROR: build file does not exist: \" + buildFile);\n            }\n\n            absFilePath = config.baseUrl = fs.absPath(fs.parent(buildFile));\n\n            //Load build file options.\n            buildFileContents = fs.readFile(buildFile);\n            try {\n                //Be a bit lenient in the file ending in a ; or ending with\n                //a //# sourceMappingUrl comment, mostly for compiled languages\n                //that create a config, like typescript.\n                buildFileContents = buildFileContents\n                                    .replace(/\\/\\/\\#[^\\n\\r]+[\\n\\r]*$/, '')\n                                    .trim()\n                                    .replace(/;$/, '');\n\n                buildFileConfig = eval(\"(\" + buildFileContents + \")\");\n                build.makeAbsConfig(buildFileConfig, absFilePath,fs);\n\n                //Mix in the config now so that items in mainConfigFile can\n                //be resolved relative to them if necessary, like if appDir\n                //is set here, but the baseUrl is in mainConfigFile. Will\n                //re-mix in the same build config later after mainConfigFile\n                //is processed, since build config should take priority.\n                mixConfig(config, buildFileConfig);\n            } catch (e) {\n                throw new Error(\"Build file \" + buildFile + \" is malformed: \" + e);\n            }\n        }\n\n        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);\n        if (mainConfigFile) {\n            if (typeof mainConfigFile === 'string') {\n                mainConfigFile = [mainConfigFile];\n            }\n\n            mainConfigFile.forEach(function (configFile) {\n                configFile = build.makeAbsPath(configFile, absFilePath,fs);\n                if (!fs.exists(configFile)) {\n                    throw new Error(configFile + ' does not exist.');\n                }\n                try {\n                    mainConfig = parse.findConfig(fs.readFile(configFile)).config;\n                } catch (configError) {\n                    throw new Error('The config in mainConfigFile ' +\n                            configFile +\n                            ' cannot be used because it cannot be evaluated' +\n                            ' correctly while running in the optimizer. Try only' +\n                            ' using a config that is also valid JSON, or do not use' +\n                            ' mainConfigFile and instead copy the config values needed' +\n                            ' into a build file or command line arguments given to the optimizer.\\n' +\n                            'Source error from parsing: ' + configFile + ': ' + configError);\n                }\n                if (mainConfig) {\n                    mainConfigPath = configFile.substring(0, configFile.lastIndexOf('/'));\n\n                    //Add in some existing config, like appDir, since they can be\n                    //used inside the configFile -- paths and baseUrl are\n                    //relative to them.\n                    if (config.appDir && !mainConfig.appDir) {\n                        mainConfig.appDir = config.appDir;\n                    }\n\n                    //If no baseUrl, then use the directory holding the main config.\n                    if (!mainConfig.baseUrl) {\n                        mainConfig.baseUrl = mainConfigPath;\n                    }\n\n                    build.makeAbsConfig(mainConfig, mainConfigPath,fs);\n                    mixConfig(config, mainConfig);\n                }\n            });\n        }\n\n        //Mix in build file config, but only after mainConfig has been mixed in.\n        //Since this is a re-application, skip array merging.\n        if (buildFileConfig) {\n            mixConfig(config, buildFileConfig, true);\n        }\n\n        //Re-apply the override config values. Command line\n        //args should take precedence over build file values.\n        //Since this is a re-application, skip array merging.\n        mixConfig(config, cfg, true);\n\n        //Fix paths to full paths so that they can be adjusted consistently\n        //lately to be in the output area.\n        lang.eachProp(config.paths, function (value, prop) {\n            if (lang.isArray(value)) {\n                throw new Error('paths fallback not supported in optimizer. ' +\n                                'Please provide a build config path override ' +\n                                'for ' + prop);\n            }\n            config.paths[prop] = build.makeAbsPath(value, config.baseUrl,fs);\n        });\n\n        //Set final output dir\n        if (hasProp(config, \"baseUrl\")) {\n            if (config.appDir) {\n                if (!config.originalBaseUrl) {\n                    throw new Error('Please set a baseUrl in the build config');\n                }\n                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir,fs);\n            } else {\n                config.dirBaseUrl = config.dir || config.baseUrl;\n            }\n            //Make sure dirBaseUrl ends in a slash, since it is\n            //concatenated with other strings.\n            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);\n        }\n\n        if (config.bundlesConfigOutFile) {\n            if (!config.dir) {\n                throw new Error('bundlesConfigOutFile can only be used with optimizations ' +\n                                'that use \"dir\".');\n            }\n            config.bundlesConfigOutFile = build.makeAbsPath(config.bundlesConfigOutFile, config.dir,fs);\n        }\n\n        //If out=stdout, write output to STDOUT instead of a file.\n        ///if (config.out && config.out === 'stdout') {\n        ///    config.out = function (content) {\n        ///        var e = env.get();\n        ///        if (e === 'rhino') {\n        ///            var out = new java.io.PrintStream(java.lang.System.out, true, 'UTF-8');\n        ///            out.println(content);\n        ///        } else if (e === 'node') {\n        ///            process.stdout.write(content, 'utf8');\n        ///        } else {\n        ///            console.log(content);\n        ///        }\n        ///    };\n        ///}\n\n        //Check for errors in config\n        if (config.main) {\n            throw new Error('\"main\" passed as an option, but the ' +\n                            'supported option is called \"name\".');\n        }\n        if (config.out && !config.name && !config.modules && !config.include &&\n                !config.cssIn) {\n            throw new Error('Missing either a \"name\", \"include\" or \"modules\" ' +\n                            'option');\n        }\n        if (config.cssIn) {\n            if (config.dir || config.appDir) {\n                throw new Error('cssIn is only for the output of single file ' +\n                    'CSS optimizations and is not compatible with \"dir\" or \"appDir\" configuration.');\n            }\n            if (!config.out) {\n                throw new Error('\"out\" option missing.');\n            }\n        }\n        if (!config.cssIn && !config.baseUrl) {\n            //Just use the current directory as the baseUrl\n            config.baseUrl = './';\n        }\n        if (!config.out && !config.dir) {\n            throw new Error('Missing either an \"out\" or \"dir\" config value. ' +\n                            'If using \"appDir\" for a full project optimization, ' +\n                            'use \"dir\". If you want to optimize to one file, ' +\n                            'use \"out\".');\n        }\n        if (config.appDir && config.out) {\n            throw new Error('\"appDir\" is not compatible with \"out\". Use \"dir\" ' +\n                            'instead. appDir is used to copy whole projects, ' +\n                            'where \"out\" with \"baseUrl\" is used to just ' +\n                            'optimize to one file.');\n        }\n        if (config.out && config.dir) {\n            throw new Error('The \"out\" and \"dir\" options are incompatible.' +\n                            ' Use \"out\" if you are targeting a single file' +\n                            ' for optimization, and \"dir\" if you want the appDir' +\n                            ' or baseUrl directories optimized.');\n        }\n\n\n        if (config.dir) {\n            // Make sure the output dir is not set to a parent of the\n            // source dir or the same dir, as it will result in source\n            // code deletion.\n            if (!config.allowSourceOverwrites && (config.dir === config.baseUrl ||\n                config.dir === config.appDir ||\n                (config.baseUrl && build.makeRelativeFilePath(config.dir,\n                                           config.baseUrl,fs).indexOf('..') !== 0) ||\n                (config.appDir &&\n                    build.makeRelativeFilePath(config.dir, config.appDir,fs).indexOf('..') !== 0))) {\n                throw new Error('\"dir\" is set to a parent or same directory as' +\n                                ' \"appDir\" or \"baseUrl\". This can result in' +\n                                ' the deletion of source code. Stopping. If' +\n                                ' you want to allow possible overwriting of' +\n                                ' source code, set \"allowSourceOverwrites\"' +\n                                ' to true in the build config, but do so at' +\n                                ' your own risk. In that case, you may want' +\n                                ' to also set \"keepBuildDir\" to true.');\n            }\n        }\n\n        if (config.insertRequire && !lang.isArray(config.insertRequire)) {\n            throw new Error('insertRequire should be a list of module IDs' +\n                            ' to insert in to a require([]) call.');\n        }\n\n        //Support older configs with uglify2 settings, but now that uglify1 has\n        //been removed, just translate it to 'uglify' settings.\n        if (config.optimize === 'uglify2') {\n            config.optimize = 'uglify';\n        }\n        if (config.uglify2) {\n            config.uglify = config.uglify2;\n            delete config.uglify2;\n        }\n\n        if (config.generateSourceMaps) {\n            if (config.preserveLicenseComments && !(config.optimize === 'none' || config.optimize === 'uglify')) {\n                throw new Error('Cannot use preserveLicenseComments and ' +\n                    'generateSourceMaps together, unless optimize is set ' +\n                    'to \\'uglify\\'. Either explicitly set preserveLicenseComments ' +\n                    'to false (default is true) or turn off generateSourceMaps. ' +\n                    'If you want source maps with license comments, see: ' +\n                    'http://requirejs.org/docs/errors.html#sourcemapcomments');\n            } else if (config.optimize !== 'none' &&\n                       config.optimize !== 'closure' &&\n                       config.optimize !== 'uglify') {\n                //Allow optimize: none to pass, since it is useful when toggling\n                //minification on and off to debug something, and it implicitly\n                //works, since it does not need a source map.\n                throw new Error('optimize: \"' + config.optimize +\n                    '\" does not support generateSourceMaps.');\n            }\n        }\n\n        if ((config.name || config.include) && !config.modules) {\n            //Just need to build one file, but may be part of a whole appDir/\n            //baseUrl copy, but specified on the command line, so cannot do\n            //the modules array setup. So create a modules section in that\n            //case.\n            config.modules = [\n                {\n                    name: config.name,\n                    out: config.out,\n                    create: config.create,\n                    include: config.include,\n                    exclude: config.exclude,\n                    excludeShallow: config.excludeShallow,\n                    insertRequire: config.insertRequire,\n                    stubModules: config.stubModules\n                }\n            ];\n            delete config.stubModules;\n        } else if (config.modules && config.out) {\n            throw new Error('If the \"modules\" option is used, then there ' +\n                            'should be a \"dir\" option set and \"out\" should ' +\n                            'not be used since \"out\" is only for single file ' +\n                            'optimization output.');\n        } else if (config.modules && config.name) {\n            throw new Error('\"name\" and \"modules\" options are incompatible. ' +\n                            'Either use \"name\" if doing a single file ' +\n                            'optimization, or \"modules\" if you want to target ' +\n                            'more than one file for optimization.');\n        }\n\n        if (config.out && !config.cssIn) {\n            //Just one file to optimize.\n\n            //Does not have a build file, so set up some defaults.\n            //Optimizing CSS should not be allowed, unless explicitly\n            //asked for on command line. In that case the only task is\n            //to optimize a CSS file.\n            if (!cfg.optimizeCss) {\n                config.optimizeCss = \"none\";\n            }\n        }\n\n        //Normalize cssPrefix\n        if (config.cssPrefix) {\n            //Make sure cssPrefix ends in a slash\n            config.cssPrefix = endsWithSlash(config.cssPrefix);\n        } else {\n            config.cssPrefix = '';\n        }\n\n        //Cycle through modules and normalize\n        if (config.modules && config.modules.length) {\n            config.modules.forEach(function (mod) {\n                if (lang.isArray(mod) || typeof mod === 'string' || !mod) {\n                    throw new Error('modules config item is malformed: it should' +\n                                    ' be an object with a \\'name\\' property.');\n                }\n\n                //Combine any local stubModules with global values.\n                if (config.stubModules) {\n                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);\n                }\n\n                //Create a hash lookup for the stubModules config to make lookup\n                //cheaper later.\n                if (mod.stubModules) {\n                    mod.stubModules._byName = {};\n                    mod.stubModules.forEach(function (id) {\n                        mod.stubModules._byName[id] = true;\n                    });\n                }\n\n                // Legacy command support, which allowed a single string ID\n                // for include.\n                if (typeof mod.include === 'string') {\n                    mod.include = [mod.include];\n                }\n\n                //Allow wrap config in overrides, but normalize it.\n                if (mod.override) {\n                    normalizeWrapConfig(mod.override, absFilePath);\n                }\n            });\n        }\n\n        normalizeWrapConfig(config, absFilePath);\n\n        //Do final input verification\n        if (config.context) {\n            throw new Error('The build argument \"context\" is not supported' +\n                            ' in a build. It should only be used in web' +\n                            ' pages.');\n        }\n\n        //Set up normalizeDirDefines. If not explicitly set, if optimize \"none\",\n        //set to \"skip\" otherwise set to \"all\".\n        if (!hasProp(config, 'normalizeDirDefines')) {\n            if (config.optimize === 'none' || config.skipDirOptimize) {\n                config.normalizeDirDefines = 'skip';\n            } else {\n                config.normalizeDirDefines = 'all';\n            }\n        }\n\n        //Set fs.fileExclusionRegExp if desired\n        if (hasProp(config, 'fileExclusionRegExp')) {\n            if (typeof config.fileExclusionRegExp === \"string\") {\n                fs.exclusionRegExp = new RegExp(config.fileExclusionRegExp);\n            } else {\n                fs.exclusionRegExp = config.fileExclusionRegExp;\n            }\n        } else if (hasProp(config, 'dirExclusionRegExp')) {\n            //Set fs.dirExclusionRegExp if desired, this is the old\n            //name for fileExclusionRegExp before 1.0.2. Support for backwards\n            //compatibility\n            fs.exclusionRegExp = config.dirExclusionRegExp;\n        }\n\n        //Track the deps, but in a different key, so that they are not loaded\n        //as part of config seeding before all config is in play (#648). Was\n        //going to merge this in with \"include\", but include is added after\n        //the \"name\" target. To preserve what r.js has done previously, make\n        //sure \"deps\" comes before the \"name\".\n        if (config.deps) {\n            config._depsInclude = config.deps;\n        }\n\n\n        //Remove things that may cause problems in the build.\n        //deps already merged above\n        delete config.deps;\n        delete config.jQuery;\n        delete config.enforceDefine;\n        delete config.urlArgs;\n\n        return config;\n    };\n\n    /**\n     * finds the module being built/optimized with the given moduleName,\n     * or returns null.\n     * @param {String} moduleName\n     * @param {Array} modules\n     * @returns {Object} the module object from the build profile, or null.\n     */\n    build.findBuildModule = function (moduleName, modules) {\n        var i, module;\n        for (i = 0; i < modules.length; i++) {\n            module = modules[i];\n            if (module.name === moduleName) {\n                return module;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Removes a module name and path from a layer, if it is supposed to be\n     * excluded from the layer.\n     * @param {String} moduleName the name of the module\n     * @param {String} path the file path for the module\n     * @param {Object} layer the layer to remove the module/path from\n     */\n    build.removeModulePath = function (module, path, layer) {\n        var index = layer.buildFilePaths.indexOf(path);\n        if (index !== -1) {\n            layer.buildFilePaths.splice(index, 1);\n        }\n    };\n\n    /**\n     * Uses the module build config object to trace the dependencies for the\n     * given module.\n     *\n     * @param {Object} module the module object from the build config info.\n     * @param {Object} config the build config object.\n     * @param {Object} [baseLoaderConfig] the base loader config to use for env resets.\n     *\n     * @returns {Object} layer information about what paths and modules should\n     * be in the flattened module.\n     */\n    build.traceDependencies = function (module, config, baseLoaderConfig) {\n        var include, override, layer, context, oldContext,\n            rawTextByIds,\n            syncChecks = {\n                rhino: true,\n                node: true,\n                xpconnect: true\n            },\n            deferred = prim();\n\n        //Reset some state set up in requirePatch.js, and clean up require's\n        //current context.\n        oldContext = require._buildReset();\n\n        //Grab the reset layer and context after the reset, but keep the\n        //old config to reuse in the new context.\n        layer = require._layer;\n        context = layer.context;\n\n        //Put back basic config, use a fresh object for it.\n        if (baseLoaderConfig) {\n            require(copyConfig(baseLoaderConfig));\n        }\n\n        logger.trace(\"\\nTracing dependencies for: \" + (module.name ||\n                     (typeof module.out === 'function' ? 'FUNCTION' : module.out)));\n        include = config._depsInclude ||  [];\n        include = include.concat(module.name && !module.create ? [module.name] : []);\n        if (module.include) {\n            include = include.concat(module.include);\n        }\n\n        //If there are overrides to basic config, set that up now.;\n        if (module.override) {\n            if (baseLoaderConfig) {\n                override = build.createOverrideConfig(baseLoaderConfig, module.override);\n            } else {\n                override = copyConfig(module.override);\n            }\n            require(override);\n        }\n\n        //Now, populate the rawText cache with any values explicitly passed in\n        //via config.\n        rawTextByIds = require.s.contexts._.config.rawText;\n        if (rawTextByIds) {\n            lang.eachProp(rawTextByIds, function (contents, id) {\n                var url = require.toUrl(id) + '.js';\n                require._cachedRawText[url] = contents;\n            });\n        }\n\n\n        //Configure the callbacks to be called.\n        deferred.reject.__requireJsBuild = true;\n\n        //Use a wrapping function so can check for errors.\n        function includeFinished(value) {\n            //If a sync build environment, check for errors here, instead of\n            //in the then callback below, since some errors, like two IDs pointed\n            //to same URL but only one anon ID will leave the loader in an\n            //unresolved state since a setTimeout cannot be used to check for\n            //timeout.\n            var hasError = false;\n            if (syncChecks[config.env.name]) {\n                try {\n                    build.checkForErrors(context, layer);\n                } catch (e) {\n                    hasError = true;\n                    deferred.reject(e);\n                }\n            }\n\n            if (!hasError) {\n                deferred.resolve(value);\n            }\n        }\n        includeFinished.__requireJsBuild = true;\n\n        //Figure out module layer dependencies by calling require to do the work.\n        require(include, includeFinished, deferred.reject);\n\n        // If a sync env, then with the \"two IDs to same anon module path\"\n        // issue, the require never completes, need to check for errors\n        // here.\n        if (syncChecks[config.env.name]) {\n            build.checkForErrors(context, layer);\n        }\n\n        return deferred.promise.then(function () {\n            //Reset config\n            if (module.override && baseLoaderConfig) {\n                require(copyConfig(baseLoaderConfig));\n            }\n\n            build.checkForErrors(context, layer);\n\n            return layer;\n        });\n    };\n\n    build.checkForErrors = function (context, layer) {\n        //Check to see if it all loaded. If not, then throw, and give\n        //a message on what is left.\n        var id, prop, mod, idParts, pluginId, pluginResources,\n            errMessage = '',\n            failedPluginMap = {},\n            failedPluginIds = [],\n            errIds = [],\n            errUrlMap = {},\n            errUrlConflicts = {},\n            hasErrUrl = false,\n            hasUndefined = false,\n            defined = context.defined,\n            registry = context.registry;\n\n        function populateErrUrlMap(id, errUrl, skipNew) {\n            // Loader plugins do not have an errUrl, so skip them.\n            if (!errUrl) {\n                return;\n            }\n\n            if (!skipNew) {\n                errIds.push(id);\n            }\n\n            if (errUrlMap[errUrl]) {\n                hasErrUrl = true;\n                //This error module has the same URL as another\n                //error module, could be misconfiguration.\n                if (!errUrlConflicts[errUrl]) {\n                    errUrlConflicts[errUrl] = [];\n                    //Store the original module that had the same URL.\n                    errUrlConflicts[errUrl].push(errUrlMap[errUrl]);\n                }\n                errUrlConflicts[errUrl].push(id);\n            } else if (!skipNew) {\n                errUrlMap[errUrl] = id;\n            }\n        }\n\n        for (id in registry) {\n            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {\n                hasUndefined = true;\n                mod = getOwn(registry, id);\n                idParts = id.split('!');\n                pluginId = idParts[0];\n\n                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {\n                    populateErrUrlMap(id, mod.map.url);\n                }\n\n                //Look for plugins that did not call load()\n                //But skip plugin IDs that were already inlined and called\n                //define() with a name.\n                if (!hasProp(layer.modulesWithNames, id) && idParts.length > 1) {\n                    if (falseProp(failedPluginMap, pluginId)) {\n                        failedPluginIds.push(pluginId);\n                    }\n                    pluginResources = failedPluginMap[pluginId];\n                    if (!pluginResources) {\n                        pluginResources = failedPluginMap[pluginId] = [];\n                    }\n                    pluginResources.push(id + (mod.error ? ': ' + mod.error : ''));\n                }\n            }\n        }\n\n        // If have some modules that are not defined/stuck in the registry,\n        // then check defined modules for URL overlap.\n        if (hasUndefined) {\n            for (id in defined) {\n                if (hasProp(defined, id) && id.indexOf('!') === -1) {\n                    populateErrUrlMap(id, require.toUrl(id) + '.js', true);\n                }\n            }\n        }\n\n        if (errIds.length || failedPluginIds.length) {\n            if (failedPluginIds.length) {\n                errMessage += 'Loader plugin' +\n                    (failedPluginIds.length === 1 ? '' : 's') +\n                    ' did not call ' +\n                    'the load callback in the build:\\n' +\n                    failedPluginIds.map(function (pluginId) {\n                        var pluginResources = failedPluginMap[pluginId];\n                        return pluginId + ':\\n  ' + pluginResources.join('\\n  ');\n                    }).join('\\n') + '\\n';\n            }\n            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');\n\n            if (hasErrUrl) {\n                errMessage += '\\nThe following modules share the same URL. This ' +\n                              'could be a misconfiguration if that URL only has ' +\n                              'one anonymous module in it:';\n                for (prop in errUrlConflicts) {\n                    if (hasProp(errUrlConflicts, prop)) {\n                        errMessage += '\\n' + prop + ': ' +\n                                      errUrlConflicts[prop].join(', ');\n                    }\n                }\n            }\n            throw new Error(errMessage);\n        }\n    };\n\n    build.createOverrideConfig = function (config, override) {\n        var cfg = copyConfig(config),\n            oride = copyConfig(override);\n\n        lang.eachProp(oride, function (value, prop) {\n            if (hasProp(build.objProps, prop)) {\n                //An object property, merge keys. Start a new object\n                //so that source object in config does not get modified.\n                cfg[prop] = {};\n                lang.mixin(cfg[prop], config[prop], true);\n                lang.mixin(cfg[prop], override[prop], true);\n            } else {\n                cfg[prop] = override[prop];\n            }\n        });\n\n        return cfg;\n    };\n\n    /**\n     * Uses the module build config object to create an flattened version\n     * of the module, with deep dependencies included.\n     *\n     * @param {Object} module the module object from the build config info.\n     *\n     * @param {Object} layer the layer object returned from build.traceDependencies.\n     *\n     * @param {Object} the build config object.\n     *\n     * @returns {Object} with two properties: \"text\", the text of the flattened\n     * module, and \"buildText\", a string of text representing which files were\n     * included in the flattened module text.\n     */\n    build.flattenModule = function (module, layer, config) {\n        var fileContents, sourceMapGenerator,\n            sourceMapBase,\n            buildFileContents = '',\n            fs = config.env.fs;\n\n        return prim().start(function () {\n            var reqIndex, currContents, fileForSourceMap,\n                moduleName, shim, packageName,\n                parts, builder, writeApi,\n                namespace, namespaceWithDot, stubModulesByName,\n                context = layer.context,\n                onLayerEnds = [],\n                onLayerEndAdded = {},\n                pkgsMainMap = {};\n\n            //Use override settings, particularly for pragmas\n            //Do this before the var readings since it reads config values.\n            if (module.override) {\n                config = build.createOverrideConfig(config, module.override);\n            }\n\n            namespace = config.namespace || '';\n            namespaceWithDot = namespace ? namespace + '.' : '';\n            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};\n\n            //Start build output for the module.\n            module.onCompleteData = {\n                name: module.name,\n                path: (config.dir ? module._buildPath.replace(config.dir, \"\") : module._buildPath),\n                included: []\n            };\n\n            buildFileContents += \"\\n\" +\n                                  module.onCompleteData.path +\n                                 \"\\n----------------\\n\";\n\n            //If there was an existing file with require in it, hoist to the top.\n            if (layer.existingRequireUrl) {\n                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);\n                if (reqIndex !== -1) {\n                    layer.buildFilePaths.splice(reqIndex, 1);\n                    layer.buildFilePaths.unshift(layer.existingRequireUrl);\n                }\n            }\n\n            if (config.generateSourceMaps) {\n                sourceMapBase = config.dir || config.baseUrl;\n                if (module._buildPath === 'FUNCTION') {\n                    fileForSourceMap = (module.name || module.include[0] || 'FUNCTION') + '.build.js';\n                } else if (config.out) {\n                    fileForSourceMap = module._buildPath.split('/').pop();\n                } else {\n                    fileForSourceMap = module._buildPath.replace(sourceMapBase, '');\n                }\n                sourceMapGenerator = new SourceMapGenerator({\n                    file: fileForSourceMap\n                });\n            }\n\n            //Create a reverse lookup for packages main module IDs to their package\n            //names, useful for knowing when to write out define() package main ID\n            //adapters.\n            lang.eachProp(layer.context.config.pkgs, function(value, prop) {\n                pkgsMainMap[value] = prop;\n            });\n\n            //Write the built module to disk, and build up the build output.\n            fileContents = \"\";\n            if (config.wrap && config.wrap.__startMap) {\n                config.wrap.__startMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n\n            return prim.serial(layer.buildFilePaths.map(function (path) {\n                return function () {\n                    var singleContents = '';\n\n                    moduleName = layer.buildFileToModule[path];\n\n                    //If the moduleName is a package main, then hold on to the\n                    //packageName in case an adapter needs to be written.\n                    packageName = getOwn(pkgsMainMap, moduleName);\n\n                    return prim().start(function () {\n                        //Figure out if the module is a result of a build plugin, and if so,\n                        //then delegate to that plugin.\n                        parts = context.makeModuleMap(moduleName);\n                        builder = parts.prefix && getOwn(context.defined, parts.prefix);\n                        if (builder) {\n                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {\n                                onLayerEnds.push(builder);\n                                onLayerEndAdded[parts.prefix] = true;\n                            }\n\n                            if (builder.write) {\n                                writeApi = function (input) {\n                                    singleContents += \"\\n\" + addSemiColon(input, config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n                                writeApi.asModule = function (moduleName, input) {\n                                    singleContents += \"\\n\" +\n                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {\n                                            useSourceUrl: layer.context.config.useSourceUrl\n                                        }), config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n\n                                builder.write(parts.prefix, parts.name, writeApi, {\n                                    name: module.onCompleteData.name,\n                                    path: module.onCompleteData.path\n                                });\n                            }\n                            return;\n                        } else {\n                            return prim().start(function () {\n                                if (hasProp(stubModulesByName, moduleName)) {\n                                    //Just want to insert a simple module definition instead\n                                    //of the source module. Useful for plugins that inline\n                                    //all their resources.\n                                    if (hasProp(layer.context.plugins, moduleName)) {\n                                        //Slightly different content for plugins, to indicate\n                                        //that dynamic loading will not work.\n                                        return 'define({load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});';\n                                    } else {\n                                        return 'define({});';\n                                    }\n                                } else {\n                                    return require._cacheReadAsync(path,undefined,fs);\n                                }\n                            }).then(function (text) {\n                                var hasPackageName;\n\n                                currContents = text;\n\n                                if (config.cjsTranslate &&\n                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                                    currContents = commonJs.convert(path, currContents);\n                                }\n\n                                if (config.onBuildRead) {\n                                    currContents = config.onBuildRead(moduleName, path, currContents);\n                                }\n\n                                if (packageName) {\n                                    hasPackageName = (packageName === parse.getNamedDefine(currContents));\n                                }\n\n                                if (namespace) {\n                                    currContents = pragma.namespace(currContents, namespace);\n                                }\n\n                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {\n                                    useSourceUrl: config.useSourceUrl\n                                });\n\n                                if (packageName && !hasPackageName) {\n                                    currContents = addSemiColon(currContents, config) + '\\n';\n                                    currContents += namespaceWithDot + \"define('\" +\n                                                    packageName + \"', ['\" + moduleName +\n                                                    \"'], function (main) { return main; });\\n\";\n                                }\n\n                                if (config.onBuildWrite) {\n                                    currContents = config.onBuildWrite(moduleName, path, currContents);\n                                }\n\n                                //Semicolon is for files that are not well formed when\n                                //concatenated with other content.\n                                singleContents += addSemiColon(currContents, config);\n                            });\n                        }\n                    }).then(function () {\n                        var shimDeps, shortPath = path.replace(config.dir, \"\");\n\n                        module.onCompleteData.included.push(shortPath);\n                        buildFileContents += shortPath + \"\\n\";\n\n                        //Some files may not have declared a require module, and if so,\n                        //put in a placeholder call so the require does not try to load them\n                        //after the module is processed.\n                        //If we have a name, but no defined module, then add in the placeholder.\n                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {\n                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageName && getOwn(config.shim, packageName)));\n                            if (shim) {\n                                shimDeps = lang.isArray(shim) ? shim : shim.deps;\n                                if (config.wrapShim) {\n\n                                    singleContents = '(function(root) {\\n' +\n                                                     namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '[], ') +\n                                                    'function() {\\n' +\n                                                    '  return (function() {\\n' +\n                                                             singleContents +\n                                                             // Start with a \\n in case last line is a comment\n                                                             // in the singleContents, like a sourceURL comment.\n                                                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                                                             '\\n' +\n                                                    '  }).apply(root, arguments);\\n' +\n                                                    '});\\n' +\n                                                    '}(this));\\n';\n                                } else {\n                                    singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '') +\n                                                     (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                                                     ');\\n';\n                                }\n                            } else {\n                                singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", function(){});\\n';\n                            }\n                        }\n\n                        //Add line break at end of file, instead of at beginning,\n                        //so source map line numbers stay correct, but still allow\n                        //for some space separation between files in case ASI issues\n                        //for concatenation would cause an error otherwise.\n                        singleContents += '\\n';\n\n                        //Add to the source map and to the final contents\n                        fileContents = appendToFileContents(fileContents, singleContents, path, config, module,\n                                                            sourceMapGenerator);\n                    });\n                };\n            })).then(function () {\n                if (onLayerEnds.length) {\n                    onLayerEnds.forEach(function (builder, index) {\n                        var path;\n                        if (typeof module.out === 'string') {\n                            path = module.out;\n                        } else if (typeof module._buildPath === 'string') {\n                            path = module._buildPath;\n                        }\n                        builder.onLayerEnd(function (input) {\n                            fileContents =\n                                appendToFileContents(fileContents, \"\\n\" + addSemiColon(input, config),\n                                                     'onLayerEnd' + index + '.js', config, module, sourceMapGenerator);\n                        }, {\n                            name: module.name,\n                            path: path\n                        });\n                    });\n                }\n\n                if (module.create) {\n                    //The ID is for a created layer. Write out\n                    //a module definition for it in case the\n                    //built file is used with enforceDefine\n                    //(#432)\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'define(\"' + module.name +\n                                                           '\", function(){});\\n', 'module-create.js', config, module,\n                                             sourceMapGenerator);\n                }\n\n                //Add a require at the end to kick start module execution, if that\n                //was desired. Usually this is only specified when using small shim\n                //loaders like almond.\n                if (module.insertRequire) {\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'require([\"' + module.insertRequire.join('\", \"') +\n                                                           '\"]);\\n', 'module-insertRequire.js', config, module,\n                                             sourceMapGenerator);\n                }\n            });\n        }).then(function () {\n            if (config.wrap && config.wrap.__endMap) {\n                config.wrap.__endMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n            return {\n                text: fileContents,\n                buildText: buildFileContents,\n                sourceMap: sourceMapGenerator ?\n                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :\n                              undefined\n            };\n        });\n    };\n\n    //Converts an JS array of strings to a string representation.\n    //Not using JSON.stringify() for Rhino's sake.\n    build.makeJsArrayString = function (ary) {\n        return '[\"' + ary.map(function (item) {\n            //Escape any double quotes, backslashes\n            return lang.jsEscape(item);\n        }).join('\",\"') + '\"]';\n    };\n\n    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {\n        var baseUrl = layer && layer.context.config.baseUrl;\n\n        function onFound(info) {\n            //Only mark this module as having a name if not a named module,\n            //or if a named module and the name matches expectations.\n            if (layer && (info.needsId || info.foundId === moduleName)) {\n                layer.modulesWithNames[moduleName] = true;\n            }\n        }\n\n        //Convert path to be a local one to the baseUrl, useful for\n        //useSourceUrl.\n        if (baseUrl) {\n            path = path.replace(baseUrl, '');\n        }\n\n        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);\n    };\n\n    return require.build = build;\n});\n\ndefine('skylark-rjs/main',[\r\n    \"./rjs\",\r\n    \"./build\",\r\n    \"./lang\",\r\n    \"./prim\",\r\n    \"./logger\",\r\n    \"./parse\",\r\n    \"./optimize\",\r\n    \"./pragma\",\r\n    \"./transform\",\r\n    \"./requirePatch\",\r\n    \"./commonJs\",\r\n    \"./source-map\"\r\n],function (\r\n    rjs,\r\n    build,\r\n    lang,\r\n    prim,\r\n    logger,\r\n    parse,\r\n    optimize,\r\n    pragma,\r\n    transform,\r\n    requirePatch,\r\n    commonJs,\r\n    sourceMap,\r\n    createRjsApi\r\n\r\n) {\r\n    'use strict';\r\n\r\n    /*return {\r\n    \tbuild,\r\n    \tlang,\r\n    \tprim,\r\n    \tlogger,\r\n    \tparse,\r\n    \toptimize,\r\n    \tpragma,\r\n    \ttransform,\r\n    \trequirePatch,\r\n    \tcommonJs,\r\n    \tsourceMap,\r\n    }\r\n    */\r\n    return rjs;\r\n\t\r\n});\ndefine('skylark-rjs', ['skylark-rjs/main'], function (main) { return main; });\n\n"]}