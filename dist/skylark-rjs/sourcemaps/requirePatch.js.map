{"version":3,"sources":["requirePatch.js"],"names":["define","pragma","parse","lang","logger","commonJs","prim","allowRun","hasProp","falseProp","getOwn","useStrictRegExp","absoluteUrlRegExp","hideResolutionConflict","require","config","fs","layer","pluginBuilderRegExp","oldNewContext","oldDef","exports","module","normalizeUrlWithBase","context","moduleName","url","jsExtRegExp","test","dir","dirBaseUrl","env","s","newContext","_cacheReset","_cachedRawText","_cachedFileContents","_cachedDefinesRequireUrls","_isSupportedBuildUrl","indexOf","ignoredUrls","info","name","oldEnable","enable","moduleProto","Module","prototype","oldInit","init","oldCallPlugin","callPlugin","nextTick","fn","needFullExec","fullExec","plugins","buildShimExports","makeShimExports","value","wrapShim","str","toString","replace","depMap","parent","id","parentId","map","mod","registry","defined","undef","apply","arguments","load","contents","pluginBuilderMatch","builderName","shim","shimExports","urlFetched","buildPathMap","buildFileToModule","start","_cacheReadAsync","undefined","then","text","cjsTranslate","convert","onBuildRead","process","existingRequireUrl","definesRequire","e1","exec","makeModuleMap","nameToUrl","insertNeedsDefine","has","findNestedDependencies","e2","Error","eval","completeLoad","e","moduleTree","push","eOuter","fileName","end","execCb","cb","args","__requireJsBuild","depMaps","this","each","bind","isDefine","parentMap","pluginMap","prefix","pluginId","pluginMod","contexts","_","_buildReset","oldContext","_layer","buildFilePaths","pathAdded","modulesWithNames","needsDefine","amd","_readFile","readFile","_fileExists","path","exists","onResourceLoad","eachProp","prop","unnormalized","originalName"],"mappings":"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","file":"../requirePatch.js","sourcesContent":["/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine([ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (require,config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw e1;\n                                        ///throw new Error('Parse error using esprima ' +\n                                        ///                'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n"]}