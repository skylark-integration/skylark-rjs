{"version":3,"sources":["pragma.js"],"names":["define","parse","logger","Temp","create","obj","mixin","prototype","prop","temp","hasOwnProperty","pragma","conditionalRegExp","useStrictRegExp","hasRegExp","configRegExp","nsWrapRegExp","apiDefRegExp","defineCheckRegExp","defineStringCheckRegExp","defineTypeFirstCheckRegExp","defineJQueryRegExp","defineHasRegExp","defineTernaryRegExp","defineExistsRegExp","defineExistsAndAmdRegExp","amdefineRegExp","removeStrict","contents","config","useStrict","replace","namespace","fileContents","ns","onLifecycleName","renameNamespace","test","indexOf","process","fileName","pluginCollector","foundIndex","startIndex","lineEndIndex","conditionLine","matches","type","marker","condition","isTrue","endRegExp","endMatches","endMarkerIndex","shouldInclude","startLength","lifecycleHas","deps","i","dep","moduleName","collectorMod","lifecyclePragmas","pragmas","hasConfig","has","kwArgs","match","skipPragmas","length","substring","eval","e","RegExp","exec","lastIndex","optimizeAllPluginResources","findDependencies","split","push","eDep","error","keepAmdefine"],"mappings":"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","file":"../pragma.js","sourcesContent":["/*jslint regexp: true, plusplus: true  */\n/*global define: false */\n\ndefine([\n    './parse', \n    './logger'\n], function (parse, logger) {\n    'use strict';\n    function Temp() {}\n\n    function create(obj, mixin) {\n        Temp.prototype = obj;\n        var temp = new Temp(), prop;\n\n        //Avoid any extra memory hanging around\n        Temp.prototype = null;\n\n        if (mixin) {\n            for (prop in mixin) {\n                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {\n                    temp[prop] = mixin[prop];\n                }\n            }\n        }\n\n        return temp; // Object\n    }\n\n    var pragma = {\n        conditionalRegExp: /(exclude|include)Start\\s*\\(\\s*[\"'](\\w+)[\"']\\s*,(.*)\\)/,\n        useStrictRegExp: /(^|[^{]\\r?\\n)['\"]use strict['\"];/g,\n        hasRegExp: /has\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n        configRegExp: /(^|[^\\.])(requirejs|require)(\\.config)\\s*\\(/g,\n        nsWrapRegExp: /\\/\\*requirejs namespace: true \\*\\//,\n        apiDefRegExp: /var requirejs,\\s*require,\\s*define;/,\n        defineCheckRegExp: /typeof(\\s+|\\s*\\(\\s*)define(\\s*\\))?\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineStringCheckRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\[\\s*[\"']amd[\"']\\s*\\]/g,\n        defineTypeFirstCheckRegExp: /\\s*[\"']function[\"']\\s*==(=?)\\s*typeof\\s+define\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineJQueryRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\.\\s*jQuery/g,\n        defineHasRegExp: /typeof\\s+define\\s*==(=)?\\s*['\"]function['\"]\\s*&&\\s*typeof\\s+define\\.amd\\s*==(=)?\\s*['\"]object['\"]\\s*&&\\s*define\\.amd/g,\n        defineTernaryRegExp: /typeof\\s+define\\s*===?\\s*['\"]function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\?\\s*define/,\n        defineExistsRegExp: /\\s+typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*/,\n        defineExistsAndAmdRegExp: /typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*/,\n        amdefineRegExp: /if\\s*\\(\\s*typeof define\\s*\\!==\\s*['\"]function['\"]\\s*\\)\\s*\\{\\s*[^\\{\\}]+amdefine[^\\{\\}]+\\}/g,\n\n        removeStrict: function (contents, config) {\n            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '$1');\n        },\n\n        namespace: function (fileContents, ns, onLifecycleName) {\n            if (ns) {\n                //Namespace require/define calls\n                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');\n\n\n                fileContents = parse.renameNamespace(fileContents, ns);\n\n                //Namespace define ternary use:\n                fileContents = fileContents.replace(pragma.defineTernaryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd ? \" + ns + \".define\");\n\n                //Namespace define jquery use:\n                fileContents = fileContents.replace(pragma.defineJQueryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd && \" + ns + \".define.amd.jQuery\");\n\n                //Namespace has.js define use:\n                fileContents = fileContents.replace(pragma.defineHasRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && typeof \" + ns + \".define.amd === 'object' && \" + ns + \".define.amd\");\n\n                //Namespace async.js define use:\n                fileContents = fileContents.replace(pragma.defineExistsAndAmdRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined' && \" + ns + \".define.amd\");\n\n                //Namespace define checks.\n                //Do these ones last, since they are a subset of the more specific\n                //checks above.\n                fileContents = fileContents.replace(pragma.defineCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define['amd']\");\n                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,\n                                                    \"'function' === typeof \" + ns + \".define && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineExistsRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined'\");\n\n                //Check for require.js with the require/define definitions\n                if (pragma.apiDefRegExp.test(fileContents) &&\n                    fileContents.indexOf(\"if (!\" + ns + \" || !\" + ns + \".requirejs)\") === -1) {\n                    //Wrap the file contents in a typeof check, and a function\n                    //to contain the API globals.\n                    fileContents = \"var \" + ns + \";(function () { if (!\" + ns + \" || !\" + ns + \".requirejs) {\\n\" +\n                                    \"if (!\" + ns + \") { \" + ns + ' = {}; } else { require = ' + ns + '; }\\n' +\n                                    fileContents +\n                                    \"\\n\" +\n                                    ns + \".requirejs = requirejs;\" +\n                                    ns + \".require = require;\" +\n                                    ns + \".define = define;\\n\" +\n                                    \"}\\n}());\";\n                }\n\n                //Finally, if the file wants a special wrapper because it ties\n                //in to the requirejs internals in a way that would not fit\n                //the above matches, do that. Look for /*requirejs namespace: true*/\n                if (pragma.nsWrapRegExp.test(fileContents)) {\n                    //Remove the pragma.\n                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');\n\n                    //Alter the contents.\n                    fileContents = '(function () {\\n' +\n                                   'var require = ' + ns + '.require,' +\n                                   'requirejs = ' + ns + '.requirejs,' +\n                                   'define = ' + ns + '.define;\\n' +\n                                   fileContents +\n                                   '\\n}());';\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * processes the fileContents for some //>> conditional statements\n         */\n        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {\n            /*jslint evil: true */\n            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,\n                matches, type, marker, condition, isTrue, endRegExp, endMatches,\n                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,\n                i, dep, moduleName, collectorMod,\n                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,\n                //Legacy arg defined to help in dojo conversion script. Remove later\n                //when dojo no longer needs conversion:\n                kwArgs = pragmas;\n\n            //Mix in a specific lifecycle scoped object, to allow targeting\n            //some pragmas/has tests to only when files are saved, or at different\n            //lifecycle events. Do not bother with kwArgs in this section, since\n            //the old dojo kwArgs were for all points in the build lifecycle.\n            if (onLifecycleName) {\n                lifecyclePragmas = config['pragmas' + onLifecycleName];\n                lifecycleHas = config['has' + onLifecycleName];\n\n                if (lifecyclePragmas) {\n                    pragmas = create(pragmas || {}, lifecyclePragmas);\n                }\n\n                if (lifecycleHas) {\n                    hasConfig = create(hasConfig || {}, lifecycleHas);\n                }\n            }\n\n            //Replace has references if desired\n            if (hasConfig) {\n                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {\n                    if (hasConfig.hasOwnProperty(test)) {\n                        return !!hasConfig[test];\n                    }\n                    return match;\n                });\n            }\n\n            if (!config.skipPragmas) {\n\n                while ((foundIndex = fileContents.indexOf(\"//>>\", startIndex)) !== -1) {\n                    //Found a conditional. Get the conditional line.\n                    lineEndIndex = fileContents.indexOf(\"\\n\", foundIndex);\n                    if (lineEndIndex === -1) {\n                        lineEndIndex = fileContents.length - 1;\n                    }\n\n                    //Increment startIndex past the line so the next conditional search can be done.\n                    startIndex = lineEndIndex + 1;\n\n                    //Break apart the conditional.\n                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);\n                    matches = conditionLine.match(pragma.conditionalRegExp);\n                    if (matches) {\n                        type = matches[1];\n                        marker = matches[2];\n                        condition = matches[3];\n                        isTrue = false;\n                        //See if the condition is true.\n                        try {\n                            isTrue = !!eval(\"(\" + condition + \")\");\n                        } catch (e) {\n                            throw \"Error in file: \" +\n                                   fileName +\n                                   \". Conditional comment: \" +\n                                   conditionLine +\n                                   \" failed with this error: \" + e;\n                        }\n\n                        //Find the endpoint marker.\n                        endRegExp = new RegExp('\\\\/\\\\/\\\\>\\\\>\\\\s*' + type + 'End\\\\(\\\\s*[\\'\"]' + marker + '[\\'\"]\\\\s*\\\\)', \"g\");\n                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));\n                        if (endMatches) {\n                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;\n\n                            //Find the next line return based on the match position.\n                            lineEndIndex = fileContents.indexOf(\"\\n\", endMarkerIndex);\n                            if (lineEndIndex === -1) {\n                                lineEndIndex = fileContents.length - 1;\n                            }\n\n                            //Should we include the segment?\n                            shouldInclude = ((type === \"exclude\" && !isTrue) || (type === \"include\" && isTrue));\n\n                            //Remove the conditional comments, and optionally remove the content inside\n                            //the conditional comments.\n                            startLength = startIndex - foundIndex;\n                            fileContents = fileContents.substring(0, foundIndex) +\n                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : \"\") +\n                                fileContents.substring(lineEndIndex + 1, fileContents.length);\n\n                            //Move startIndex to foundIndex, since that is the new position in the file\n                            //where we need to look for more conditionals in the next while loop pass.\n                            startIndex = foundIndex;\n                        } else {\n                            throw \"Error in file: \" +\n                                  fileName +\n                                  \". Cannot find end marker for conditional comment: \" +\n                                  conditionLine;\n\n                        }\n                    }\n                }\n            }\n\n            //If need to find all plugin resources to optimize, do that now,\n            //before namespacing, since the namespacing will change the API\n            //names.\n            //If there is a plugin collector, scan the file for plugin resources.\n            if (config.optimizeAllPluginResources && pluginCollector) {\n                try {\n                    deps = parse.findDependencies(fileName, fileContents);\n                    if (deps.length) {\n                        for (i = 0; i < deps.length; i++) {\n                            dep = deps[i];\n                            if (dep.indexOf('!') !== -1) {\n                                moduleName = dep.split('!')[0];\n                                collectorMod = pluginCollector[moduleName];\n                                if (!collectorMod) {\n                                 collectorMod = pluginCollector[moduleName] = [];\n                                }\n                                collectorMod.push(dep);\n                            }\n                        }\n                    }\n                } catch (eDep) {\n                    logger.error('Parse error looking for plugin resources in ' +\n                                 fileName + ', skipping.');\n                }\n            }\n\n            //Strip amdefine use for node-shared modules.\n            if (!config.keepAmdefine) {\n                fileContents = fileContents.replace(pragma.amdefineRegExp, '');\n            }\n\n            //Do namespacing\n            if (onLifecycleName === 'OnSave' && config.namespace) {\n                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);\n            }\n\n\n            return pragma.removeStrict(fileContents, config);\n        }\n    };\n\n    return pragma;\n});\n"]}