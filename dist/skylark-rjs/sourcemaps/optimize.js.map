{"version":3,"sources":["optimize.js"],"names":["define","lang","logger","parse","pragma","uglify","sourceMap","optimize","cssImportRegExp","cssCommentImportRegExp","cssUrlRegExp","protocolRegExp","SourceMapGenerator","SourceMapConsumer","cleanCssUrlQuotes","url","replace","charAt","substring","length","fixCssUrlPaths","fileName","path","contents","cssPrefix","fullMatch","urlMatch","parts","i","fixedUrlMatch","firstChar","backSlashRegExp","hasProtocol","test","trace","split","splice","join","jsFile","fileContents","outFileName","config","pluginCollector","fs","env","readFile","js","saveUtf8File","String","optimizerName","keepLines","licenseContents","process","optFunc","optimizers","Error","optConfig","generateSourceMaps","_buildSourceMap","preserveLicenseComments","getLicenseComments","e","toString","preamble","throwWhen","error","cssFile","startIndex","endIndex","comment","originalFileContents","flat","flattenCss","cssImportIgnore","included","topLevel","lastIndexOf","filePath","importList","skippedList","urlStart","importFileName","urlEnd","mediaTypes","push","indexOf","importEndIndex","importPath","fullImportFileName","importContents","apply","warn","optimizeCss","buildText","dir","map","css","startDir","result","fileList","shouldRemove","removeCombined","getFilteredFileList","pop","concat","forEach","exists","deleteFile","existingMap","resultMap","uconfig","existingMapPath","baseName","mixin","output","outSourceMap","JSON","inSourceMap","minify","saveFile","code","errorString","isSyntaxError","console"],"mappings":"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","file":"../optimize.js","sourcesContent":["/*jslint plusplus: true, nomen: true, regexp: true */\n/*global define: false */\n\ndefine([ \n    './lang', \n    './logger', \n///    'env!env/optimize', \n///    'env!env/file', \n    './parse',\n    './pragma', \n    './uglifyjs',\n    './source-map'\n],function (\n    lang,\n    logger,\n///     envOptimize, \n///     file, \n     parse,\n     pragma, \n     uglify,\n     sourceMap\n) {\n    'use strict';\n\n    var optimize,\n        cssImportRegExp = /\\@import\\s+(url\\()?\\s*([^);]+)\\s*(\\))?([\\w, ]*)(;)?/ig,\n        cssCommentImportRegExp = /\\/\\*[^\\*]*@import[^\\*]*\\*\\//g,\n        cssUrlRegExp = /\\url\\(\\s*([^\\)]+)\\s*\\)?/g,\n        protocolRegExp = /^\\w+:/,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        SourceMapConsumer = sourceMap.SourceMapConsumer,\n        es5PlusGuidance = 'If the source uses ES2015 or later syntax, please pass \"optimize: \\'none\\'\" to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.';\n\n    /**\n     * If an URL from a CSS url value contains start/end quotes, remove them.\n     * This is not done in the regexp, since my regexp fu is not that strong,\n     * and the CSS spec allows for ' and \" in the URL if they are backslash escaped.\n     * @param {String} url\n     */\n    function cleanCssUrlQuotes(url) {\n        //Make sure we are not ending in whitespace.\n        //Not very confident of the css regexps above that there will not be ending\n        //whitespace.\n        url = url.replace(/\\s+$/, \"\");\n\n        if (url.charAt(0) === \"'\" || url.charAt(0) === \"\\\"\") {\n            url = url.substring(1, url.length - 1);\n        }\n\n        return url;\n    }\n\n    function fixCssUrlPaths(fileName, path, contents, cssPrefix) {\n        return contents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {\n            var firstChar, hasProtocol, parts, i,\n                fixedUrlMatch = cleanCssUrlQuotes(urlMatch);\n\n            fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, \"/\");\n\n            //Only do the work for relative URLs. Skip things that start with / or #, or have\n            //a protocol.\n            firstChar = fixedUrlMatch.charAt(0);\n            hasProtocol = protocolRegExp.test(fixedUrlMatch);\n            if (firstChar !== \"/\" && firstChar !== \"#\" && !hasProtocol) {\n                //It is a relative URL, tack on the cssPrefix and path prefix\n                urlMatch = cssPrefix + path + fixedUrlMatch;\n            } else if (!hasProtocol) {\n                logger.trace(fileName + \"\\n  URL not a relative URL, skipping: \" + urlMatch);\n            }\n\n            //Collapse .. and .\n            parts = urlMatch.split(\"/\");\n            for (i = parts.length - 1; i > 0; i--) {\n                if (parts[i] === \".\") {\n                    parts.splice(i, 1);\n                } else if (parts[i] === \"..\") {\n                    if (i !== 0 && parts[i - 1] !== \"..\") {\n                        parts.splice(i - 1, 2);\n                        i -= 1;\n                    }\n                }\n            }\n\n            return \"url(\" + parts.join(\"/\") + \")\";\n        });\n    }\n\n    /**\n     * Inlines nested stylesheets that have @import calls in them.\n     * @param {String} fileName the file name\n     * @param {String} fileContents the file contents\n     * @param {String} cssImportIgnore comma delimited string of files to ignore\n     * @param {String} cssPrefix string to be prefixed before relative URLs\n     * @param {Object} included an object used to track the files already imported\n     */\n    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included, topLevel,config) {\n        //Find the last slash in the name.\n        fileName = fileName.replace(lang.backSlashRegExp, \"/\");\n        var endIndex = fileName.lastIndexOf(\"/\"),\n            //Make a file path based on the last slash.\n            //If no slash, so must be just a file name. Use empty string then.\n            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : \"\",\n            //store a list of merged files\n            importList = [],\n            skippedList = [],\n            fs = config.env.fs;\n\n        //First make a pass by removing any commented out @import calls.\n        fileContents = fileContents.replace(cssCommentImportRegExp, '');\n\n        //Make sure we have a delimited ignore list to make matching faster\n        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== \",\") {\n            cssImportIgnore += \",\";\n        }\n\n        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {\n            //Only process media type \"all\" or empty media type rules.\n            if (mediaTypes && ((mediaTypes.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')) !== \"all\")) {\n                skippedList.push(fileName);\n                return fullMatch;\n            }\n\n            importFileName = cleanCssUrlQuotes(importFileName);\n\n            //Ignore the file import if it is part of an ignore list.\n            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + \",\") !== -1) {\n                return fullMatch;\n            }\n\n            //Make sure we have a unix path for the rest of the operation.\n            importFileName = importFileName.replace(lang.backSlashRegExp, \"/\");\n\n            try {\n                //if a relative path, then tack on the filePath.\n                //If it is not a relative path, then the readFile below will fail,\n                //and we will just skip that import.\n                var fullImportFileName = importFileName.charAt(0) === \"/\" ? importFileName : filePath + importFileName,\n                    importContents = fs.readFile(fullImportFileName),\n                    importEndIndex, importPath, flat;\n\n                //Skip the file if it has already been included.\n                if (included[fullImportFileName]) {\n                    return '';\n                }\n                included[fullImportFileName] = true;\n\n                //Make sure to flatten any nested imports.\n                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included,false,config);\n                importContents = flat.fileContents;\n\n                if (flat.importList.length) {\n                    importList.push.apply(importList, flat.importList);\n                }\n                if (flat.skippedList.length) {\n                    skippedList.push.apply(skippedList, flat.skippedList);\n                }\n\n                //Make the full import path\n                importEndIndex = importFileName.lastIndexOf(\"/\");\n\n                //Make a file path based on the last slash.\n                //If no slash, so must be just a file name. Use empty string then.\n                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : \"\";\n\n                //fix url() on relative import (#5)\n                importPath = importPath.replace(/^\\.\\//, '');\n\n                //Modify URL paths to match the path represented by this file.\n                importContents = fixCssUrlPaths(importFileName, importPath, importContents, cssPrefix);\n\n                importList.push(fullImportFileName);\n                return importContents;\n            } catch (e) {\n                logger.warn(fileName + \"\\n  Cannot inline css import, skipping: \" + importFileName);\n                return fullMatch;\n            }\n        });\n\n        if (cssPrefix && topLevel) {\n            //Modify URL paths to match the path represented by this file.\n            fileContents = fixCssUrlPaths(fileName, '', fileContents, cssPrefix);\n        }\n\n        return {\n            importList : importList,\n            skippedList: skippedList,\n            fileContents : fileContents\n        };\n    }\n\n    optimize = {\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file to optimize\n         * @param {String} fileContents the contents to optimize. If this is\n         * a null value, then fileName will be used to read the fileContents.\n         * @param {String} outFileName the name of the file to use for the\n         * saved optimized content.\n         * @param {Object} config the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var fs = config.env.fs;\n            if (!fileContents) {\n                fileContents = fs.readFile(fileName);\n            }\n\n            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);\n\n            fs.saveUtf8File(outFileName, fileContents);\n        },\n\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file that matches the\n         * fileContents.\n         * @param {String} fileContents the string of JS to optimize.\n         * @param {Object} [config] the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        js: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var optFunc, optConfig,\n                parts = (String(config.optimize)).split('.'),\n                optimizerName = parts[0],\n                keepLines = parts[1] === 'keepLines',\n                licenseContents = '';\n\n            config = config || {};\n\n            //Apply pragmas/namespace renaming\n            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n\n            //Optimize the JS files if asked.\n            if (optimizerName && optimizerName !== 'none') {\n                ///optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n                optFunc = optimize.optimizers[optimizerName];\n                if (!optFunc) {\n                    throw new Error('optimizer with name of \"' +\n                                    optimizerName +\n                                    '\" not found for this environment');\n                }\n\n                optConfig = config[optimizerName] || {};\n                if (config.generateSourceMaps) {\n                    optConfig.generateSourceMaps = !!config.generateSourceMaps;\n                    optConfig._buildSourceMap = config._buildSourceMap;\n                }\n                ///optConfig.env = config.env;\n\n                try {\n                    if (config.preserveLicenseComments) {\n                        //Pull out any license comments for prepending after optimization.\n                        try {\n                            licenseContents = parse.getLicenseComments(fileName, fileContents);\n                        } catch (e) {\n                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n                        }\n                    }\n\n                    if (config.generateSourceMaps && licenseContents) {\n                        optConfig.preamble = licenseContents;\n                        licenseContents = '';\n                    }\n\n                    fileContents = licenseContents + optFunc(fileName,\n                                                             fileContents,\n                                                             outFileName,\n                                                             keepLines,\n                                                             optConfig,\n                                                             config.env.fs);\n                    if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n                        config._buildSourceMap = optConfig._buildSourceMap;\n                    }\n                } catch (e) {\n                    if (config.throwWhen && config.throwWhen.optimize) {\n                        throw e;\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            } else {\n                if (config._buildSourceMap) {\n                    config._buildSourceMap = null;\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * Optimizes one CSS file, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} fileName the path to the CSS file to optimize\n         * @param {String} outFileName the path to save the optimized file.\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        cssFile: function (fileName, outFileName, config) {\n            var fs = config.env.fs;\n            //Read in the file. Make sure we have a JS string.\n            var originalFileContents = fs.readFile(fileName),\n                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}, true,config),\n                //Do not use the flattened CSS if there was one that was skipped.\n                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,\n                startIndex, endIndex, buildText, comment;\n\n            if (flat.skippedList.length) {\n                logger.warn('Cannot inline @imports for ' + fileName +\n                            ',\\nthe following files had media queries in them:\\n' +\n                            flat.skippedList.join('\\n'));\n            }\n\n            //Do comment removal.\n            try {\n                if (config.optimizeCss.indexOf(\".keepComments\") === -1) {\n                    startIndex = 0;\n                    //Get rid of comments.\n                    while ((startIndex = fileContents.indexOf(\"/*\", startIndex)) !== -1) {\n                        endIndex = fileContents.indexOf(\"*/\", startIndex + 2);\n                        if (endIndex === -1) {\n                            throw \"Improper comment in CSS file: \" + fileName;\n                        }\n                        comment = fileContents.substring(startIndex, endIndex);\n\n                        if (config.preserveLicenseComments &&\n                            (comment.indexOf('license') !== -1 ||\n                             comment.indexOf('opyright') !== -1 ||\n                             comment.indexOf('(c)') !== -1)) {\n                            //Keep the comment, just increment the startIndex\n                            startIndex = endIndex;\n                        } else {\n                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);\n                            startIndex = 0;\n                        }\n                    }\n                }\n                //Get rid of newlines.\n                if (config.optimizeCss.indexOf(\".keepLines\") === -1) {\n                    fileContents = fileContents.replace(/[\\r\\n]/g, \" \");\n                    fileContents = fileContents.replace(/\\s+/g, \" \");\n                    fileContents = fileContents.replace(/\\{\\s/g, \"{\");\n                    fileContents = fileContents.replace(/\\s\\}/g, \"}\");\n                } else {\n                    //Remove multiple empty lines.\n                    fileContents = fileContents.replace(/(\\r\\n)+/g, \"\\r\\n\");\n                    fileContents = fileContents.replace(/(\\n)+/g, \"\\n\");\n                }\n                //Remove unnecessary whitespace\n                if (config.optimizeCss.indexOf(\".keepWhitespace\") === -1) {\n                    //Remove leading and trailing whitespace from lines\n                    fileContents = fileContents.replace(/^[ \\t]+/gm, \"\");\n                    fileContents = fileContents.replace(/[ \\t]+$/gm, \"\");\n                    //Remove whitespace after semicolon, colon, curly brackets and commas\n                    fileContents = fileContents.replace(/(;|:|\\{|}|,)[ \\t]+/g, \"$1\");\n                    //Remove whitespace before opening curly brackets\n                    fileContents = fileContents.replace(/[ \\t]+(\\{)/g, \"$1\");\n                    //Truncate double whitespace\n                    fileContents = fileContents.replace(/([ \\t])+/g, \"$1\");\n                    //Remove empty lines\n                    fileContents = fileContents.replace(/^[ \\t]*[\\r\\n]/gm,'');\n                }\n            } catch (e) {\n                fileContents = originalFileContents;\n                logger.error(\"Could not optimized CSS file: \" + fileName + \", error: \" + e);\n            }\n\n            fs.saveUtf8File(outFileName, fileContents);\n\n            //text output to stdout and/or written to build.txt file\n            buildText = \"\\n\"+ outFileName.replace(config.dir, \"\") +\"\\n----------------\\n\";\n            flat.importList.push(fileName);\n            buildText += flat.importList.map(function(path){\n                return path.replace(config.dir, \"\");\n            }).join(\"\\n\");\n\n            return {\n                importList: flat.importList,\n                buildText: buildText +\"\\n\"\n            };\n        },\n\n        /**\n         * Optimizes CSS files, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} startDir the path to the top level directory\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        css: function (startDir, config) {\n            var buildText = \"\",\n                importList = [],\n                shouldRemove = config.dir && config.removeCombined,\n                i, fileName, result, fileList,\n                fs = config.env.fs;\n\n            if (config.optimizeCss.indexOf(\"standard\") !== -1) {\n                fileList = fs.getFilteredFileList(startDir, /\\.css$/, true);\n                if (fileList) {\n                    for (i = 0; i < fileList.length; i++) {\n                        fileName = fileList[i];\n                        logger.trace(\"Optimizing (\" + config.optimizeCss + \") CSS file: \" + fileName);\n                        result = optimize.cssFile(fileName, fileName, config);\n                        buildText += result.buildText;\n                        if (shouldRemove) {\n                            result.importList.pop();\n                            importList = importList.concat(result.importList);\n                        }\n                    }\n                }\n\n                if (shouldRemove) {\n                    importList.forEach(function (path) {\n                        if (fs.exists(path)) {\n                            fs.deleteFile(path);\n                        }\n                    });\n                }\n            }\n            return buildText;\n        },\n\n        optimizers: {\n            uglify: function (fileName, fileContents, outFileName, keepLines, config,fs) {\n                var result, existingMap, resultMap, finalMap, sourceIndex,\n                    uconfig = {},\n                    existingMapPath = outFileName + '.map',\n                    baseName = fileName && fileName.split('/').pop();\n\n                config = config || {};\n\n                lang.mixin(uconfig, config, true);\n\n                ///uconfig.fromString = true;  // uglify 2 -> 3\n\n                if (config.preamble) {\n                    uconfig.output = {preamble: config.preamble};\n                }\n\n                ///var fs = config.env.fs;\n\n                if (config.generateSourceMaps && (outFileName || config._buildSourceMap)) {\n                    uconfig.outSourceMap = baseName + '.map';\n\n                    if (config._buildSourceMap) {\n                        existingMap = JSON.parse(config._buildSourceMap);\n                        uconfig.inSourceMap = existingMap;\n                    } else if (fs.exists(existingMapPath)) {\n                        uconfig.inSourceMap = existingMapPath;\n                        existingMap = JSON.parse(fs.readFile(existingMapPath));\n                    }\n                }\n\n                logger.trace(\"Uglify file: \" + fileName);\n\n                try {\n                    //var tempContents = fileContents.replace(/\\/\\/\\# sourceMappingURL=.*$/, '');\n                    result = uglify.minify(fileContents, uconfig, baseName + '.src.js');\n                    if (uconfig.outSourceMap && result.map) {\n                        resultMap = result.map;\n                        if (!existingMap && !config._buildSourceMap) {\n                            fs.saveFile(outFileName + '.src.js', fileContents);\n                        }\n\n                        fileContents = result.code;\n\n                        if (config._buildSourceMap) {\n                            config._buildSourceMap = resultMap;\n                        } else {\n                            fs.saveFile(outFileName + '.map', resultMap);\n                        }\n                    } else {\n                        fileContents = result.code;\n                    }\n                } catch (e) {\n                    var errorString = e.toString();\n                    var isSyntaxError = /SyntaxError/.test(errorString);\n                    console.error(e);\n                    throw new Error('Cannot uglify file: ' + fileName +\n                                    '. Skipping it. Error is:\\n' + errorString +\n                                  (isSyntaxError ? '\\n\\n' + es5PlusGuidance : ''));\n                }\n                return fileContents;\n            }\n        }\n    };\n\n    return optimize;\n});\n"]}