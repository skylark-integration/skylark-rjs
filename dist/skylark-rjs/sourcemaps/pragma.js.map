{"version":3,"sources":["pragma.js"],"names":["define","parse","logger","Temp","create","obj","mixin","prototype","prop","temp","hasOwnProperty","pragma","conditionalRegExp","useStrictRegExp","hasRegExp","configRegExp","nsWrapRegExp","apiDefRegExp","defineCheckRegExp","defineStringCheckRegExp","defineTypeFirstCheckRegExp","defineJQueryRegExp","defineHasRegExp","defineTernaryRegExp","defineExistsRegExp","defineExistsAndAmdRegExp","amdefineRegExp","removeStrict","contents","config","useStrict","replace","namespace","fileContents","ns","onLifecycleName","renameNamespace","test","indexOf","process","fileName","pluginCollector","foundIndex","startIndex","lineEndIndex","conditionLine","matches","type","marker","condition","isTrue","endRegExp","endMatches","endMarkerIndex","shouldInclude","startLength","lifecycleHas","deps","i","dep","moduleName","collectorMod","lifecyclePragmas","pragmas","hasConfig","has","kwArgs","match","skipPragmas","length","substring","eval","e","RegExp","exec","lastIndex","optimizeAllPluginResources","findDependencies","split","push","eDep","error","keepAmdefine"],"mappings":"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","file":"../pragma.js","sourcesContent":["/*jslint regexp: true, plusplus: true  */\n/*global define: false */\n\ndefine([\n    './parse', \n    './logger'\n], function (parse, logger) {\n    'use strict';\n    function Temp() {}\n\n    function create(obj, mixin) {\n        Temp.prototype = obj;\n        var temp = new Temp(), prop;\n\n        //Avoid any extra memory hanging around\n        Temp.prototype = null;\n\n        if (mixin) {\n            for (prop in mixin) {\n                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {\n                    temp[prop] = mixin[prop];\n                }\n            }\n        }\n\n        return temp; // Object\n    }\n\n    var pragma = {\n        conditionalRegExp: /(exclude|include)Start\\s*\\(\\s*[\"'](\\w+)[\"']\\s*,(.*)\\)/,\n        useStrictRegExp: /(^|[^{]\\r?\\n)['\"]use strict['\"];/g,\n        hasRegExp: /has\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n        configRegExp: /(^|[^\\.])(requirejs|require)(\\.config)\\s*\\(/g,\n        nsWrapRegExp: /\\/\\*requirejs namespace: true \\*\\//,\n        apiDefRegExp: /var requirejs,\\s*require,\\s*define;/,\n        defineCheckRegExp: /typeof(\\s+|\\s*\\(\\s*)define(\\s*\\))?\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineStringCheckRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\[\\s*[\"']amd[\"']\\s*\\]/g,\n        defineTypeFirstCheckRegExp: /\\s*[\"']function[\"']\\s*==(=?)\\s*typeof\\s+define\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineJQueryRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\.\\s*jQuery/g,\n        defineHasRegExp: /typeof\\s+define\\s*==(=)?\\s*['\"]function['\"]\\s*&&\\s*typeof\\s+define\\.amd\\s*==(=)?\\s*['\"]object['\"]\\s*&&\\s*define\\.amd/g,\n        defineTernaryRegExp: /typeof\\s+define\\s*===?\\s*['\"]function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\?\\s*define/,\n        defineExistsRegExp: /\\s+typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*/,\n        defineExistsAndAmdRegExp: /typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*/,\n        amdefineRegExp: /if\\s*\\(\\s*typeof define\\s*\\!==\\s*['\"]function['\"]\\s*\\)\\s*\\{\\s*[^\\{\\}]+amdefine[^\\{\\}]+\\}/g,\n\n        removeStrict: function (contents, config) {\n            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '$1');\n        },\n\n        namespace: function (fileContents, ns, onLifecycleName) {\n            if (ns) {\n                //Namespace require/define calls\n                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');\n\n\n                fileContents = parse.renameNamespace(fileContents, ns);\n\n                //Namespace define ternary use:\n                fileContents = fileContents.replace(pragma.defineTernaryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd ? \" + ns + \".define\");\n\n                //Namespace define jquery use:\n                fileContents = fileContents.replace(pragma.defineJQueryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd && \" + ns + \".define.amd.jQuery\");\n\n                //Namespace has.js define use:\n                fileContents = fileContents.replace(pragma.defineHasRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && typeof \" + ns + \".define.amd === 'object' && \" + ns + \".define.amd\");\n\n                //Namespace async.js define use:\n                fileContents = fileContents.replace(pragma.defineExistsAndAmdRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined' && \" + ns + \".define.amd\");\n\n                //Namespace define checks.\n                //Do these ones last, since they are a subset of the more specific\n                //checks above.\n                fileContents = fileContents.replace(pragma.defineCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define['amd']\");\n                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,\n                                                    \"'function' === typeof \" + ns + \".define && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineExistsRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined'\");\n\n                //Check for require.js with the require/define definitions\n                if (pragma.apiDefRegExp.test(fileContents) &&\n                    fileContents.indexOf(\"if (!\" + ns + \" || !\" + ns + \".requirejs)\") === -1) {\n                    //Wrap the file contents in a typeof check, and a function\n                    //to contain the API globals.\n                    fileContents = \"var \" + ns + \";(function () { if (!\" + ns + \" || !\" + ns + \".requirejs) {\\n\" +\n                                    \"if (!\" + ns + \") { \" + ns + ' = {}; } else { require = ' + ns + '; }\\n' +\n                                    fileContents +\n                                    \"\\n\" +\n                                    ns + \".requirejs = requirejs;\" +\n                                    ns + \".require = require;\" +\n                                    ns + \".define = define;\\n\" +\n                                    \"}\\n}());\";\n                }\n\n                //Finally, if the file wants a special wrapper because it ties\n                //in to the requirejs internals in a way that would not fit\n                //the above matches, do that. Look for /*requirejs namespace: true*/\n                if (pragma.nsWrapRegExp.test(fileContents)) {\n                    //Remove the pragma.\n                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');\n\n                    //Alter the contents.\n                    fileContents = '(function () {\\n' +\n                                   'var require = ' + ns + '.require,' +\n                                   'requirejs = ' + ns + '.requirejs,' +\n                                   'define = ' + ns + '.define;\\n' +\n                                   fileContents +\n                                   '\\n}());';\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * processes the fileContents for some //>> conditional statements\n         */\n        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {\n            /*jslint evil: true */\n            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,\n                matches, type, marker, condition, isTrue, endRegExp, endMatches,\n                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,\n                i, dep, moduleName, collectorMod,\n                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,\n                //Legacy arg defined to help in dojo conversion script. Remove later\n                //when dojo no longer needs conversion:\n                kwArgs = pragmas;\n\n            //Mix in a specific lifecycle scoped object, to allow targeting\n            //some pragmas/has tests to only when files are saved, or at different\n            //lifecycle events. Do not bother with kwArgs in this section, since\n            //the old dojo kwArgs were for all points in the build lifecycle.\n            if (onLifecycleName) {\n                lifecyclePragmas = config['pragmas' + onLifecycleName];\n                lifecycleHas = config['has' + onLifecycleName];\n\n                if (lifecyclePragmas) {\n                    pragmas = create(pragmas || {}, lifecyclePragmas);\n                }\n\n                if (lifecycleHas) {\n                    hasConfig = create(hasConfig || {}, lifecycleHas);\n                }\n            }\n\n            //Replace has references if desired\n            if (hasConfig) {\n                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {\n                    if (hasConfig.hasOwnProperty(test)) {\n                        return !!hasConfig[test];\n                    }\n                    return match;\n                });\n            }\n\n            if (!config.skipPragmas) {\n\n                while ((foundIndex = fileContents.indexOf(\"//>>\", startIndex)) !== -1) {\n                    //Found a conditional. Get the conditional line.\n                    lineEndIndex = fileContents.indexOf(\"\\n\", foundIndex);\n                    if (lineEndIndex === -1) {\n                        lineEndIndex = fileContents.length - 1;\n                    }\n\n                    //Increment startIndex past the line so the next conditional search can be done.\n                    startIndex = lineEndIndex + 1;\n\n                    //Break apart the conditional.\n                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);\n                    matches = conditionLine.match(pragma.conditionalRegExp);\n                    if (matches) {\n                        type = matches[1];\n                        marker = matches[2];\n                        condition = matches[3];\n                        isTrue = false;\n                        //See if the condition is true.\n                        try {\n                            isTrue = !!eval(\"(\" + condition + \")\");\n                        } catch (e) {\n                            throw \"Error in file: \" +\n                                   fileName +\n                                   \". Conditional comment: \" +\n                                   conditionLine +\n                                   \" failed with this error: \" + e;\n                        }\n\n                        //Find the endpoint marker.\n                        endRegExp = new RegExp('\\\\/\\\\/\\\\>\\\\>\\\\s*' + type + 'End\\\\(\\\\s*[\\'\"]' + marker + '[\\'\"]\\\\s*\\\\)', \"g\");\n                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));\n                        if (endMatches) {\n                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;\n\n                            //Find the next line return based on the match position.\n                            lineEndIndex = fileContents.indexOf(\"\\n\", endMarkerIndex);\n                            if (lineEndIndex === -1) {\n                                lineEndIndex = fileContents.length - 1;\n                            }\n\n                            //Should we include the segment?\n                            shouldInclude = ((type === \"exclude\" && !isTrue) || (type === \"include\" && isTrue));\n\n                            //Remove the conditional comments, and optionally remove the content inside\n                            //the conditional comments.\n                            startLength = startIndex - foundIndex;\n                            fileContents = fileContents.substring(0, foundIndex) +\n                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : \"\") +\n                                fileContents.substring(lineEndIndex + 1, fileContents.length);\n\n                            //Move startIndex to foundIndex, since that is the new position in the file\n                            //where we need to look for more conditionals in the next while loop pass.\n                            startIndex = foundIndex;\n                        } else {\n                            throw \"Error in file: \" +\n                                  fileName +\n                                  \". Cannot find end marker for conditional comment: \" +\n                                  conditionLine;\n\n                        }\n                    }\n                }\n            }\n\n            //If need to find all plugin resources to optimize, do that now,\n            //before namespacing, since the namespacing will change the API\n            //names.\n            //If there is a plugin collector, scan the file for plugin resources.\n            if (config.optimizeAllPluginResources && pluginCollector) {\n                try {\n                    deps = parse.findDependencies(fileName, fileContents);\n                    if (deps.length) {\n                        for (i = 0; i < deps.length; i++) {\n                            dep = deps[i];\n                            if (dep.indexOf('!') !== -1) {\n                                moduleName = dep.split('!')[0];\n                                collectorMod = pluginCollector[moduleName];\n                                if (!collectorMod) {\n                                 collectorMod = pluginCollector[moduleName] = [];\n                                }\n                                collectorMod.push(dep);\n                            }\n                        }\n                    }\n                } catch (eDep) {\n                    logger.error('Parse error looking for plugin resources in ' +\n                                 fileName + ', skipping.');\n                }\n            }\n\n            //Strip amdefine use for node-shared modules.\n            if (!config.keepAmdefine) {\n                fileContents = fileContents.replace(pragma.amdefineRegExp, '');\n            }\n\n            //Do namespacing\n            if (onLifecycleName === 'OnSave' && config.namespace) {\n                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);\n            }\n\n\n            return pragma.removeStrict(fileContents, config);\n        }\n    };\n\n    return pragma;\n});\n"]}