{"version":3,"sources":["transform.js"],"names":["define","esprima","parse","logger","lang","transform","baseIndentRegExp","indentRegExp","keyRegExp","bulkIndentRegExps","\n","\r\n","toTransport","namespace","moduleName","path","contents","onFound","options","astRoot","contentLines","modLine","foundAnon","scanCount","scanReset","defineInfos","applySourceUrl","useSourceUrl","jsEscape","indexOf","loc","e","trace","toString","traverse","node","args","firstArg","firstArgLoc","factoryNode","needsId","depAction","init","range","namespaceExists","type","id","name","callee","arguments","length","value","object","property","isDefineNodeWithArgs","isFnExpression","operator","argument","foundId","defineLoc","sourceUrlData","push","reverse","split","contentInsertion","startIndex","start","column","lineIndex","line","substring","forEach","info","deps","depString","getAnonDepsFromNode","map","dep","join","modifyConfig","fileContents","onConfig","details","findConfig","config","serializeConfig","quote","end","indent","match","outDentRegExp","baseIndent","startString","existingConfigString","lineReturn","lastReturnIndex","lastIndexOf","exec","RegExp","str","regExp","replace","applyIndent","objectToString","obj","totalIndent","startBrace","endBrace","nextIndent","first","undefined","isArray","each","item","i","isFunction","isRegExp","eachProp","v","prop","test"],"mappings":"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","file":"../transform.js","sourcesContent":["/*global define */\n\ndefine([ \n    './esprima', \n    './parse', \n    './logger', \n    './lang'\n],\nfunction (esprima, parse, logger, lang) {\n    'use strict';\n    var transform,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                logger.trace('toTransport skipping ' + path + ': ' +\n                             e.toString());\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            logger.trace(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n"]}