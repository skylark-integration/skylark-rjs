{"version":3,"sources":["skylark-rjs.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-rjs.js","sourcesContent":["define('skylark-rjs/rjs',[\r\n    \"skylark-langx-ns\",\r\n],function(skylark){\r\n    require.define = define;\r\n\r\n\treturn skylark.attach(\"intg.rjs\",require);\r\n});\n/*jslint plusplus: true */\n/*global define, java */\n\ndefine('skylark-rjs/lang',[],function () {\n    'use strict';\n\n    var lang, isJavaObj,\n        hasOwn = Object.prototype.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    isJavaObj = function () {\n        return false;\n    };\n\n    //Rhino, but not Nashorn (detected by importPackage not existing)\n    //Can have some strange foreign objects.\n    if (typeof java !== 'undefined' && java.lang && java.lang.Object && typeof importPackage !== 'undefined') {\n        isJavaObj = function (obj) {\n            return obj instanceof java.lang.Object;\n        };\n    }\n\n    lang = {\n        backSlashRegExp: /\\\\/g,\n        ostring: Object.prototype.toString,\n\n        isArray: Array.isArray || function (it) {\n            return lang.ostring.call(it) === \"[object Array]\";\n        },\n\n        isFunction: function(it) {\n            return lang.ostring.call(it) === \"[object Function]\";\n        },\n\n        isRegExp: function(it) {\n            return it && it instanceof RegExp;\n        },\n\n        hasProp: hasProp,\n\n        //returns true if the object does not have an own property prop,\n        //or if it does, it is a falsy value.\n        falseProp: function (obj, prop) {\n            return !hasProp(obj, prop) || !obj[prop];\n        },\n\n        //gets own property value for given prop on object\n        getOwn: function (obj, prop) {\n            return hasProp(obj, prop) && obj[prop];\n        },\n\n        _mixin: function(dest, source, override){\n            var name;\n            for (name in source) {\n                if(source.hasOwnProperty(name) &&\n                    (override || !dest.hasOwnProperty(name))) {\n                    dest[name] = source[name];\n                }\n            }\n\n            return dest; // Object\n        },\n\n        /**\n         * mixin({}, obj1, obj2) is allowed. If the last argument is a boolean,\n         * then the source objects properties are force copied over to dest.\n         */\n        mixin: function(dest){\n            var parameters = Array.prototype.slice.call(arguments),\n                override, i, l;\n\n            if (!dest) { dest = {}; }\n\n            if (parameters.length > 2 && typeof arguments[parameters.length-1] === 'boolean') {\n                override = parameters.pop();\n            }\n\n            for (i = 1, l = parameters.length; i < l; i++) {\n                lang._mixin(dest, parameters[i], override);\n            }\n            return dest; // Object\n        },\n\n        /**\n         * Does a deep mix of source into dest, where source values override\n         * dest values if a winner is needed.\n         * @param  {Object} dest destination object that receives the mixed\n         * values.\n         * @param  {Object} source source object contributing properties to mix\n         * in.\n         * @return {[Object]} returns dest object with the modification.\n         */\n        deepMix: function(dest, source) {\n            lang.eachProp(source, function (value, prop) {\n                if (typeof value === 'object' && value &&\n                    !lang.isArray(value) && !lang.isFunction(value) &&\n                    !(value instanceof RegExp)) {\n\n                    if (!dest[prop]) {\n                        dest[prop] = {};\n                    }\n                    lang.deepMix(dest[prop], value);\n                } else {\n                    dest[prop] = value;\n                }\n            });\n            return dest;\n        },\n\n        /**\n         * Does a type of deep copy. Do not give it anything fancy, best\n         * for basic object copies of objects that also work well as\n         * JSON-serialized things, or has properties pointing to functions.\n         * For non-array/object values, just returns the same object.\n         * @param  {Object} obj      copy properties from this object\n         * @param  {Object} [ignoredProps] optional object whose own properties\n         * are keys that should be ignored.\n         * @return {Object}\n         */\n        deeplikeCopy: function (obj, ignoredProps) {\n            var type, result;\n\n            if (lang.isArray(obj)) {\n                result = [];\n                obj.forEach(function(value) {\n                    result.push(lang.deeplikeCopy(value, ignoredProps));\n                });\n                return result;\n            }\n\n            type = typeof obj;\n            if (obj === null || obj === undefined || type === 'boolean' ||\n                type === 'string' || type === 'number' || lang.isFunction(obj) ||\n                lang.isRegExp(obj)|| isJavaObj(obj)) {\n                return obj;\n            }\n\n            //Anything else is an object, hopefully.\n            result = {};\n            lang.eachProp(obj, function(value, key) {\n                if (!ignoredProps || !hasProp(ignoredProps, key)) {\n                    result[key] = lang.deeplikeCopy(value, ignoredProps);\n                }\n            });\n            return result;\n        },\n\n        delegate: (function () {\n            // boodman/crockford delegation w/ cornford optimization\n            function TMP() {}\n            return function (obj, props) {\n                TMP.prototype = obj;\n                var tmp = new TMP();\n                TMP.prototype = null;\n                if (props) {\n                    lang.mixin(tmp, props);\n                }\n                return tmp; // Object\n            };\n        }()),\n\n        /**\n         * Helper function for iterating over an array. If the func returns\n         * a true value, it will break out of the loop.\n         */\n        each: function each(ary, func) {\n            if (ary) {\n                var i;\n                for (i = 0; i < ary.length; i += 1) {\n                    if (func(ary[i], i, ary)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        /**\n         * Cycles over properties in an object and calls a function for each\n         * property value. If the function returns a truthy value, then the\n         * iteration is stopped.\n         */\n        eachProp: function eachProp(obj, func) {\n            var prop;\n            for (prop in obj) {\n                if (hasProp(obj, prop)) {\n                    if (func(obj[prop], prop)) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        //Similar to Function.prototype.bind, but the \"this\" object is specified\n        //first, since it is easier to read/figure out what \"this\" will be.\n        bind: function bind(obj, fn) {\n            return function () {\n                return fn.apply(obj, arguments);\n            };\n        },\n\n        //Escapes a content string to be be a string that has characters escaped\n        //for inclusion as part of a JS string.\n        jsEscape: function (content) {\n            return content.replace(/([\"'\\\\])/g, '\\\\$1')\n                .replace(/[\\f]/g, \"\\\\f\")\n                .replace(/[\\b]/g, \"\\\\b\")\n                .replace(/[\\n]/g, \"\\\\n\")\n                .replace(/[\\t]/g, \"\\\\t\")\n                .replace(/[\\r]/g, \"\\\\r\");\n        }\n    };\n    return lang;\n});\n\n/**\n * prim 0.0.1 Copyright (c) 2012-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/prim for details\n */\n\n/*global setImmediate, process, setTimeout, define, module */\n\n//Set prime.hideResolutionConflict = true to allow \"resolution-races\"\n//in promise-tests to pass.\n//Since the goal of prim is to be a small impl for trusted code, it is\n//more important to normally throw in this case so that we can find\n//logic errors quicker.\n\ndefine('skylark-rjs/prim',[],function () {\n    'use strict';\n    var op = Object.prototype,\n        hasOwn = op.hasOwnProperty;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i]) {\n                    func(ary[i], i, ary);\n                }\n            }\n        }\n    }\n\n    function check(p) {\n        if (hasProp(p, 'e') || hasProp(p, 'v')) {\n            if (!prim.hideResolutionConflict) {\n                throw new Error('Prim promise already resolved: ' +\n                                JSON.stringify(p));\n            }\n            return false;\n        }\n        return true;\n    }\n\n    function notify(ary, value) {\n        prim.nextTick(function () {\n            each(ary, function (item) {\n                item(value);\n            });\n        });\n    }\n\n    function prim() {\n        var p,\n            ok = [],\n            fail = [];\n\n        return (p = {\n            callback: function (yes, no) {\n                if (no) {\n                    p.errback(no);\n                }\n\n                if (hasProp(p, 'v')) {\n                    prim.nextTick(function () {\n                        yes(p.v);\n                    });\n                } else {\n                    ok.push(yes);\n                }\n            },\n\n            errback: function (no) {\n                if (hasProp(p, 'e')) {\n                    prim.nextTick(function () {\n                        no(p.e);\n                    });\n                } else {\n                    fail.push(no);\n                }\n            },\n\n            finished: function () {\n                return hasProp(p, 'e') || hasProp(p, 'v');\n            },\n\n            rejected: function () {\n                return hasProp(p, 'e');\n            },\n\n            resolve: function (v) {\n                if (check(p)) {\n                    p.v = v;\n                    notify(ok, v);\n                }\n                return p;\n            },\n            reject: function (e) {\n                if (check(p)) {\n                    p.e = e;\n                    notify(fail, e);\n                }\n                return p;\n            },\n\n            start: function (fn) {\n                p.resolve();\n                return p.promise.then(fn);\n            },\n\n            promise: {\n                then: function (yes, no) {\n                    var next = prim();\n\n                    p.callback(function (v) {\n                        try {\n                            if (yes && typeof yes === 'function') {\n                                v = yes(v);\n                            }\n\n                            if (v && v.then) {\n                                v.then(next.resolve, next.reject);\n                            } else {\n                                next.resolve(v);\n                            }\n                        } catch (e) {\n                            next.reject(e);\n                        }\n                    }, function (e) {\n                        var err;\n\n                        try {\n                            if (!no || typeof no !== 'function') {\n                                next.reject(e);\n                            } else {\n                                err = no(e);\n\n                                if (err && err.then) {\n                                    err.then(next.resolve, next.reject);\n                                } else {\n                                    next.resolve(err);\n                                }\n                            }\n                        } catch (e2) {\n                            next.reject(e2);\n                        }\n                    });\n\n                    return next.promise;\n                },\n\n                fail: function (no) {\n                    return p.promise.then(null, no);\n                },\n\n                end: function () {\n                    p.errback(function (e) {\n                        throw e;\n                    });\n                }\n            }\n        });\n    };\n\n    prim.serial = function (ary) {\n        var result = prim().resolve().promise;\n        each(ary, function (item) {\n            result = result.then(function () {\n                return item();\n            });\n        });\n        return result;\n    };\n\n    prim.nextTick = typeof setImmediate === 'function' ? setImmediate :\n        (typeof process !== 'undefined' && process.nextTick ?\n            process.nextTick : (typeof setTimeout !== 'undefined' ?\n                function (fn) {\n                setTimeout(fn, 0);\n            } : function (fn) {\n        fn();\n    }));\n\n    return prim;\n});\n/*jslint nomen: false, strict: false */\n/*global define: false */\n\ndefine('skylark-rjs/logger',[],function () {\n    function print(msg,e) {\n        console.log(msg,e);\n    }\n\n    var logger = {\n        TRACE: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        SILENT: 4,\n        level: 0,\n        logPrefix: \"\",\n\n        logLevel: function( level ) {\n            this.level = level;\n        },\n\n        trace: function (message) {\n            if (this.level <= this.TRACE) {\n                this._print(message);\n            }\n        },\n\n        info: function (message) {\n            if (this.level <= this.INFO) {\n                this._print(message);\n            }\n        },\n\n        warn: function (message) {\n            if (this.level <= this.WARN) {\n                this._print(message);\n            }\n        },\n\n        error: function (message) {\n            if (this.level <= this.ERROR) {\n                this._print(message);\n            }\n        },\n\n        _print: function (message) {\n            this._sysPrint((this.logPrefix ? (this.logPrefix + \" \") : \"\") + message);\n        },\n\n        _sysPrint: function (message) {\n            print(message);\n        }\n    };\n\n    return logger;\n});\n\n/*global define, Reflect */\n\n/*\n * xpcshell has a smaller stack on linux and windows (1MB vs 9MB on mac),\n * and the recursive nature of esprima can cause it to overflow pretty\n * quickly. So favor it built in Reflect parser:\n * https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n */\ndefine('skylark-rjs/esprima',['skylark-espree'], function (esprima) {\n    return esprima;\n});\n\n/*jslint plusplus: true */\n/*global define: false */\n\ndefine('skylark-rjs/parse',[\n    './esprima', \n    './lang'\n], function (esprima, lang) {\n    'use strict';\n\n    function arrayToString(ary) {\n        var output = '[';\n        if (ary) {\n            ary.forEach(function (item, i) {\n                output += (i > 0 ? ',' : '') + '\"' + lang.jsEscape(item) + '\"';\n            });\n        }\n        output += ']';\n\n        return output;\n    }\n\n    //This string is saved off because JSLint complains\n    //about obj.arguments use, as 'reserved word'\n    var argPropName = 'arguments',\n        //Default object to use for \"scope\" checking for UMD identifiers.\n        emptyScope = {},\n        mixin = lang.mixin,\n        hasProp = lang.hasProp;\n\n    //From an esprima example for traversing its ast.\n    function traverse(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[keys[i]];\n            if (typeof child === 'object' && child !== null) {\n                if (traverse(child, visitor) === false) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    //Like traverse, but visitor returning false just\n    //stops that subtree analysis, not the rest of tree\n    //visiting.\n    function traverseBroad(object, visitor) {\n        var child;\n\n        if (!object) {\n            return;\n        }\n\n        if (visitor.call(null, object) === false) {\n            return false;\n        }\n        for (var i = 0, keys = Object.keys(object); i < keys.length; i++) {\n            child = object[key];\n            if (typeof child === 'object' && child !== null) {\n                traverseBroad(child, visitor);\n            }\n        }\n    }\n\n    /**\n     * Pulls out dependencies from an array literal with just string members.\n     * If string literals, will just return those string values in an array,\n     * skipping other items in the array.\n     *\n     * @param {Node} node an AST node.\n     *\n     * @returns {Array} an array of strings.\n     * If null is returned, then it means the input node was not a valid\n     * dependency.\n     */\n    function getValidDeps(node) {\n        if (!node || node.type !== 'ArrayExpression' || !node.elements) {\n            return;\n        }\n\n        var deps = [];\n\n        node.elements.some(function (elem) {\n            if (elem.type === 'Literal') {\n                deps.push(elem.value);\n            }\n        });\n\n        return deps.length ? deps : undefined;\n    }\n\n    // Detects regular or arrow function expressions as the desired expression\n    // type.\n    function isFnExpression(node) {\n        return (node && (node.type === 'FunctionExpression' ||\n                             node.type === 'ArrowFunctionExpression'));\n    }\n\n    /**\n     * Main parse function. Returns a string of any valid require or\n     * define/require.def calls as part of one JavaScript source string.\n     * @param {String} moduleName the module name that represents this file.\n     * It is used to create a default define if there is not one already for the\n     * file. This allows properly tracing dependencies for builds. Otherwise, if\n     * the file just has a require() call, the file dependencies will not be\n     * properly reflected: the file will come before its dependencies.\n     * @param {String} moduleName\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @param {Object} options optional options. insertNeedsDefine: true will\n     * add calls to require.needsDefine() if appropriate.\n     * @returns {String} JS source string or null, if no require or\n     * define/require.def calls are found.\n     */\n    function parse(moduleName, fileName, fileContents, options) {\n        options = options || {};\n\n        //Set up source input\n        var i, moduleCall, depString,\n            moduleDeps = [],\n            result = '',\n            moduleList = [],\n            needsDefine = true,\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (!deps) {\n                deps = [];\n            }\n\n            if (callName === 'define' && (!name || name === moduleName)) {\n                needsDefine = false;\n            }\n\n            if (!name) {\n                //If there is no module name, the dependencies are for\n                //this file/default module name.\n                moduleDeps = moduleDeps.concat(deps);\n            } else {\n                moduleList.push({\n                    name: name,\n                    deps: deps\n                });\n            }\n\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return !!options.findNestedDependencies;\n        }, options);\n\n        if (options.insertNeedsDefine && needsDefine) {\n            result += 'require.needsDefine(\"' + moduleName + '\");';\n        }\n\n        if (moduleDeps.length || moduleList.length) {\n            for (i = 0; i < moduleList.length; i++) {\n                moduleCall = moduleList[i];\n                if (result) {\n                    result += '\\n';\n                }\n\n                //If this is the main module for this file, combine any\n                //\"anonymous\" dependencies (could come from a nested require\n                //call) with this module.\n                if (moduleCall.name === moduleName) {\n                    moduleCall.deps = moduleCall.deps.concat(moduleDeps);\n                    moduleDeps = [];\n                }\n\n                depString = arrayToString(moduleCall.deps);\n                result += 'define(\"' + moduleCall.name + '\",' +\n                          depString + ');';\n            }\n            if (moduleDeps.length) {\n                if (result) {\n                    result += '\\n';\n                }\n                depString = arrayToString(moduleDeps);\n                result += 'define(\"' + moduleName + '\",' + depString + ');';\n            }\n        }\n\n        return result || null;\n    }\n\n    parse.traverse = traverse;\n    parse.traverseBroad = traverseBroad;\n    parse.isFnExpression = isFnExpression;\n\n    /**\n     * Handles parsing a file recursively for require calls.\n     * @param {Array} parentNode the AST node to start with.\n     * @param {Function} onMatch function to call on a parse match.\n     * @param {Object} [options] This is normally the build config options if\n     * it is passed.\n     * @param {Object} [fnExpScope] holds list of function expresssion\n     * argument identifiers, set up internally, not passed in\n     */\n    parse.recurse = function (object, onMatch, options, fnExpScope) {\n        //Like traverse, but skips if branches that would not be processed\n        //after has application that results in tests of true or false boolean\n        //literal values.\n        var keys, child, result, i, params, param, tempObject,\n            hasHas = options && options.has;\n\n        fnExpScope = fnExpScope || emptyScope;\n\n        if (!object) {\n            return;\n        }\n\n        //If has replacement has resulted in if(true){} or if(false){}, take\n        //the appropriate branch and skip the other one.\n        if (hasHas && object.type === 'IfStatement' && object.test.type &&\n                object.test.type === 'Literal') {\n            if (object.test.value) {\n                //Take the if branch\n                this.recurse(object.consequent, onMatch, options, fnExpScope);\n            } else {\n                //Take the else branch\n                this.recurse(object.alternate, onMatch, options, fnExpScope);\n            }\n        } else {\n            result = this.parseNode(object, onMatch, fnExpScope);\n            if (result === false) {\n                return;\n            } else if (typeof result === 'string') {\n                return result;\n            }\n\n            //Build up a \"scope\" object that informs nested recurse calls if\n            //the define call references an identifier that is likely a UMD\n            //wrapped function expression argument.\n            //Catch (function(a) {... wrappers\n            if (object.type === 'ExpressionStatement' && object.expression &&\n                    object.expression.type === 'CallExpression' && object.expression.callee &&\n                    isFnExpression(object.expression.callee)) {\n                tempObject = object.expression.callee;\n            }\n            // Catch !function(a) {... wrappers\n            if (object.type === 'UnaryExpression' && object.argument &&\n                object.argument.type === 'CallExpression' && object.argument.callee &&\n                isFnExpression(object.argument.callee)) {\n                tempObject = object.argument.callee;\n            }\n            if (tempObject && tempObject.params && tempObject.params.length) {\n                params = tempObject.params;\n                fnExpScope = mixin({}, fnExpScope, true);\n                for (i = 0; i < params.length; i++) {\n                    param = params[i];\n                    if (param.type === 'Identifier') {\n                        fnExpScope[param.name] = true;\n                    }\n                }\n            }\n\n            for (i = 0, keys = Object.keys(object); i < keys.length; i++) {\n                child = object[keys[i]];\n                if (typeof child === 'object' && child !== null) {\n                    result = this.recurse(child, onMatch, options, fnExpScope);\n                    if (typeof result === 'string' && hasProp(fnExpScope, result)) {\n                        //The result was still in fnExpScope so break. Otherwise,\n                        //was a return from a a tree that had a UMD definition,\n                        //but now out of that scope so keep siblings.\n                        break;\n                    }\n                }\n            }\n\n            //Check for an identifier for a factory function identifier being\n            //passed in as a function expression, indicating a UMD-type of\n            //wrapping.\n            if (typeof result === 'string') {\n                if (hasProp(fnExpScope, result)) {\n                    //result still in scope, keep jumping out indicating the\n                    //identifier still in use.\n                    return result;\n                }\n\n                return;\n            }\n        }\n    };\n\n    /**\n     * Determines if the file defines the require/define module API.\n     * Specifically, it looks for the `define.amd = ` expression.\n     * @param {String} fileName\n     * @param {String} fileContents\n     * @returns {Boolean}\n     */\n    parse.definesRequire = function (fileName, fileContents) {\n        var foundDefine = false,\n            foundDefineAmd = false;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            // Look for a top level declaration of a define, like\n            // var requirejs, require, define, off Program body.\n            if (node.type === 'Program' && node.body && node.body.length) {\n                foundDefine = node.body.some(function(bodyNode) {\n                    // var define\n                    if (bodyNode.type === 'VariableDeclaration') {\n                        var decls = bodyNode.declarations;\n                        if (decls) {\n                            var hasVarDefine = decls.some(function(declNode) {\n                                return (declNode.type === 'VariableDeclarator' &&\n                                        declNode.id &&\n                                        declNode.id.type === 'Identifier' &&\n                                        declNode.id.name === 'define');\n                            });\n                            if (hasVarDefine) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    // function define() {}\n                    if (bodyNode.type === 'FunctionDeclaration' &&\n                        bodyNode.id &&\n                        bodyNode.id.type === 'Identifier' &&\n                        bodyNode.id.name === 'define') {\n                        return true;\n                    }\n\n                });\n            }\n\n            // Need define variable found first, before detecting define.amd.\n            if (foundDefine && parse.hasDefineAmd(node)) {\n                foundDefineAmd = true;\n\n                //Stop traversal\n                return false;\n            }\n        });\n\n        return foundDefine && foundDefineAmd;\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped in a\n     * define(function(require, exports, module){}) wrapper. These dependencies\n     * will be added to a modified define() call that lists the dependencies\n     * on the outside of the function.\n     * @param {String} fileName\n     * @param {String|Object} fileContents: a string of contents, or an already\n     * parsed AST tree.\n     * @returns {Array} an array of module names that are dependencies. Always\n     * returns an array, but could be of length zero.\n     */\n    parse.getAnonDeps = function (fileName, fileContents) {\n        var astRoot = typeof fileContents === 'string' ?\n                      esprima.parse(fileContents) : fileContents,\n            defFunc = this.findAnonDefineFactory(astRoot);\n\n        return parse.getAnonDepsFromNode(defFunc);\n    };\n\n    /**\n     * Finds require(\"\") calls inside a CommonJS anonymous module wrapped\n     * in a define function, given an AST node for the definition function.\n     * @param {Node} node the AST node for the definition function.\n     * @returns {Array} and array of dependency names. Can be of zero length.\n     */\n    parse.getAnonDepsFromNode = function (node) {\n        var deps = [],\n            funcArgLength;\n\n        if (node) {\n            this.findRequireDepNames(node, deps);\n\n            //If no deps, still add the standard CommonJS require, exports,\n            //module, in that order, to the deps, but only if specified as\n            //function args. In particular, if exports is used, it is favored\n            //over the return value of the function, so only add it if asked.\n            funcArgLength = node.params && node.params.length;\n            if (funcArgLength) {\n                deps = (funcArgLength > 1 ? [\"require\", \"exports\", \"module\"] :\n                        [\"require\"]).concat(deps);\n            }\n        }\n        return deps;\n    };\n\n    parse.isDefineNodeWithArgs = function (node) {\n        return node && node.type === 'CallExpression' &&\n               node.callee && node.callee.type === 'Identifier' &&\n               node.callee.name === 'define' && node[argPropName];\n    };\n\n    /**\n     * Finds the function in define(function (require, exports, module){});\n     * @param {Array} node\n     * @returns {Boolean}\n     */\n    parse.findAnonDefineFactory = function (node) {\n        var match;\n\n        traverse(node, function (node) {\n            var arg0, arg1;\n\n            if (parse.isDefineNodeWithArgs(node)) {\n\n                //Just the factory function passed to define\n                arg0 = node[argPropName][0];\n                if (isFnExpression(arg0)) {\n                    match = arg0;\n                    return false;\n                }\n\n                //A string literal module ID followed by the factory function.\n                arg1 = node[argPropName][1];\n                if (arg0.type === 'Literal' && isFnExpression(arg1)) {\n                    match = arg1;\n                    return false;\n                }\n            }\n        });\n\n        return match;\n    };\n\n    /**\n     * Finds any config that is passed to requirejs. That includes calls to\n     * require/requirejs.config(), as well as require({}, ...) and\n     * requirejs({}, ...)\n     * @param {String} fileContents\n     *\n     * @returns {Object} a config details object with the following properties:\n     * - config: {Object} the config object found. Can be undefined if no\n     * config found.\n     * - range: {Array} the start index and end index in the contents where\n     * the config was found. Can be undefined if no config found.\n     * Can throw an error if the config in the file cannot be evaluated in\n     * a build context to valid JavaScript.\n     */\n    parse.findConfig = function (fileContents) {\n        /*jslint evil: true */\n        var jsConfig, foundConfig, stringData, foundRange, quote, quoteMatch,\n            quoteRegExp = /(:\\s|\\[\\s*)(['\"])/,\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        traverse(astRoot, function (node) {\n            var arg,\n                requireType = parse.hasRequire(node);\n\n            if (requireType && (requireType === 'require' ||\n                    requireType === 'requirejs' ||\n                    requireType === 'requireConfig' ||\n                    requireType === 'requirejsConfig')) {\n\n                arg = node[argPropName] && node[argPropName][0];\n\n                if (arg && arg.type === 'ObjectExpression') {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            } else {\n                arg = parse.getRequireObjectLiteral(node);\n                if (arg) {\n                    stringData = parse.nodeToString(fileContents, arg);\n                    jsConfig = stringData.value;\n                    foundRange = stringData.range;\n                    return false;\n                }\n            }\n        });\n\n        if (jsConfig) {\n            // Eval the config\n            quoteMatch = quoteRegExp.exec(jsConfig);\n            quote = (quoteMatch && quoteMatch[2]) || '\"';\n            foundConfig = eval('(' + jsConfig + ')');\n        }\n\n        return {\n            config: foundConfig,\n            range: foundRange,\n            quote: quote\n        };\n    };\n\n    /** Returns the node for the object literal assigned to require/requirejs,\n     * for holding a declarative config.\n     */\n    parse.getRequireObjectLiteral = function (node) {\n        if (node.id && node.id.type === 'Identifier' &&\n                (node.id.name === 'require' || node.id.name === 'requirejs') &&\n                node.init && node.init.type === 'ObjectExpression') {\n            return node.init;\n        }\n    };\n\n    /**\n     * Renames require/requirejs/define calls to be ns + '.' + require/requirejs/define\n     * Does *not* do .config calls though. See pragma.namespace for the complete\n     * set of namespace transforms. This function is used because require calls\n     * inside a define() call should not be renamed, so a simple regexp is not\n     * good enough.\n     * @param  {String} fileContents the contents to transform.\n     * @param  {String} ns the namespace, *not* including trailing dot.\n     * @return {String} the fileContents with the namespace applied\n     */\n    parse.renameNamespace = function (fileContents, ns) {\n        var lines,\n            locs = [],\n            astRoot = esprima.parse(fileContents, {\n                loc: true\n            });\n\n        parse.recurse(astRoot, function (callName, config, name, deps, node) {\n            locs.push(node.loc);\n            //Do not recurse into define functions, they should be using\n            //local defines.\n            return callName !== 'define';\n        }, {});\n\n        if (locs.length) {\n            lines = fileContents.split('\\n');\n\n            //Go backwards through the found locs, adding in the namespace name\n            //in front.\n            locs.reverse();\n            locs.forEach(function (loc) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = lines[lineIndex];\n\n                lines[lineIndex] = line.substring(0, startIndex) +\n                                   ns + '.' +\n                                   line.substring(startIndex,\n                                                      line.length);\n            });\n\n            fileContents = lines.join('\\n');\n        }\n\n        return fileContents;\n    };\n\n    /**\n     * Finds all dependencies specified in dependency arrays and inside\n     * simplified commonjs wrappers.\n     * @param {String} fileName\n     * @param {String} fileContents\n     *\n     * @returns {Array} an array of dependency strings. The dependencies\n     * have not been normalized, they may be relative IDs.\n     */\n    parse.findDependencies = function (fileName, fileContents, options) {\n        var dependencies = [],\n            astRoot = esprima.parse(fileContents);\n\n        parse.recurse(astRoot, function (callName, config, name, deps) {\n            if (deps) {\n                dependencies = dependencies.concat(deps);\n            }\n        }, options);\n\n        return dependencies;\n    };\n\n    /**\n     * Finds only CJS dependencies, ones that are the form\n     * require('stringLiteral')\n     */\n    parse.findCjsDependencies = function (fileName, fileContents) {\n        var dependencies = [];\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1) {\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    dependencies.push(arg.value);\n                }\n            }\n        });\n\n        return dependencies;\n    };\n\n    //function define() {}\n    parse.hasDefDefine = function (node) {\n        return node.type === 'FunctionDeclaration' && node.id &&\n                    node.id.type === 'Identifier' && node.id.name === 'define';\n    };\n\n    //define.amd = ...\n    parse.hasDefineAmd = function (node) {\n        return node && node.type === 'AssignmentExpression' &&\n            node.left && node.left.type === 'MemberExpression' &&\n            node.left.object && node.left.object.name === 'define' &&\n            node.left.property && node.left.property.name === 'amd';\n    };\n\n    //define.amd reference, as in: if (define.amd)\n    parse.refsDefineAmd = function (node) {\n        return node && node.type === 'MemberExpression' &&\n        node.object && node.object.name === 'define' &&\n        node.object.type === 'Identifier' &&\n        node.property && node.property.name === 'amd' &&\n        node.property.type === 'Identifier';\n    };\n\n    //require(), requirejs(), require.config() and requirejs.config()\n    parse.hasRequire = function (node) {\n        var callName,\n            c = node && node.callee;\n\n        if (node && node.type === 'CallExpression' && c) {\n            if (c.type === 'Identifier' &&\n                    (c.name === 'require' ||\n                    c.name === 'requirejs')) {\n                //A require/requirejs({}, ...) call\n                callName = c.name;\n            } else if (c.type === 'MemberExpression' &&\n                    c.object &&\n                    c.object.type === 'Identifier' &&\n                    (c.object.name === 'require' ||\n                        c.object.name === 'requirejs') &&\n                    c.property && c.property.name === 'config') {\n                // require/requirejs.config({}) call\n                callName = c.object.name + 'Config';\n            }\n        }\n\n        return callName;\n    };\n\n    //define()\n    parse.hasDefine = function (node) {\n        return node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define';\n    };\n\n    /**\n     * If there is a named define in the file, returns the name. Does not\n     * scan for mulitple names, just the first one.\n     */\n    parse.getNamedDefine = function (fileContents) {\n        var name;\n        traverse(esprima.parse(fileContents), function (node) {\n            if (node && node.type === 'CallExpression' && node.callee &&\n            node.callee.type === 'Identifier' &&\n            node.callee.name === 'define' &&\n            node[argPropName] && node[argPropName][0] &&\n            node[argPropName][0].type === 'Literal') {\n                name = node[argPropName][0].value;\n                return false;\n            }\n        });\n\n        return name;\n    };\n\n    /**\n     * Finds all the named define module IDs in a file.\n     */\n    parse.getAllNamedDefines = function (fileContents, excludeMap) {\n        var names = [];\n        parse.recurse(esprima.parse(fileContents),\n        function (callName, config, name, deps, node, factoryIdentifier, fnExpScope) {\n            if (callName === 'define' && name) {\n                if (!excludeMap.hasOwnProperty(name)) {\n                    names.push(name);\n                }\n            }\n\n            //If a UMD definition that points to a factory that is an Identifier,\n            //indicate processing should not traverse inside the UMD definition.\n            if (callName === 'define' && factoryIdentifier && hasProp(fnExpScope, factoryIdentifier)) {\n                return factoryIdentifier;\n            }\n\n            //If define was found, no need to dive deeper, unless\n            //the config explicitly wants to dig deeper.\n            return true;\n        }, {});\n\n        return names;\n    };\n\n    /**\n     * Determines if define(), require({}|[]) or requirejs was called in the\n     * file. Also finds out if define() is declared and if define.amd is called.\n     */\n    parse.usesAmdOrRequireJs = function (fileName, fileContents) {\n        var uses;\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type, callName, arg;\n\n            if (parse.hasDefDefine(node)) {\n                //function define() {}\n                type = 'declaresDefine';\n            } else if (parse.hasDefineAmd(node)) {\n                type = 'defineAmd';\n            } else {\n                callName = parse.hasRequire(node);\n                if (callName) {\n                    arg = node[argPropName] && node[argPropName][0];\n                    if (arg && (arg.type === 'ObjectExpression' ||\n                            arg.type === 'ArrayExpression')) {\n                        type = callName;\n                    }\n                } else if (parse.hasDefine(node)) {\n                    type = 'define';\n                }\n            }\n\n            if (type) {\n                if (!uses) {\n                    uses = {};\n                }\n                uses[type] = true;\n            }\n        });\n\n        return uses;\n    };\n\n    /**\n     * Determines if require(''), exports.x =, module.exports =,\n     * __dirname, __filename are used. So, not strictly traditional CommonJS,\n     * also checks for Node variants.\n     */\n    parse.usesCommonJs = function (fileName, fileContents) {\n        var uses = null,\n            assignsExports = false;\n\n\n        traverse(esprima.parse(fileContents), function (node) {\n            var type,\n                exp = node.expression || node.init;\n\n            if (node.type === 'Identifier' &&\n                    (node.name === '__dirname' || node.name === '__filename')) {\n                type = node.name.substring(2);\n            } else if (node.type === 'VariableDeclarator' && node.id &&\n                    node.id.type === 'Identifier' &&\n                        node.id.name === 'exports') {\n                //Hmm, a variable assignment for exports, so does not use cjs\n                //exports.\n                type = 'varExports';\n            } else if (exp && exp.type === 'AssignmentExpression' && exp.left &&\n                    exp.left.type === 'MemberExpression' && exp.left.object) {\n                if (exp.left.object.name === 'module' && exp.left.property &&\n                        exp.left.property.name === 'exports') {\n                    type = 'moduleExports';\n                } else if (exp.left.object.name === 'exports' &&\n                        exp.left.property) {\n                    type = 'exports';\n                } else if (exp.left.object.type === 'MemberExpression' &&\n                           exp.left.object.object.name === 'module' &&\n                           exp.left.object.property.name === 'exports' &&\n                           exp.left.object.property.type === 'Identifier') {\n                    type = 'moduleExports';\n                }\n\n            } else if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' && node[argPropName] &&\n                    node[argPropName].length === 1 &&\n                    node[argPropName][0].type === 'Literal') {\n                type = 'require';\n            }\n\n            if (type) {\n                if (type === 'varExports') {\n                    assignsExports = true;\n                } else if (type !== 'exports' || !assignsExports) {\n                    if (!uses) {\n                        uses = {};\n                    }\n                    uses[type] = true;\n                }\n            }\n        });\n\n        return uses;\n    };\n\n\n    parse.findRequireDepNames = function (node, deps) {\n        traverse(node, function (node) {\n            var arg;\n\n            if (node && node.type === 'CallExpression' && node.callee &&\n                    node.callee.type === 'Identifier' &&\n                    node.callee.name === 'require' &&\n                    node[argPropName] && node[argPropName].length === 1) {\n\n                arg = node[argPropName][0];\n                if (arg.type === 'Literal') {\n                    deps.push(arg.value);\n                }\n            }\n        });\n    };\n\n    /**\n     * Determines if a specific node is a valid require or define/require.def\n     * call.\n     * @param {Array} node\n     * @param {Function} onMatch a function to call when a match is found.\n     * It is passed the match name, and the config, name, deps possible args.\n     * The config, name and deps args are not normalized.\n     * @param {Object} fnExpScope an object whose keys are all function\n     * expression identifiers that should be in scope. Useful for UMD wrapper\n     * detection to avoid parsing more into the wrapped UMD code.\n     *\n     * @returns {String} a JS source string with the valid require/define call.\n     * Otherwise null.\n     */\n    parse.parseNode = function (node, onMatch, fnExpScope) {\n        var name, deps, cjsDeps, arg, factory, exp, refsDefine, bodyNode,\n            args = node && node[argPropName],\n            callName = parse.hasRequire(node),\n            isUmd = false;\n\n        if (callName === 'require' || callName === 'requirejs') {\n            //A plain require/requirejs call\n            arg = node[argPropName] && node[argPropName][0];\n            if (arg && arg.type !== 'ArrayExpression') {\n                if (arg.type === 'ObjectExpression') {\n                    //A config call, try the second arg.\n                    arg = node[argPropName][1];\n                }\n            }\n\n            deps = getValidDeps(arg);\n            if (!deps) {\n                return;\n            }\n\n            return onMatch(\"require\", null, null, deps, node);\n        } else if (parse.hasDefine(node) && args && args.length) {\n            name = args[0];\n            deps = args[1];\n            factory = args[2];\n\n            if (name.type === 'ArrayExpression') {\n                //No name, adjust args\n                factory = deps;\n                deps = name;\n                name = null;\n            } else if (isFnExpression(name)) {\n                //Just the factory, no name or deps\n                factory = name;\n                name = deps = null;\n            } else if (name.type === 'Identifier' && args.length === 1 &&\n                       hasProp(fnExpScope, name.name)) {\n                //define(e) where e is a UMD identifier for the factory\n                //function.\n                isUmd = true;\n                factory = name;\n                name = null;\n            } else if (name.type !== 'Literal') {\n                 //An object literal, just null out\n                name = deps = factory = null;\n            }\n\n            if (name && name.type === 'Literal' && deps) {\n                if (isFnExpression(deps)) {\n                    //deps is the factory\n                    factory = deps;\n                    deps = null;\n                } else if (deps.type === 'ObjectExpression') {\n                    //deps is object literal, null out\n                    deps = factory = null;\n                } else if (deps.type === 'Identifier') {\n                    if (args.length === 2) {\n                        //define('id', factory)\n                        deps = factory = null;\n                    } else if (args.length === 3 && isFnExpression(factory)) {\n                        //define('id', depsIdentifier, factory)\n                        //Since identifier, cannot know the deps, but do not\n                        //error out, assume they are taken care of outside of\n                        //static parsing.\n                        deps = null;\n                    }\n                }\n            }\n\n            if (deps && deps.type === 'ArrayExpression') {\n                deps = getValidDeps(deps);\n            } else if (isFnExpression(factory)) {\n                //If no deps and a factory function, could be a commonjs sugar\n                //wrapper, scan the function for dependencies.\n                cjsDeps = parse.getAnonDepsFromNode(factory);\n                if (cjsDeps.length) {\n                    deps = cjsDeps;\n                }\n            } else if (deps || (factory && !isUmd)) {\n                //Does not match the shape of an AMD call.\n                return;\n            }\n\n            //Just save off the name as a string instead of an AST object.\n            if (name && name.type === 'Literal') {\n                name = name.value;\n            }\n\n            return onMatch(\"define\", null, name, deps, node,\n                           (factory && factory.type === 'Identifier' ? factory.name : undefined),\n                           fnExpScope);\n        } else if (node.type === 'CallExpression' && node.callee &&\n                   isFnExpression(node.callee) &&\n                   node.callee.body && node.callee.body.body &&\n                   node.callee.body.body.length === 1 &&\n                   node.callee.body.body[0].type === 'IfStatement') {\n            bodyNode = node.callee.body.body[0];\n            //Look for a define(Identifier) case, but only if inside an\n            //if that has a define.amd test\n            if (bodyNode.consequent && bodyNode.consequent.body) {\n                exp = bodyNode.consequent.body[0];\n                if (exp.type === 'ExpressionStatement' && exp.expression &&\n                    parse.hasDefine(exp.expression) &&\n                    exp.expression.arguments &&\n                    exp.expression.arguments.length === 1 &&\n                    exp.expression.arguments[0].type === 'Identifier') {\n\n                    //Calls define(Identifier) as first statement in body.\n                    //Confirm the if test references define.amd\n                    traverse(bodyNode.test, function (node) {\n                        if (parse.refsDefineAmd(node)) {\n                            refsDefine = true;\n                            return false;\n                        }\n                    });\n\n                    if (refsDefine) {\n                        return onMatch(\"define\", null, null, null, exp.expression,\n                                       exp.expression.arguments[0].name, fnExpScope);\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Converts an AST node into a JS source string by extracting\n     * the node's location from the given contents string. Assumes\n     * esprima.parse() with loc was done.\n     * @param {String} contents\n     * @param {Object} node\n     * @returns {String} a JS source string.\n     */\n    parse.nodeToString = function (contents, node) {\n        var extracted,\n            loc = node.loc,\n            lines = contents.split('\\n'),\n            firstLine = loc.start.line > 1 ?\n                        lines.slice(0, loc.start.line - 1).join('\\n') + '\\n' :\n                        '',\n            preamble = firstLine +\n                       lines[loc.start.line - 1].substring(0, loc.start.column);\n\n        if (loc.start.line === loc.end.line) {\n            extracted = lines[loc.start.line - 1].substring(loc.start.column,\n                                                            loc.end.column);\n        } else {\n            extracted =  lines[loc.start.line - 1].substring(loc.start.column) +\n                     '\\n' +\n                     lines.slice(loc.start.line, loc.end.line - 1).join('\\n') +\n                     '\\n' +\n                     lines[loc.end.line - 1].substring(0, loc.end.column);\n        }\n\n        return {\n            value: extracted,\n            range: [\n                preamble.length,\n                preamble.length + extracted.length\n            ]\n        };\n    };\n\n    /**\n     * Extracts license comments from JS text.\n     * @param {String} fileName\n     * @param {String} contents\n     * @returns {String} a string of license comments.\n     */\n    parse.getLicenseComments = function (fileName, contents) {\n        var commentNode, refNode, subNode, value, i, j,\n            //xpconnect's Reflect does not support comment or range, but\n            //prefer continued operation vs strict parity of operation,\n            //as license comments can be expressed in other ways, like\n            //via wrap args, or linked via sourcemaps.\n            ast = esprima.parse(contents, {\n                comment: true,\n                range: true\n            }),\n            result = '',\n            existsMap = {},\n            lineEnd = contents.indexOf('\\r') === -1 ? '\\n' : '\\r\\n';\n\n        if (ast.comments) {\n            for (i = 0; i < ast.comments.length; i++) {\n                commentNode = ast.comments[i];\n\n                if (commentNode.type === 'Line') {\n                    value = '//' + commentNode.value + lineEnd;\n                    refNode = commentNode;\n\n                    if (i + 1 >= ast.comments.length) {\n                        value += lineEnd;\n                    } else {\n                        //Look for immediately adjacent single line comments\n                        //since it could from a multiple line comment made out\n                        //of single line comments. Like this comment.\n                        for (j = i + 1; j < ast.comments.length; j++) {\n                            subNode = ast.comments[j];\n                            if (subNode.type === 'Line' &&\n                                    subNode.range[0] === refNode.range[1] + 1) {\n                                //Adjacent single line comment. Collect it.\n                                value += '//' + subNode.value + lineEnd;\n                                refNode = subNode;\n                            } else {\n                                //No more single line comment blocks. Break out\n                                //and continue outer looping.\n                                break;\n                            }\n                        }\n                        value += lineEnd;\n                        i = j - 1;\n                    }\n                } else {\n                    value = '/*' + commentNode.value + '*/' + lineEnd + lineEnd;\n                }\n\n                if (!existsMap[value] && (value.indexOf('license') !== -1 ||\n                        (commentNode.type === 'Block' &&\n                            value.indexOf('/*!') === 0) ||\n                        value.indexOf('opyright') !== -1 ||\n                        value.indexOf('(c)') !== -1)) {\n\n                    result += value;\n                    existsMap[value] = true;\n                }\n\n            }\n        }\n\n        return result;\n    };\n\n    return parse;\n});\n\n/*jslint regexp: true, plusplus: true  */\n/*global define: false */\n\ndefine('skylark-rjs/pragma',[\n    './parse', \n    './logger'\n], function (parse, logger) {\n    'use strict';\n    function Temp() {}\n\n    function create(obj, mixin) {\n        Temp.prototype = obj;\n        var temp = new Temp(), prop;\n\n        //Avoid any extra memory hanging around\n        Temp.prototype = null;\n\n        if (mixin) {\n            for (prop in mixin) {\n                if (mixin.hasOwnProperty(prop) && !temp.hasOwnProperty(prop)) {\n                    temp[prop] = mixin[prop];\n                }\n            }\n        }\n\n        return temp; // Object\n    }\n\n    var pragma = {\n        conditionalRegExp: /(exclude|include)Start\\s*\\(\\s*[\"'](\\w+)[\"']\\s*,(.*)\\)/,\n        useStrictRegExp: /(^|[^{]\\r?\\n)['\"]use strict['\"];/g,\n        hasRegExp: /has\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n        configRegExp: /(^|[^\\.])(requirejs|require)(\\.config)\\s*\\(/g,\n        nsWrapRegExp: /\\/\\*requirejs namespace: true \\*\\//,\n        apiDefRegExp: /var requirejs,\\s*require,\\s*define;/,\n        defineCheckRegExp: /typeof(\\s+|\\s*\\(\\s*)define(\\s*\\))?\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineStringCheckRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\[\\s*[\"']amd[\"']\\s*\\]/g,\n        defineTypeFirstCheckRegExp: /\\s*[\"']function[\"']\\s*==(=?)\\s*typeof\\s+define\\s*&&\\s*define\\s*\\.\\s*amd/g,\n        defineJQueryRegExp: /typeof\\s+define\\s*===?\\s*[\"']function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\.\\s*jQuery/g,\n        defineHasRegExp: /typeof\\s+define\\s*==(=)?\\s*['\"]function['\"]\\s*&&\\s*typeof\\s+define\\.amd\\s*==(=)?\\s*['\"]object['\"]\\s*&&\\s*define\\.amd/g,\n        defineTernaryRegExp: /typeof\\s+define\\s*===?\\s*['\"]function[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*\\?\\s*define/,\n        defineExistsRegExp: /\\s+typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*/,\n        defineExistsAndAmdRegExp: /typeof\\s+define\\s*!==?\\s*['\"]undefined[\"']\\s*&&\\s*define\\s*\\.\\s*amd\\s*/,\n        amdefineRegExp: /if\\s*\\(\\s*typeof define\\s*\\!==\\s*['\"]function['\"]\\s*\\)\\s*\\{\\s*[^\\{\\}]+amdefine[^\\{\\}]+\\}/g,\n\n        removeStrict: function (contents, config) {\n            return config.useStrict ? contents : contents.replace(pragma.useStrictRegExp, '$1');\n        },\n\n        namespace: function (fileContents, ns, onLifecycleName) {\n            if (ns) {\n                //Namespace require/define calls\n                fileContents = fileContents.replace(pragma.configRegExp, '$1' + ns + '.$2$3(');\n\n\n                fileContents = parse.renameNamespace(fileContents, ns);\n\n                //Namespace define ternary use:\n                fileContents = fileContents.replace(pragma.defineTernaryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd ? \" + ns + \".define\");\n\n                //Namespace define jquery use:\n                fileContents = fileContents.replace(pragma.defineJQueryRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd && \" + ns + \".define.amd.jQuery\");\n\n                //Namespace has.js define use:\n                fileContents = fileContents.replace(pragma.defineHasRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && typeof \" + ns + \".define.amd === 'object' && \" + ns + \".define.amd\");\n\n                //Namespace async.js define use:\n                fileContents = fileContents.replace(pragma.defineExistsAndAmdRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined' && \" + ns + \".define.amd\");\n\n                //Namespace define checks.\n                //Do these ones last, since they are a subset of the more specific\n                //checks above.\n                fileContents = fileContents.replace(pragma.defineCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineStringCheckRegExp,\n                                                    \"typeof \" + ns + \".define === 'function' && \" + ns + \".define['amd']\");\n                fileContents = fileContents.replace(pragma.defineTypeFirstCheckRegExp,\n                                                    \"'function' === typeof \" + ns + \".define && \" + ns + \".define.amd\");\n                fileContents = fileContents.replace(pragma.defineExistsRegExp,\n                                                    \"typeof \" + ns + \".define !== 'undefined'\");\n\n                //Check for require.js with the require/define definitions\n                if (pragma.apiDefRegExp.test(fileContents) &&\n                    fileContents.indexOf(\"if (!\" + ns + \" || !\" + ns + \".requirejs)\") === -1) {\n                    //Wrap the file contents in a typeof check, and a function\n                    //to contain the API globals.\n                    fileContents = \"var \" + ns + \";(function () { if (!\" + ns + \" || !\" + ns + \".requirejs) {\\n\" +\n                                    \"if (!\" + ns + \") { \" + ns + ' = {}; } else { require = ' + ns + '; }\\n' +\n                                    fileContents +\n                                    \"\\n\" +\n                                    ns + \".requirejs = requirejs;\" +\n                                    ns + \".require = require;\" +\n                                    ns + \".define = define;\\n\" +\n                                    \"}\\n}());\";\n                }\n\n                //Finally, if the file wants a special wrapper because it ties\n                //in to the requirejs internals in a way that would not fit\n                //the above matches, do that. Look for /*requirejs namespace: true*/\n                if (pragma.nsWrapRegExp.test(fileContents)) {\n                    //Remove the pragma.\n                    fileContents = fileContents.replace(pragma.nsWrapRegExp, '');\n\n                    //Alter the contents.\n                    fileContents = '(function () {\\n' +\n                                   'var require = ' + ns + '.require,' +\n                                   'requirejs = ' + ns + '.requirejs,' +\n                                   'define = ' + ns + '.define;\\n' +\n                                   fileContents +\n                                   '\\n}());';\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * processes the fileContents for some //>> conditional statements\n         */\n        process: function (fileName, fileContents, config, onLifecycleName, pluginCollector) {\n            /*jslint evil: true */\n            var foundIndex = -1, startIndex = 0, lineEndIndex, conditionLine,\n                matches, type, marker, condition, isTrue, endRegExp, endMatches,\n                endMarkerIndex, shouldInclude, startLength, lifecycleHas, deps,\n                i, dep, moduleName, collectorMod,\n                lifecyclePragmas, pragmas = config.pragmas, hasConfig = config.has,\n                //Legacy arg defined to help in dojo conversion script. Remove later\n                //when dojo no longer needs conversion:\n                kwArgs = pragmas;\n\n            //Mix in a specific lifecycle scoped object, to allow targeting\n            //some pragmas/has tests to only when files are saved, or at different\n            //lifecycle events. Do not bother with kwArgs in this section, since\n            //the old dojo kwArgs were for all points in the build lifecycle.\n            if (onLifecycleName) {\n                lifecyclePragmas = config['pragmas' + onLifecycleName];\n                lifecycleHas = config['has' + onLifecycleName];\n\n                if (lifecyclePragmas) {\n                    pragmas = create(pragmas || {}, lifecyclePragmas);\n                }\n\n                if (lifecycleHas) {\n                    hasConfig = create(hasConfig || {}, lifecycleHas);\n                }\n            }\n\n            //Replace has references if desired\n            if (hasConfig) {\n                fileContents = fileContents.replace(pragma.hasRegExp, function (match, test) {\n                    if (hasConfig.hasOwnProperty(test)) {\n                        return !!hasConfig[test];\n                    }\n                    return match;\n                });\n            }\n\n            if (!config.skipPragmas) {\n\n                while ((foundIndex = fileContents.indexOf(\"//>>\", startIndex)) !== -1) {\n                    //Found a conditional. Get the conditional line.\n                    lineEndIndex = fileContents.indexOf(\"\\n\", foundIndex);\n                    if (lineEndIndex === -1) {\n                        lineEndIndex = fileContents.length - 1;\n                    }\n\n                    //Increment startIndex past the line so the next conditional search can be done.\n                    startIndex = lineEndIndex + 1;\n\n                    //Break apart the conditional.\n                    conditionLine = fileContents.substring(foundIndex, lineEndIndex + 1);\n                    matches = conditionLine.match(pragma.conditionalRegExp);\n                    if (matches) {\n                        type = matches[1];\n                        marker = matches[2];\n                        condition = matches[3];\n                        isTrue = false;\n                        //See if the condition is true.\n                        try {\n                            isTrue = !!eval(\"(\" + condition + \")\");\n                        } catch (e) {\n                            throw \"Error in file: \" +\n                                   fileName +\n                                   \". Conditional comment: \" +\n                                   conditionLine +\n                                   \" failed with this error: \" + e;\n                        }\n\n                        //Find the endpoint marker.\n                        endRegExp = new RegExp('\\\\/\\\\/\\\\>\\\\>\\\\s*' + type + 'End\\\\(\\\\s*[\\'\"]' + marker + '[\\'\"]\\\\s*\\\\)', \"g\");\n                        endMatches = endRegExp.exec(fileContents.substring(startIndex, fileContents.length));\n                        if (endMatches) {\n                            endMarkerIndex = startIndex + endRegExp.lastIndex - endMatches[0].length;\n\n                            //Find the next line return based on the match position.\n                            lineEndIndex = fileContents.indexOf(\"\\n\", endMarkerIndex);\n                            if (lineEndIndex === -1) {\n                                lineEndIndex = fileContents.length - 1;\n                            }\n\n                            //Should we include the segment?\n                            shouldInclude = ((type === \"exclude\" && !isTrue) || (type === \"include\" && isTrue));\n\n                            //Remove the conditional comments, and optionally remove the content inside\n                            //the conditional comments.\n                            startLength = startIndex - foundIndex;\n                            fileContents = fileContents.substring(0, foundIndex) +\n                                (shouldInclude ? fileContents.substring(startIndex, endMarkerIndex) : \"\") +\n                                fileContents.substring(lineEndIndex + 1, fileContents.length);\n\n                            //Move startIndex to foundIndex, since that is the new position in the file\n                            //where we need to look for more conditionals in the next while loop pass.\n                            startIndex = foundIndex;\n                        } else {\n                            throw \"Error in file: \" +\n                                  fileName +\n                                  \". Cannot find end marker for conditional comment: \" +\n                                  conditionLine;\n\n                        }\n                    }\n                }\n            }\n\n            //If need to find all plugin resources to optimize, do that now,\n            //before namespacing, since the namespacing will change the API\n            //names.\n            //If there is a plugin collector, scan the file for plugin resources.\n            if (config.optimizeAllPluginResources && pluginCollector) {\n                try {\n                    deps = parse.findDependencies(fileName, fileContents);\n                    if (deps.length) {\n                        for (i = 0; i < deps.length; i++) {\n                            dep = deps[i];\n                            if (dep.indexOf('!') !== -1) {\n                                moduleName = dep.split('!')[0];\n                                collectorMod = pluginCollector[moduleName];\n                                if (!collectorMod) {\n                                 collectorMod = pluginCollector[moduleName] = [];\n                                }\n                                collectorMod.push(dep);\n                            }\n                        }\n                    }\n                } catch (eDep) {\n                    logger.error('Parse error looking for plugin resources in ' +\n                                 fileName + ', skipping.');\n                }\n            }\n\n            //Strip amdefine use for node-shared modules.\n            if (!config.keepAmdefine) {\n                fileContents = fileContents.replace(pragma.amdefineRegExp, '');\n            }\n\n            //Do namespacing\n            if (onLifecycleName === 'OnSave' && config.namespace) {\n                fileContents = pragma.namespace(fileContents, config.namespace, onLifecycleName);\n            }\n\n\n            return pragma.removeStrict(fileContents, config);\n        }\n    };\n\n    return pragma;\n});\n\n//Distributed under the BSD license:\n//Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\ndefine('skylark-rjs/uglifyjs',['skylark-uglifyjs'], function (uglifyjs) {\n    return uglifyjs;\n});\n\ndefine('skylark-rjs/source-map',['skylark-sourcemap'], function (sourcemap) {\n    return sourcemap;\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true */\n/*global define: false */\n\ndefine('skylark-rjs/optimize',[ \n    './lang', \n    './logger', \n///    'env!env/optimize', \n///    'env!env/file', \n    './parse',\n    './pragma', \n    './uglifyjs',\n    './source-map'\n],function (\n    lang,\n    logger,\n///     envOptimize, \n///     file, \n     parse,\n     pragma, \n     uglify,\n     sourceMap\n) {\n    'use strict';\n\n    var optimize,\n        cssImportRegExp = /\\@import\\s+(url\\()?\\s*([^);]+)\\s*(\\))?([\\w, ]*)(;)?/ig,\n        cssCommentImportRegExp = /\\/\\*[^\\*]*@import[^\\*]*\\*\\//g,\n        cssUrlRegExp = /\\url\\(\\s*([^\\)]+)\\s*\\)?/g,\n        protocolRegExp = /^\\w+:/,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        SourceMapConsumer = sourceMap.SourceMapConsumer,\n        es5PlusGuidance = 'If the source uses ES2015 or later syntax, please pass \"optimize: \\'none\\'\" to r.js and use an ES2015+ compatible minifier after running r.js. The included UglifyJS only understands ES5 or earlier syntax.';\n\n    /**\n     * If an URL from a CSS url value contains start/end quotes, remove them.\n     * This is not done in the regexp, since my regexp fu is not that strong,\n     * and the CSS spec allows for ' and \" in the URL if they are backslash escaped.\n     * @param {String} url\n     */\n    function cleanCssUrlQuotes(url) {\n        //Make sure we are not ending in whitespace.\n        //Not very confident of the css regexps above that there will not be ending\n        //whitespace.\n        url = url.replace(/\\s+$/, \"\");\n\n        if (url.charAt(0) === \"'\" || url.charAt(0) === \"\\\"\") {\n            url = url.substring(1, url.length - 1);\n        }\n\n        return url;\n    }\n\n    function fixCssUrlPaths(fileName, path, contents, cssPrefix) {\n        return contents.replace(cssUrlRegExp, function (fullMatch, urlMatch) {\n            var firstChar, hasProtocol, parts, i,\n                fixedUrlMatch = cleanCssUrlQuotes(urlMatch);\n\n            fixedUrlMatch = fixedUrlMatch.replace(lang.backSlashRegExp, \"/\");\n\n            //Only do the work for relative URLs. Skip things that start with / or #, or have\n            //a protocol.\n            firstChar = fixedUrlMatch.charAt(0);\n            hasProtocol = protocolRegExp.test(fixedUrlMatch);\n            if (firstChar !== \"/\" && firstChar !== \"#\" && !hasProtocol) {\n                //It is a relative URL, tack on the cssPrefix and path prefix\n                urlMatch = cssPrefix + path + fixedUrlMatch;\n            } else if (!hasProtocol) {\n                logger.trace(fileName + \"\\n  URL not a relative URL, skipping: \" + urlMatch);\n            }\n\n            //Collapse .. and .\n            parts = urlMatch.split(\"/\");\n            for (i = parts.length - 1; i > 0; i--) {\n                if (parts[i] === \".\") {\n                    parts.splice(i, 1);\n                } else if (parts[i] === \"..\") {\n                    if (i !== 0 && parts[i - 1] !== \"..\") {\n                        parts.splice(i - 1, 2);\n                        i -= 1;\n                    }\n                }\n            }\n\n            return \"url(\" + parts.join(\"/\") + \")\";\n        });\n    }\n\n    /**\n     * Inlines nested stylesheets that have @import calls in them.\n     * @param {String} fileName the file name\n     * @param {String} fileContents the file contents\n     * @param {String} cssImportIgnore comma delimited string of files to ignore\n     * @param {String} cssPrefix string to be prefixed before relative URLs\n     * @param {Object} included an object used to track the files already imported\n     */\n    function flattenCss(fileName, fileContents, cssImportIgnore, cssPrefix, included, topLevel,config) {\n        //Find the last slash in the name.\n        fileName = fileName.replace(lang.backSlashRegExp, \"/\");\n        var endIndex = fileName.lastIndexOf(\"/\"),\n            //Make a file path based on the last slash.\n            //If no slash, so must be just a file name. Use empty string then.\n            filePath = (endIndex !== -1) ? fileName.substring(0, endIndex + 1) : \"\",\n            //store a list of merged files\n            importList = [],\n            skippedList = [],\n            fs = config.env.fs;\n\n        //First make a pass by removing any commented out @import calls.\n        fileContents = fileContents.replace(cssCommentImportRegExp, '');\n\n        //Make sure we have a delimited ignore list to make matching faster\n        if (cssImportIgnore && cssImportIgnore.charAt(cssImportIgnore.length - 1) !== \",\") {\n            cssImportIgnore += \",\";\n        }\n\n        fileContents = fileContents.replace(cssImportRegExp, function (fullMatch, urlStart, importFileName, urlEnd, mediaTypes) {\n            //Only process media type \"all\" or empty media type rules.\n            if (mediaTypes && ((mediaTypes.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '')) !== \"all\")) {\n                skippedList.push(fileName);\n                return fullMatch;\n            }\n\n            importFileName = cleanCssUrlQuotes(importFileName);\n\n            //Ignore the file import if it is part of an ignore list.\n            if (cssImportIgnore && cssImportIgnore.indexOf(importFileName + \",\") !== -1) {\n                return fullMatch;\n            }\n\n            //Make sure we have a unix path for the rest of the operation.\n            importFileName = importFileName.replace(lang.backSlashRegExp, \"/\");\n\n            try {\n                //if a relative path, then tack on the filePath.\n                //If it is not a relative path, then the readFile below will fail,\n                //and we will just skip that import.\n                var fullImportFileName = importFileName.charAt(0) === \"/\" ? importFileName : filePath + importFileName,\n                    importContents = fs.readFile(fullImportFileName),\n                    importEndIndex, importPath, flat;\n\n                //Skip the file if it has already been included.\n                if (included[fullImportFileName]) {\n                    return '';\n                }\n                included[fullImportFileName] = true;\n\n                //Make sure to flatten any nested imports.\n                flat = flattenCss(fullImportFileName, importContents, cssImportIgnore, cssPrefix, included,false,config);\n                importContents = flat.fileContents;\n\n                if (flat.importList.length) {\n                    importList.push.apply(importList, flat.importList);\n                }\n                if (flat.skippedList.length) {\n                    skippedList.push.apply(skippedList, flat.skippedList);\n                }\n\n                //Make the full import path\n                importEndIndex = importFileName.lastIndexOf(\"/\");\n\n                //Make a file path based on the last slash.\n                //If no slash, so must be just a file name. Use empty string then.\n                importPath = (importEndIndex !== -1) ? importFileName.substring(0, importEndIndex + 1) : \"\";\n\n                //fix url() on relative import (#5)\n                importPath = importPath.replace(/^\\.\\//, '');\n\n                //Modify URL paths to match the path represented by this file.\n                importContents = fixCssUrlPaths(importFileName, importPath, importContents, cssPrefix);\n\n                importList.push(fullImportFileName);\n                return importContents;\n            } catch (e) {\n                logger.warn(fileName + \"\\n  Cannot inline css import, skipping: \" + importFileName);\n                return fullMatch;\n            }\n        });\n\n        if (cssPrefix && topLevel) {\n            //Modify URL paths to match the path represented by this file.\n            fileContents = fixCssUrlPaths(fileName, '', fileContents, cssPrefix);\n        }\n\n        return {\n            importList : importList,\n            skippedList: skippedList,\n            fileContents : fileContents\n        };\n    }\n\n    optimize = {\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file to optimize\n         * @param {String} fileContents the contents to optimize. If this is\n         * a null value, then fileName will be used to read the fileContents.\n         * @param {String} outFileName the name of the file to use for the\n         * saved optimized content.\n         * @param {Object} config the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        jsFile: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var fs = config.env.fs;\n            if (!fileContents) {\n                fileContents = fs.readFile(fileName);\n            }\n\n            fileContents = optimize.js(fileName, fileContents, outFileName, config, pluginCollector);\n\n            fs.saveUtf8File(outFileName, fileContents);\n        },\n\n        /**\n         * Optimizes a file that contains JavaScript content. Optionally collects\n         * plugin resources mentioned in a file, and then passes the content\n         * through an minifier if one is specified via config.optimize.\n         *\n         * @param {String} fileName the name of the file that matches the\n         * fileContents.\n         * @param {String} fileContents the string of JS to optimize.\n         * @param {Object} [config] the build config object.\n         * @param {Array} [pluginCollector] storage for any plugin resources\n         * found.\n         */\n        js: function (fileName, fileContents, outFileName, config, pluginCollector) {\n            var optFunc, optConfig,\n                parts = (String(config.optimize)).split('.'),\n                optimizerName = parts[0],\n                keepLines = parts[1] === 'keepLines',\n                licenseContents = '';\n\n            config = config || {};\n\n            //Apply pragmas/namespace renaming\n            fileContents = pragma.process(fileName, fileContents, config, 'OnSave', pluginCollector);\n\n            //Optimize the JS files if asked.\n            if (optimizerName && optimizerName !== 'none') {\n                ///optFunc = envOptimize[optimizerName] || optimize.optimizers[optimizerName];\n                optFunc = optimize.optimizers[optimizerName];\n                if (!optFunc) {\n                    throw new Error('optimizer with name of \"' +\n                                    optimizerName +\n                                    '\" not found for this environment');\n                }\n\n                optConfig = config[optimizerName] || {};\n                if (config.generateSourceMaps) {\n                    optConfig.generateSourceMaps = !!config.generateSourceMaps;\n                    optConfig._buildSourceMap = config._buildSourceMap;\n                }\n                ///optConfig.env = config.env;\n\n                try {\n                    if (config.preserveLicenseComments) {\n                        //Pull out any license comments for prepending after optimization.\n                        try {\n                            licenseContents = parse.getLicenseComments(fileName, fileContents);\n                        } catch (e) {\n                            throw new Error('Cannot parse file: ' + fileName + ' for comments. Skipping it. Error is:\\n' + e.toString());\n                        }\n                    }\n\n                    if (config.generateSourceMaps && licenseContents) {\n                        optConfig.preamble = licenseContents;\n                        licenseContents = '';\n                    }\n\n                    fileContents = licenseContents + optFunc(fileName,\n                                                             fileContents,\n                                                             outFileName,\n                                                             keepLines,\n                                                             optConfig,\n                                                             config.env.fs);\n                    if (optConfig._buildSourceMap && optConfig._buildSourceMap !== config._buildSourceMap) {\n                        config._buildSourceMap = optConfig._buildSourceMap;\n                    }\n                } catch (e) {\n                    if (config.throwWhen && config.throwWhen.optimize) {\n                        throw e;\n                    } else {\n                        logger.error(e);\n                    }\n                }\n            } else {\n                if (config._buildSourceMap) {\n                    config._buildSourceMap = null;\n                }\n            }\n\n            return fileContents;\n        },\n\n        /**\n         * Optimizes one CSS file, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} fileName the path to the CSS file to optimize\n         * @param {String} outFileName the path to save the optimized file.\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        cssFile: function (fileName, outFileName, config) {\n            var fs = config.env.fs;\n            //Read in the file. Make sure we have a JS string.\n            var originalFileContents = fs.readFile(fileName),\n                flat = flattenCss(fileName, originalFileContents, config.cssImportIgnore, config.cssPrefix, {}, true,config),\n                //Do not use the flattened CSS if there was one that was skipped.\n                fileContents = flat.skippedList.length ? originalFileContents : flat.fileContents,\n                startIndex, endIndex, buildText, comment;\n\n            if (flat.skippedList.length) {\n                logger.warn('Cannot inline @imports for ' + fileName +\n                            ',\\nthe following files had media queries in them:\\n' +\n                            flat.skippedList.join('\\n'));\n            }\n\n            //Do comment removal.\n            try {\n                if (config.optimizeCss.indexOf(\".keepComments\") === -1) {\n                    startIndex = 0;\n                    //Get rid of comments.\n                    while ((startIndex = fileContents.indexOf(\"/*\", startIndex)) !== -1) {\n                        endIndex = fileContents.indexOf(\"*/\", startIndex + 2);\n                        if (endIndex === -1) {\n                            throw \"Improper comment in CSS file: \" + fileName;\n                        }\n                        comment = fileContents.substring(startIndex, endIndex);\n\n                        if (config.preserveLicenseComments &&\n                            (comment.indexOf('license') !== -1 ||\n                             comment.indexOf('opyright') !== -1 ||\n                             comment.indexOf('(c)') !== -1)) {\n                            //Keep the comment, just increment the startIndex\n                            startIndex = endIndex;\n                        } else {\n                            fileContents = fileContents.substring(0, startIndex) + fileContents.substring(endIndex + 2, fileContents.length);\n                            startIndex = 0;\n                        }\n                    }\n                }\n                //Get rid of newlines.\n                if (config.optimizeCss.indexOf(\".keepLines\") === -1) {\n                    fileContents = fileContents.replace(/[\\r\\n]/g, \" \");\n                    fileContents = fileContents.replace(/\\s+/g, \" \");\n                    fileContents = fileContents.replace(/\\{\\s/g, \"{\");\n                    fileContents = fileContents.replace(/\\s\\}/g, \"}\");\n                } else {\n                    //Remove multiple empty lines.\n                    fileContents = fileContents.replace(/(\\r\\n)+/g, \"\\r\\n\");\n                    fileContents = fileContents.replace(/(\\n)+/g, \"\\n\");\n                }\n                //Remove unnecessary whitespace\n                if (config.optimizeCss.indexOf(\".keepWhitespace\") === -1) {\n                    //Remove leading and trailing whitespace from lines\n                    fileContents = fileContents.replace(/^[ \\t]+/gm, \"\");\n                    fileContents = fileContents.replace(/[ \\t]+$/gm, \"\");\n                    //Remove whitespace after semicolon, colon, curly brackets and commas\n                    fileContents = fileContents.replace(/(;|:|\\{|}|,)[ \\t]+/g, \"$1\");\n                    //Remove whitespace before opening curly brackets\n                    fileContents = fileContents.replace(/[ \\t]+(\\{)/g, \"$1\");\n                    //Truncate double whitespace\n                    fileContents = fileContents.replace(/([ \\t])+/g, \"$1\");\n                    //Remove empty lines\n                    fileContents = fileContents.replace(/^[ \\t]*[\\r\\n]/gm,'');\n                }\n            } catch (e) {\n                fileContents = originalFileContents;\n                logger.error(\"Could not optimized CSS file: \" + fileName + \", error: \" + e);\n            }\n\n            fs.saveUtf8File(outFileName, fileContents);\n\n            //text output to stdout and/or written to build.txt file\n            buildText = \"\\n\"+ outFileName.replace(config.dir, \"\") +\"\\n----------------\\n\";\n            flat.importList.push(fileName);\n            buildText += flat.importList.map(function(path){\n                return path.replace(config.dir, \"\");\n            }).join(\"\\n\");\n\n            return {\n                importList: flat.importList,\n                buildText: buildText +\"\\n\"\n            };\n        },\n\n        /**\n         * Optimizes CSS files, inlining @import calls, stripping comments, and\n         * optionally removes line returns.\n         * @param {String} startDir the path to the top level directory\n         * @param {Object} config the config object with the optimizeCss and\n         * cssImportIgnore options.\n         */\n        css: function (startDir, config) {\n            var buildText = \"\",\n                importList = [],\n                shouldRemove = config.dir && config.removeCombined,\n                i, fileName, result, fileList,\n                fs = config.env.fs;\n\n            if (config.optimizeCss.indexOf(\"standard\") !== -1) {\n                fileList = fs.getFilteredFileList(startDir, /\\.css$/, true);\n                if (fileList) {\n                    for (i = 0; i < fileList.length; i++) {\n                        fileName = fileList[i];\n                        logger.trace(\"Optimizing (\" + config.optimizeCss + \") CSS file: \" + fileName);\n                        result = optimize.cssFile(fileName, fileName, config);\n                        buildText += result.buildText;\n                        if (shouldRemove) {\n                            result.importList.pop();\n                            importList = importList.concat(result.importList);\n                        }\n                    }\n                }\n\n                if (shouldRemove) {\n                    importList.forEach(function (path) {\n                        if (fs.exists(path)) {\n                            fs.deleteFile(path);\n                        }\n                    });\n                }\n            }\n            return buildText;\n        },\n\n        optimizers: {\n            uglify: function (fileName, fileContents, outFileName, keepLines, config,fs) {\n                var result, existingMap, resultMap, finalMap, sourceIndex,\n                    uconfig = {},\n                    existingMapPath = outFileName + '.map',\n                    baseName = fileName && fileName.split('/').pop();\n\n                config = config || {};\n\n                lang.mixin(uconfig, config, true);\n\n                ///uconfig.fromString = true;  // uglify 2 -> 3\n\n                if (config.preamble) {\n                    uconfig.output = {preamble: config.preamble};\n                }\n\n                ///var fs = config.env.fs;\n\n                if (config.generateSourceMaps && (outFileName || config._buildSourceMap)) {\n                    uconfig.outSourceMap = baseName + '.map';\n\n                    if (config._buildSourceMap) {\n                        existingMap = JSON.parse(config._buildSourceMap);\n                        uconfig.inSourceMap = existingMap;\n                    } else if (fs.exists(existingMapPath)) {\n                        uconfig.inSourceMap = existingMapPath;\n                        existingMap = JSON.parse(fs.readFile(existingMapPath));\n                    }\n                }\n\n                logger.trace(\"Uglify file: \" + fileName);\n\n                try {\n                    //var tempContents = fileContents.replace(/\\/\\/\\# sourceMappingURL=.*$/, '');\n                    result = uglify.minify(fileContents, uconfig, baseName + '.src.js');\n                    if (uconfig.outSourceMap && result.map) {\n                        resultMap = result.map;\n                        if (!existingMap && !config._buildSourceMap) {\n                            fs.saveFile(outFileName + '.src.js', fileContents);\n                        }\n\n                        fileContents = result.code;\n\n                        if (config._buildSourceMap) {\n                            config._buildSourceMap = resultMap;\n                        } else {\n                            fs.saveFile(outFileName + '.map', resultMap);\n                        }\n                    } else {\n                        fileContents = result.code;\n                    }\n                } catch (e) {\n                    var errorString = e.toString();\n                    var isSyntaxError = /SyntaxError/.test(errorString);\n                    console.error(e);\n                    throw new Error('Cannot uglify file: ' + fileName +\n                                    '. Skipping it. Error is:\\n' + errorString +\n                                  (isSyntaxError ? '\\n\\n' + es5PlusGuidance : ''));\n                }\n                return fileContents;\n            }\n        }\n    };\n\n    return optimize;\n});\n\n/*global define */\n\ndefine('skylark-rjs/transform',[ \n    './esprima', \n    './parse', \n    './logger', \n    './lang'\n],\nfunction (esprima, parse, logger, lang) {\n    'use strict';\n    var transform,\n        baseIndentRegExp = /^([ \\t]+)/,\n        indentRegExp = /\\{[\\r\\n]+([ \\t]+)/,\n        keyRegExp = /^[_A-Za-z]([A-Za-z\\d_]*)$/,\n        bulkIndentRegExps = {\n            '\\n': /\\n/g,\n            '\\r\\n': /\\r\\n/g\n        };\n\n    function applyIndent(str, indent, lineReturn) {\n        var regExp = bulkIndentRegExps[lineReturn];\n        return str.replace(regExp, '$&' + indent);\n    }\n\n    transform = {\n        toTransport: function (namespace, moduleName, path, contents, onFound, options) {\n            options = options || {};\n\n            var astRoot, contentLines, modLine,\n                foundAnon,\n                scanCount = 0,\n                scanReset = false,\n                defineInfos = [],\n                applySourceUrl = function (contents) {\n                    if (options.useSourceUrl) {\n                        contents = 'eval(\"' + lang.jsEscape(contents) +\n                            '\\\\n//# sourceURL=' + (path.indexOf('/') === 0 ? '' : '/') +\n                            path +\n                            '\");\\n';\n                    }\n                    return contents;\n                };\n\n            try {\n                astRoot = esprima.parse(contents, {\n                    loc: true\n                });\n            } catch (e) {\n                logger.trace('toTransport skipping ' + path + ': ' +\n                             e.toString());\n                return contents;\n            }\n\n            //Find the define calls and their position in the files.\n            parse.traverse(astRoot, function (node) {\n                var args, firstArg, firstArgLoc, factoryNode,\n                    needsId, depAction, foundId, init,\n                    sourceUrlData, range,\n                    namespaceExists = false;\n\n                // If a bundle script with a define declaration, do not\n                // parse any further at this level. Likely a built layer\n                // by some other tool.\n                if (node.type === 'VariableDeclarator' &&\n                    node.id && node.id.name === 'define' &&\n                    node.id.type === 'Identifier') {\n                    init = node.init;\n                    if (init && init.callee &&\n                        init.callee.type === 'CallExpression' &&\n                        init.callee.callee &&\n                        init.callee.callee.type === 'Identifier' &&\n                        init.callee.callee.name === 'require' &&\n                        init.callee.arguments && init.callee.arguments.length === 1 &&\n                        init.callee.arguments[0].type === 'Literal' &&\n                        init.callee.arguments[0].value &&\n                        init.callee.arguments[0].value.indexOf('amdefine') !== -1) {\n                        // the var define = require('amdefine')(module) case,\n                        // keep going in that case.\n                    } else {\n                        return false;\n                    }\n                }\n\n                namespaceExists = namespace &&\n                                node.type === 'CallExpression' &&\n                                node.callee  && node.callee.object &&\n                                node.callee.object.type === 'Identifier' &&\n                                node.callee.object.name === namespace &&\n                                node.callee.property.type === 'Identifier' &&\n                                node.callee.property.name === 'define';\n\n                if (namespaceExists || parse.isDefineNodeWithArgs(node)) {\n                    //The arguments are where its at.\n                    args = node.arguments;\n                    if (!args || !args.length) {\n                        return;\n                    }\n\n                    firstArg = args[0];\n                    firstArgLoc = firstArg.loc;\n\n                    if (args.length === 1) {\n                        if (firstArg.type === 'Identifier') {\n                            //The define(factory) case, but\n                            //only allow it if one Identifier arg,\n                            //to limit impact of false positives.\n                            needsId = true;\n                            depAction = 'empty';\n                        } else if (parse.isFnExpression(firstArg)) {\n                            //define(function(){})\n                            factoryNode = firstArg;\n                            needsId = true;\n                            depAction = 'scan';\n                        } else if (firstArg.type === 'ObjectExpression') {\n                            //define({});\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'Literal' &&\n                                   typeof firstArg.value === 'number') {\n                            //define('12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'UnaryExpression' &&\n                                   firstArg.operator === '-' &&\n                                   firstArg.argument &&\n                                   firstArg.argument.type === 'Literal' &&\n                                   typeof firstArg.argument.value === 'number') {\n                            //define('-12345');\n                            needsId = true;\n                            depAction = 'skip';\n                        } else if (firstArg.type === 'MemberExpression' &&\n                                   firstArg.object &&\n                                   firstArg.property &&\n                                   firstArg.property.type === 'Identifier') {\n                            //define(this.key);\n                            needsId = true;\n                            depAction = 'empty';\n                        }\n                    } else if (firstArg.type === 'ArrayExpression') {\n                        //define([], ...);\n                        needsId = true;\n                        depAction = 'skip';\n                    } else if (firstArg.type === 'Literal' &&\n                               typeof firstArg.value === 'string') {\n                        //define('string', ....)\n                        //Already has an ID.\n                        needsId = false;\n                        if (args.length === 2 &&\n                            parse.isFnExpression(args[1])) {\n                            //Needs dependency scanning.\n                            factoryNode = args[1];\n                            depAction = 'scan';\n                        } else {\n                            depAction = 'skip';\n                        }\n                    } else {\n                        //Unknown define entity, keep looking, even\n                        //in the subtree for this node.\n                        return;\n                    }\n\n                    range = {\n                        foundId: foundId,\n                        needsId: needsId,\n                        depAction: depAction,\n                        namespaceExists: namespaceExists,\n                        node: node,\n                        defineLoc: node.loc,\n                        firstArgLoc: firstArgLoc,\n                        factoryNode: factoryNode,\n                        sourceUrlData: sourceUrlData\n                    };\n\n                    //Only transform ones that do not have IDs. If it has an\n                    //ID but no dependency array, assume it is something like\n                    //a phonegap implementation, that has its own internal\n                    //define that cannot handle dependency array constructs,\n                    //and if it is a named module, then it means it has been\n                    //set for transport form.\n                    if (range.needsId) {\n                        if (foundAnon) {\n                            logger.trace(path + ' has more than one anonymous ' +\n                                'define. May be a built file from another ' +\n                                'build system like, Ender. Skipping normalization.');\n                            defineInfos = [];\n                            return false;\n                        } else {\n                            foundAnon = range;\n                            defineInfos.push(range);\n                        }\n                    } else if (depAction === 'scan') {\n                        scanCount += 1;\n                        if (scanCount > 1) {\n                            //Just go back to an array that just has the\n                            //anon one, since this is an already optimized\n                            //file like the phonegap one.\n                            if (!scanReset) {\n                                defineInfos =  foundAnon ? [foundAnon] : [];\n                                scanReset = true;\n                            }\n                        } else {\n                            defineInfos.push(range);\n                        }\n                    }\n                }\n            });\n\n\n            if (!defineInfos.length) {\n                return applySourceUrl(contents);\n            }\n\n            //Reverse the matches, need to start from the bottom of\n            //the file to modify it, so that the ranges are still true\n            //further up.\n            defineInfos.reverse();\n\n            contentLines = contents.split('\\n');\n\n            modLine = function (loc, contentInsertion) {\n                var startIndex = loc.start.column,\n                //start.line is 1-based, not 0 based.\n                lineIndex = loc.start.line - 1,\n                line = contentLines[lineIndex];\n                contentLines[lineIndex] = line.substring(0, startIndex) +\n                                           contentInsertion +\n                                           line.substring(startIndex,\n                                                              line.length);\n            };\n\n            defineInfos.forEach(function (info) {\n                var deps,\n                    contentInsertion = '',\n                    depString = '';\n\n                //Do the modifications \"backwards\", in other words, start with the\n                //one that is farthest down and work up, so that the ranges in the\n                //defineInfos still apply. So that means deps, id, then namespace.\n                if (info.needsId && moduleName) {\n                    contentInsertion += \"'\" + moduleName + \"',\";\n                }\n\n                if (info.depAction === 'scan') {\n                    deps = parse.getAnonDepsFromNode(info.factoryNode);\n\n                    if (deps.length) {\n                        depString = '[' + deps.map(function (dep) {\n                            return \"'\" + dep + \"'\";\n                        }) + ']';\n                    } else {\n                        depString = '[]';\n                    }\n                    depString +=  ',';\n\n                    if (info.factoryNode) {\n                        //Already have a named module, need to insert the\n                        //dependencies after the name.\n                        modLine(info.factoryNode.loc, depString);\n                    } else {\n                        contentInsertion += depString;\n                    }\n                }\n\n                if (contentInsertion) {\n                    modLine(info.firstArgLoc, contentInsertion);\n                }\n\n                //Do namespace last so that ui does not mess upthe parenRange\n                //used above.\n                if (namespace && !info.namespaceExists) {\n                    modLine(info.defineLoc, namespace + '.');\n                }\n\n                //Notify any listener for the found info\n                if (onFound) {\n                    onFound(info);\n                }\n            });\n\n            contents = contentLines.join('\\n');\n\n            return applySourceUrl(contents);\n        },\n\n        /**\n         * Modify the contents of a require.config/requirejs.config call. This\n         * call will LOSE any existing comments that are in the config string.\n         *\n         * @param  {String} fileContents String that may contain a config call\n         * @param  {Function} onConfig Function called when the first config\n         * call is found. It will be passed an Object which is the current\n         * config, and the onConfig function should return an Object to use\n         * as the config.\n         * @return {String} the fileContents with the config changes applied.\n         */\n        modifyConfig: function (fileContents, onConfig) {\n            var details = parse.findConfig(fileContents),\n                config = details.config;\n\n            if (config) {\n                config = onConfig(config);\n                if (config) {\n                    return transform.serializeConfig(config,\n                                              fileContents,\n                                              details.range[0],\n                                              details.range[1],\n                                              {\n                                                quote: details.quote\n                                              });\n                }\n            }\n\n            return fileContents;\n        },\n\n        serializeConfig: function (config, fileContents, start, end, options) {\n            //Calculate base level of indent\n            var indent, match, configString, outDentRegExp,\n                baseIndent = '',\n                startString = fileContents.substring(0, start),\n                existingConfigString = fileContents.substring(start, end),\n                lineReturn = existingConfigString.indexOf('\\r') === -1 ? '\\n' : '\\r\\n',\n                lastReturnIndex = startString.lastIndexOf('\\n');\n\n            //Get the basic amount of indent for the require config call.\n            if (lastReturnIndex === -1) {\n                lastReturnIndex = 0;\n            }\n\n            match = baseIndentRegExp.exec(startString.substring(lastReturnIndex + 1, start));\n            if (match && match[1]) {\n                baseIndent = match[1];\n            }\n\n            //Calculate internal indentation for config\n            match = indentRegExp.exec(existingConfigString);\n            if (match && match[1]) {\n                indent = match[1];\n            }\n\n            if (!indent || indent.length < baseIndent) {\n                indent = '  ';\n            } else {\n                indent = indent.substring(baseIndent.length);\n            }\n\n            outDentRegExp = new RegExp('(' + lineReturn + ')' + indent, 'g');\n\n            configString = transform.objectToString(config, {\n                                                    indent: indent,\n                                                    lineReturn: lineReturn,\n                                                    outDentRegExp: outDentRegExp,\n                                                    quote: options && options.quote\n                                                });\n\n            //Add in the base indenting level.\n            configString = applyIndent(configString, baseIndent, lineReturn);\n\n            return startString + configString + fileContents.substring(end);\n        },\n\n        /**\n         * Tries converting a JS object to a string. This will likely suck, and\n         * is tailored to the type of config expected in a loader config call.\n         * So, hasOwnProperty fields, strings, numbers, arrays and functions,\n         * no weird recursively referenced stuff.\n         * @param  {Object} obj        the object to convert\n         * @param  {Object} options    options object with the following values:\n         *         {String} indent     the indentation to use for each level\n         *         {String} lineReturn the type of line return to use\n         *         {outDentRegExp} outDentRegExp the regexp to use to outdent functions\n         *         {String} quote      the quote type to use, ' or \". Optional. Default is \"\n         * @param  {String} totalIndent the total indent to print for this level\n         * @return {String}            a string representation of the object.\n         */\n        objectToString: function (obj, options, totalIndent) {\n            var startBrace, endBrace, nextIndent,\n                first = true,\n                value = '',\n                lineReturn = options.lineReturn,\n                indent = options.indent,\n                outDentRegExp = options.outDentRegExp,\n                quote = options.quote || '\"';\n\n            totalIndent = totalIndent || '';\n            nextIndent = totalIndent + indent;\n\n            if (obj === null) {\n                value = 'null';\n            } else if (obj === undefined) {\n                value = 'undefined';\n            } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n                value = obj;\n            } else if (typeof obj === 'string') {\n                //Use double quotes in case the config may also work as JSON.\n                value = quote + lang.jsEscape(obj) + quote;\n            } else if (lang.isArray(obj)) {\n                lang.each(obj, function (item, i) {\n                    value += (i !== 0 ? ',' + lineReturn : '' ) +\n                        nextIndent +\n                        transform.objectToString(item,\n                                                 options,\n                                                 nextIndent);\n                });\n\n                startBrace = '[';\n                endBrace = ']';\n            } else if (lang.isFunction(obj) || lang.isRegExp(obj)) {\n                //The outdent regexp just helps pretty up the conversion\n                //just in node. Rhino strips comments and does a different\n                //indent scheme for Function toString, so not really helpful\n                //there.\n                value = obj.toString().replace(outDentRegExp, '$1');\n            } else {\n                //An object\n                lang.eachProp(obj, function (v, prop) {\n                    value += (first ? '': ',' + lineReturn) +\n                        nextIndent +\n                        (keyRegExp.test(prop) ? prop : quote + lang.jsEscape(prop) + quote )+\n                        ': ' +\n                        transform.objectToString(v,\n                                                 options,\n                                                 nextIndent);\n                    first = false;\n                });\n                startBrace = '{';\n                endBrace = '}';\n            }\n\n            if (startBrace) {\n                value = startBrace +\n                        lineReturn +\n                        value +\n                        lineReturn + totalIndent +\n                        endBrace;\n            }\n\n            return value;\n        }\n    };\n\n    return transform;\n});\n\n/*jslint */\n/*global define: false, console: false */\n\ndefine('skylark-rjs/commonJs',[\n    './parse'\n], function (\n    parse\n) {\n    'use strict';\n    var commonJs = {\n        //Set to false if you do not want this file to log. Useful in environments\n        //like node where you want the work to happen without noise.\n        useLog: true,\n\n        convertDir: function (commonJsPath, savePath,fs) {\n            var fileList, i,\n                jsFileRegExp = /\\.js$/,\n                fileName, convertedFileName, fileContents;\n\n            //Get list of files to convert.\n            fileList = fs.getFilteredFileList(commonJsPath, /\\w/, true);\n\n            //Normalize on front slashes and make sure the paths do not end in a slash.\n            commonJsPath = commonJsPath.replace(/\\\\/g, \"/\");\n            savePath = savePath.replace(/\\\\/g, \"/\");\n            if (commonJsPath.charAt(commonJsPath.length - 1) === \"/\") {\n                commonJsPath = commonJsPath.substring(0, commonJsPath.length - 1);\n            }\n            if (savePath.charAt(savePath.length - 1) === \"/\") {\n                savePath = savePath.substring(0, savePath.length - 1);\n            }\n\n            //Cycle through all the JS files and convert them.\n            if (!fileList || !fileList.length) {\n                if (commonJs.useLog) {\n                    if (commonJsPath === \"convert\") {\n                        //A request just to convert one file.\n                        console.log('\\n\\n' + commonJs.convert(savePath, fs.readFile(savePath),config));\n                    } else {\n                        console.log(\"No files to convert in directory: \" + commonJsPath);\n                    }\n                }\n            } else {\n                for (i = 0; i < fileList.length; i++) {\n                    fileName = fileList[i];\n                    convertedFileName = fileName.replace(commonJsPath, savePath);\n\n                    //Handle JS files.\n                    if (jsFileRegExp.test(fileName)) {\n                        fileContents = fs.readFile(fileName);\n                        fileContents = commonJs.convert(fileName, fileContents,config);\n                        fs.saveUtf8File(convertedFileName, fileContents);\n                    } else {\n                        //Just copy the file over.\n                        fs.copyFile(fileName, convertedFileName, true);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Does the actual file conversion.\n         *\n         * @param {String} fileName the name of the file.\n         *\n         * @param {String} fileContents the contents of a file :)\n         *\n         * @returns {String} the converted contents\n         */\n        convert: function (fileName, fileContents) {\n            //Strip out comments.\n            try {\n                var preamble = '',\n                    commonJsProps = parse.usesCommonJs(fileName, fileContents);\n\n                //First see if the module is not already RequireJS-formatted.\n                if (parse.usesAmdOrRequireJs(fileName, fileContents) || !commonJsProps) {\n                    return fileContents;\n                }\n\n                if (commonJsProps.dirname || commonJsProps.filename) {\n                    preamble = 'var __filename = module.uri || \"\", ' +\n                               '__dirname = __filename.substring(0, __filename.lastIndexOf(\"/\") + 1); ';\n                }\n\n                //Construct the wrapper boilerplate.\n                fileContents = 'define(function (require, exports, module) {' +\n                    preamble +\n                    fileContents +\n                    '\\n});\\n';\n\n            } catch (e) {\n                console.log(\"commonJs.convert: COULD NOT CONVERT: \" + fileName + \", so skipping it. Error was: \" + e);\n                return fileContents;\n            }\n\n            return fileContents;\n        }\n    };\n\n    return commonJs;\n});\n\n/*\n * This file patches require.js to communicate with the build system.\n */\n\n//Using sloppy since this uses eval for some code like plugins,\n//which may not be strict mode compliant. So if use strict is used\n//below they will have strict rules applied and may cause an error.\n/*jslint sloppy: true, nomen: true, plusplus: true, regexp: true */\n/*global require, define: true */\n\n//NOT asking for require as a dependency since the goal is to modify the\n//global require below\ndefine('skylark-rjs/requirePatch',[ \n    ///'env!env/file', \n    './pragma', \n    './parse', \n    './lang', \n    './logger',\n    './commonJs', \n    './prim'\n], function (\n    ///file,\n    pragma,\n    parse,\n    lang,\n    logger,\n    commonJs,\n    prim\n) {\n\n    var allowRun = true,\n        hasProp = lang.hasProp,\n        falseProp = lang.falseProp,\n        getOwn = lang.getOwn,\n        // Used to strip out use strict from toString()'d functions for the\n        // shim config since they will explicitly want to not be bound by strict,\n        // but some envs, explicitly xpcshell, adds a use strict.\n        useStrictRegExp = /['\"]use strict['\"];/g,\n        //Absolute path if starts with /, \\, or x:\n        absoluteUrlRegExp = /^[\\/\\\\]|^\\w:/;\n\n    //Turn off throwing on resolution conflict, that was just an older prim\n    //idea about finding errors early, but does not comply with how promises\n    //should operate.\n    prim.hideResolutionConflict = true;\n\n    //This method should be called when the patches to require should take hold.\n    return function (config) {\n        if (!allowRun) {\n            return;\n        }\n        allowRun = false;\n\n        var fs = config.env.fs;\n\n        var layer,\n            pluginBuilderRegExp = /([\"']?)pluginBuilder([\"']?)\\s*[=\\:]\\s*[\"']([^'\"\\s]+)[\"']/,\n            oldNewContext = require.s.newContext,\n            oldDef,\n\n            //create local undefined values for module and exports,\n            //so that when files are evaled in this function they do not\n            //see the node values used for r.js\n            exports,\n            module;\n\n        /**\n         * Reset \"global\" build caches that are kept around between\n         * build layer builds. Useful to do when there are multiple\n         * top level requirejs.optimize() calls.\n         */\n        require._cacheReset = function () {\n            //Stored raw text caches, used by browser use.\n            require._cachedRawText = {};\n            //Stored cached file contents for reuse in other layers.\n            require._cachedFileContents = {};\n            //Store which cached files contain a require definition.\n            require._cachedDefinesRequireUrls = {};\n        };\n        require._cacheReset();\n\n        /**\n         * Makes sure the URL is something that can be supported by the\n         * optimization tool.\n         * @param {String} url\n         * @returns {Boolean}\n         */\n        require._isSupportedBuildUrl = function (url) {\n            //Ignore URLs with protocols, hosts or question marks, means either network\n            //access is needed to fetch it or it is too dynamic. Note that\n            //on Windows, full paths are used for some urls, which include\n            //the drive, like c:/something, so need to test for something other\n            //than just a colon.\n            if (url.indexOf(\"://\") === -1 && url.indexOf(\"?\") === -1 &&\n                    url.indexOf('empty:') !== 0 && url.indexOf('//') !== 0) {\n                return true;\n            } else {\n                if (!layer.ignoredUrls[url]) {\n                    if (url.indexOf('empty:') === -1) {\n                        logger.info('Cannot optimize network URL, skipping: ' + url);\n                    }\n                    layer.ignoredUrls[url] = true;\n                }\n                return false;\n            }\n        };\n\n        function normalizeUrlWithBase(context, moduleName, url) {\n            //Adjust the URL if it was not transformed to use baseUrl, but only\n            //if the URL is not already an absolute path.\n            if (require.jsExtRegExp.test(moduleName) &&\n                !absoluteUrlRegExp.test(url)) {\n                url = (context.config.dir || context.config.dirBaseUrl) + url;\n            }\n            return url;\n        }\n\n        //Overrides the new context call to add existing tracking features.\n        require.s.newContext = function (name) {\n            var context = oldNewContext(name),\n                oldEnable = context.enable,\n                moduleProto = context.Module.prototype,\n                oldInit = moduleProto.init,\n                oldCallPlugin = moduleProto.callPlugin;\n\n            //Only do this for the context used for building.\n            if (name === '_') {\n                //For build contexts, do everything sync\n                context.nextTick = function (fn) {\n                    fn();\n                };\n\n                context.needFullExec = {};\n                context.fullExec = {};\n                context.plugins = {};\n                context.buildShimExports = {};\n\n                //Override the shim exports function generator to just\n                //spit out strings that can be used in the stringified\n                //build output.\n                context.makeShimExports = function (value) {\n                    var fn;\n                    if (context.config.wrapShim) {\n                        fn = function () {\n                            var str = 'return ';\n                            // If specifies an export that is just a global\n                            // name, no dot for a `this.` and such, then also\n                            // attach to the global, for `var a = {}` files\n                            // where the function closure would hide that from\n                            // the global object.\n                            if (value.exports && value.exports.indexOf('.') === -1) {\n                                str += 'root.' + value.exports + ' = ';\n                            }\n\n                            if (value.init) {\n                                str += '(' + value.init.toString()\n                                       .replace(useStrictRegExp, '') + '.apply(this, arguments))';\n                            }\n                            if (value.init && value.exports) {\n                                str += ' || ';\n                            }\n                            if (value.exports) {\n                                str += value.exports;\n                            }\n                            str += ';';\n                            return str;\n                        };\n                    } else {\n                        fn = function () {\n                            return '(function (global) {\\n' +\n                                '    return function () {\\n' +\n                                '        var ret, fn;\\n' +\n                                (value.init ?\n                                        ('       fn = ' + value.init.toString()\n                                        .replace(useStrictRegExp, '') + ';\\n' +\n                                        '        ret = fn.apply(global, arguments);\\n') : '') +\n                                (value.exports ?\n                                        '        return ret || global.' + value.exports + ';\\n' :\n                                        '        return ret;\\n') +\n                                '    };\\n' +\n                                '}(this))';\n                        };\n                    }\n\n                    return fn;\n                };\n\n                context.enable = function (depMap, parent) {\n                    var id = depMap.id,\n                        parentId = parent && parent.map.id,\n                        needFullExec = context.needFullExec,\n                        fullExec = context.fullExec,\n                        mod = getOwn(context.registry, id);\n\n                    if (mod && !mod.defined) {\n                        if (parentId && getOwn(needFullExec, parentId)) {\n                            needFullExec[id] = depMap;\n                        }\n\n                    } else if ((getOwn(needFullExec, id) && falseProp(fullExec, id)) ||\n                               (parentId && getOwn(needFullExec, parentId) &&\n                                falseProp(fullExec, id))) {\n                        context.require.undef(id);\n                    }\n\n                    return oldEnable.apply(context, arguments);\n                };\n\n                //Override load so that the file paths can be collected.\n                context.load = function (moduleName, url) {\n                    /*jslint evil: true */\n                    var contents, pluginBuilderMatch, builderName,\n                        shim, shimExports;\n\n                    //Do not mark the url as fetched if it is\n                    //not an empty: URL, used by the optimizer.\n                    //In that case we need to be sure to call\n                    //load() for each module that is mapped to\n                    //empty: so that dependencies are satisfied\n                    //correctly.\n                    if (url.indexOf('empty:') === 0) {\n                        delete context.urlFetched[url];\n                    }\n\n                    //Only handle urls that can be inlined, so that means avoiding some\n                    //URLs like ones that require network access or may be too dynamic,\n                    //like JSONP\n                    if (require._isSupportedBuildUrl(url)) {\n                        //Adjust the URL if it was not transformed to use baseUrl.\n                        url = normalizeUrlWithBase(context, moduleName, url);\n\n                        //Save the module name to path  and path to module name mappings.\n                        layer.buildPathMap[moduleName] = url;\n                        layer.buildFileToModule[url] = moduleName;\n\n                        if (hasProp(context.plugins, moduleName)) {\n                            //plugins need to have their source evaled as-is.\n                            context.needFullExec[moduleName] = true;\n                        }\n\n                        prim().start(function () {\n                            if (hasProp(require._cachedFileContents, url) &&\n                                    (falseProp(context.needFullExec, moduleName) ||\n                                    getOwn(context.fullExec, moduleName))) {\n                                contents = require._cachedFileContents[url];\n\n                                //If it defines require, mark it so it can be hoisted.\n                                //Done here and in the else below, before the\n                                //else block removes code from the contents.\n                                //Related to #263\n                                if (!layer.existingRequireUrl && require._cachedDefinesRequireUrls[url]) {\n                                    layer.existingRequireUrl = url;\n                                }\n                            } else {\n                                //Load the file contents, process for conditionals, then\n                                //evaluate it.\n                                return require._cacheReadAsync(url,undefined,fs).then(function (text) {\n                                    contents = text;\n\n                                    if (context.config.cjsTranslate &&\n                                        (!context.config.shim || !lang.hasProp(context.config.shim, moduleName))) {\n                                        contents = commonJs.convert(url, contents);\n                                    }\n\n                                    //If there is a read filter, run it now.\n                                    if (context.config.onBuildRead) {\n                                        contents = context.config.onBuildRead(moduleName, url, contents);\n                                    }\n\n                                    contents = pragma.process(url, contents, context.config, 'OnExecute');\n\n                                    //Find out if the file contains a require() definition. Need to know\n                                    //this so we can inject plugins right after it, but before they are needed,\n                                    //and to make sure this file is first, so that define calls work.\n                                    try {\n                                        if (!layer.existingRequireUrl && parse.definesRequire(url, contents)) {\n                                            layer.existingRequireUrl = url;\n                                            require._cachedDefinesRequireUrls[url] = true;\n                                        }\n                                    } catch (e1) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e1);\n                                    }\n                                }).then(function () {\n                                    if (hasProp(context.plugins, moduleName)) {\n                                        //This is a loader plugin, check to see if it has a build extension,\n                                        //otherwise the plugin will act as the plugin builder too.\n                                        pluginBuilderMatch = pluginBuilderRegExp.exec(contents);\n                                        if (pluginBuilderMatch) {\n                                            //Load the plugin builder for the plugin contents.\n                                            builderName = context.makeModuleMap(pluginBuilderMatch[3],\n                                                                                context.makeModuleMap(moduleName),\n                                                                                null,\n                                                                                true).id;\n                                            return require._cacheReadAsync(context.nameToUrl(builderName),undefined,fs);\n                                        }\n                                    }\n                                    return contents;\n                                }).then(function (text) {\n                                    contents = text;\n\n                                    //Parse out the require and define calls.\n                                    //Do this even for plugins in case they have their own\n                                    //dependencies that may be separate to how the pluginBuilder works.\n                                    try {\n                                        if (falseProp(context.needFullExec, moduleName)) {\n                                            contents = parse(moduleName, url, contents, {\n                                                insertNeedsDefine: true,\n                                                has: context.config.has,\n                                                findNestedDependencies: context.config.findNestedDependencies\n                                            });\n                                        }\n                                    } catch (e2) {\n                                        throw new Error('Parse error using esprima ' +\n                                                        'for file: ' + url + '\\n' + e2);\n                                    }\n\n                                    require._cachedFileContents[url] = contents;\n                                });\n                            }\n                        }).then(function () {\n                            if (contents) {\n                                eval(contents);\n                            }\n\n                            try {\n                                //If have a string shim config, and this is\n                                //a fully executed module, try to see if\n                                //it created a variable in this eval scope\n                                if (getOwn(context.needFullExec, moduleName)) {\n                                    shim = getOwn(context.config.shim, moduleName);\n                                    if (shim && shim.exports) {\n                                        shimExports = eval(shim.exports);\n                                        if (typeof shimExports !== 'undefined') {\n                                            context.buildShimExports[moduleName] = shimExports;\n                                        }\n                                    }\n                                }\n\n                                //Need to close out completion of this module\n                                //so that listeners will get notified that it is available.\n                                context.completeLoad(moduleName);\n                            } catch (e) {\n                                //Track which module could not complete loading.\n                                if (!e.moduleTree) {\n                                    e.moduleTree = [];\n                                }\n                                e.moduleTree.push(moduleName);\n                                throw e;\n                            }\n                        }).then(null, function (eOuter) {\n\n                            if (!eOuter.fileName) {\n                                eOuter.fileName = url;\n                            }\n                            throw eOuter;\n                        }).end();\n                    } else {\n                        //With unsupported URLs still need to call completeLoad to\n                        //finish loading.\n                        context.completeLoad(moduleName);\n                    }\n                };\n\n                //Marks module has having a name, and optionally executes the\n                //callback, but only if it meets certain criteria.\n                context.execCb = function (name, cb, args, exports) {\n                    var buildShimExports = getOwn(layer.context.buildShimExports, name);\n\n                    if (buildShimExports) {\n                        return buildShimExports;\n                    } else if (cb.__requireJsBuild || getOwn(layer.context.needFullExec, name)) {\n                        return cb.apply(exports, args);\n                    }\n                    return undefined;\n                };\n\n                moduleProto.init = function (depMaps) {\n                    if (context.needFullExec[this.map.id]) {\n                        lang.each(depMaps, lang.bind(this, function (depMap) {\n                            if (typeof depMap === 'string') {\n                                depMap = context.makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false, true);\n                            }\n\n                            if (!context.fullExec[depMap.id]) {\n                                context.require.undef(depMap.id);\n                            }\n                        }));\n                    }\n\n                    return oldInit.apply(this, arguments);\n                };\n\n                moduleProto.callPlugin = function () {\n                    var map = this.map,\n                        pluginMap = context.makeModuleMap(map.prefix),\n                        pluginId = pluginMap.id,\n                        pluginMod = getOwn(context.registry, pluginId);\n\n                    context.plugins[pluginId] = true;\n                    context.needFullExec[pluginId] = map;\n\n                    //If the module is not waiting to finish being defined,\n                    //undef it and start over, to get full execution.\n                    if (falseProp(context.fullExec, pluginId) && (!pluginMod || pluginMod.defined)) {\n                        context.require.undef(pluginMap.id);\n                    }\n\n                    return oldCallPlugin.apply(this, arguments);\n                };\n            }\n\n            return context;\n        };\n\n        //Clear up the existing context so that the newContext modifications\n        //above will be active.\n        delete require.s.contexts._;\n\n        /** Reset state for each build layer pass. */\n        require._buildReset = function () {\n            var oldContext = require.s.contexts._;\n\n            //Clear up the existing context.\n            delete require.s.contexts._;\n\n            //Set up new context, so the layer object can hold onto it.\n            require({});\n\n            layer = require._layer = {\n                buildPathMap: {},\n                buildFileToModule: {},\n                buildFilePaths: [],\n                pathAdded: {},\n                modulesWithNames: {},\n                needsDefine: {},\n                existingRequireUrl: \"\",\n                ignoredUrls: {},\n                context: require.s.contexts._\n            };\n\n            //Return the previous context in case it is needed, like for\n            //the basic config object.\n            return oldContext;\n        };\n\n        require._buildReset();\n\n        //Override define() to catch modules that just define an object, so that\n        //a dummy define call is not put in the build file for them. They do\n        //not end up getting defined via context.execCb, so we need to catch them\n        //at the define call.\n        oldDef = define;\n\n        //This function signature does not have to be exact, just match what we\n        //are looking for.\n        define = function (name) {\n            if (typeof name === \"string\" && falseProp(layer.needsDefine, name)) {\n                layer.modulesWithNames[name] = true;\n            }\n            return oldDef.apply(require, arguments);\n        };\n\n        define.amd = oldDef.amd;\n\n        //Add some utilities for plugins\n        require._readFile = fs.readFile;\n        require._fileExists = function (path) {\n            return fs.exists(path);\n        };\n\n        //Called when execManager runs for a dependency. Used to figure out\n        //what order of execution.\n        require.onResourceLoad = function (context, map) {\n            var id = map.id,\n                url;\n\n            // Fix up any maps that need to be normalized as part of the fullExec\n            // plumbing for plugins to participate in the build.\n            if (context.plugins && lang.hasProp(context.plugins, id)) {\n                lang.eachProp(context.needFullExec, function(value, prop) {\n                    // For plugin entries themselves, they do not have a map\n                    // value in needFullExec, just a \"true\" entry.\n                    if (value !== true && value.prefix === id && value.unnormalized) {\n                        var map = context.makeModuleMap(value.originalName, value.parentMap);\n                        context.needFullExec[map.id] = map;\n                    }\n                });\n            }\n\n            //If build needed a full execution, indicate it\n            //has been done now. But only do it if the context is tracking\n            //that. Only valid for the context used in a build, not for\n            //other contexts being run, like for useLib, plain requirejs\n            //use in node/rhino.\n            if (context.needFullExec && getOwn(context.needFullExec, id)) {\n                context.fullExec[id] = map;\n            }\n\n            //A plugin.\n            if (map.prefix) {\n                if (falseProp(layer.pathAdded, id)) {\n                    layer.buildFilePaths.push(id);\n                    //For plugins the real path is not knowable, use the name\n                    //for both module to file and file to module mappings.\n                    layer.buildPathMap[id] = id;\n                    layer.buildFileToModule[id] = id;\n                    layer.modulesWithNames[id] = true;\n                    layer.pathAdded[id] = true;\n                }\n            } else if (map.url && require._isSupportedBuildUrl(map.url)) {\n                //If the url has not been added to the layer yet, and it\n                //is from an actual file that was loaded, add it now.\n                url = normalizeUrlWithBase(context, id, map.url);\n                if (!layer.pathAdded[url] && getOwn(layer.buildPathMap, id)) {\n                    //Remember the list of dependencies for this layer.\n                    layer.buildFilePaths.push(url);\n                    layer.pathAdded[url] = true;\n                }\n            }\n        };\n\n        //Called by output of the parse() function, when a file does not\n        //explicitly call define, probably just require, but the parse()\n        //function normalizes on define() for dependency mapping and file\n        //ordering works correctly.\n        require.needsDefine = function (moduleName) {\n            layer.needsDefine[moduleName] = true;\n        };\n    };\n});\n\n/*jslint plusplus: true, nomen: true, regexp: true  */\n/*global define, requirejs, java, process, console */\n\n\ndefine('skylark-rjs/build',[\n    \"./rjs\",\n    \"./lang\",\n    \"./prim\",\n    \"./logger\",\n    ///\"env!env/file\",\n    \"./parse\",\n    \"./optimize\",\n    \"./pragma\",\n    \"./transform\",\n    \"./requirePatch\",\n    ///\"env\",\n    \"./commonJs\",\n    \"./source-map\"\n],function (\n    require,\n    lang,\n    prim,\n    logger,\n    parse,\n    optimize,\n    pragma,\n    transform,\n    requirePatch,\n    commonJs,\n    sourceMap\n\n) {\n    'use strict';\n\n    var build,\n        ///lang = require('lang'),\n        ///prim = require('prim'),\n        ///logger = require('logger'),\n        ///file = require('env!env/file'),\n        ///parse = require('parse'),\n        ///optimize = require('optimize'),\n        ///pragma = require('pragma'),\n        ///transform = require('transform'),\n        ///requirePatch = require('requirePatch'),\n        ///env = require('env'),\n        ///commonJs = require('commonJs'),\n        ///SourceMapGenerator = require('source-map').SourceMapGenerator,\n        SourceMapGenerator = sourceMap.SourceMapGenerator,\n        hasProp = lang.hasProp,\n        getOwn = lang.getOwn,\n        falseProp = lang.falseProp,\n        endsWithSemiColonRegExp = /;\\s*$/,\n        endsWithSlashRegExp = /[\\/\\\\]$/,\n        resourceIsModuleIdRegExp = /^[\\w\\/\\\\\\.]+$/,\n        deepCopyProps = {\n            layer: true\n        };\n\n    //Deep copy a config object, but do not copy over the \"layer\" property,\n    //as it can be a deeply nested structure with a full requirejs context.\n    function copyConfig(obj) {\n        return lang.deeplikeCopy(obj, deepCopyProps);\n    }\n\n    prim.nextTick = function (fn) {\n        fn();\n    };\n\n    //Now map require to the outermost requirejs, now that we have\n    //local dependencies for this module. The rest of the require use is\n    //manipulating the requirejs loader.\n    ///require = requirejs;\n\n    //Caching function for performance. Attached to\n    //require so it can be reused in requirePatch.js. _cachedRawText\n    //set up by requirePatch.js\n    require._cacheReadAsync = function (path, encoding,fs) {\n        var d;\n\n        if (lang.hasProp(require._cachedRawText, path)) {\n            d = prim();\n            d.resolve(require._cachedRawText[path]);\n            return d.promise;\n        } else {\n            return fs.readFileAsync(path, encoding).then(function (text) {\n                require._cachedRawText[path] = text;\n                return text;\n            });\n        }\n    };\n\n    function makeBuildBaseConfig(fs) {\n        return {\n            appDir: \"\",\n            pragmas: {},\n            paths: {},\n            optimize: \"uglify\",\n            optimizeCss: \"standard.keepLines.keepWhitespace\",\n            inlineText: true,\n            isBuild: true,\n            optimizeAllPluginResources: false,\n            findNestedDependencies: false,\n            preserveLicenseComments: true,\n            writeBuildTxt: true,\n            //Some builds can take a while, up the default limit.\n            waitSeconds: 30,\n            //By default, all files/directories are copied, unless\n            //they match this regexp, by default just excludes .folders\n            dirExclusionRegExp: fs.dirExclusionRegExp,\n            _buildPathToModuleIndex: {}\n        };\n    }\n\n    /**\n     * Some JS may not be valid if concatenated with other JS, in particular\n     * the style of omitting semicolons and rely on ASI. Add a semicolon in\n     * those cases.\n     */\n    function addSemiColon(text, config) {\n        if (config.skipSemiColonInsertion || endsWithSemiColonRegExp.test(text)) {\n            return text;\n        } else {\n            return text + \";\";\n        }\n    }\n\n    function endsWithSlash(dirName) {\n        if (dirName.charAt(dirName.length - 1) !== \"/\") {\n            dirName += \"/\";\n        }\n        return dirName;\n    }\n\n    function endsWithNewLine(text) {\n        if (text.charAt(text.length - 1) !== \"\\n\") {\n            text += \"\\n\";\n        }\n        return text;\n    }\n\n    //Method used by plugin writeFile calls, defined up here to avoid\n    //jslint warning about \"making a function in a loop\".\n    function makeWriteFile(namespace, layer) {\n        function writeFile(name, contents) {\n            logger.trace('Saving plugin-optimized file: ' + name);\n            file.saveUtf8File(name, contents);\n        }\n\n        writeFile.asModule = function (moduleName, fileName, contents) {\n            writeFile(fileName,\n                build.toTransport(namespace, moduleName, fileName, contents, layer));\n        };\n\n        return writeFile;\n    }\n\n    /**\n     * Appends singleContents to fileContents and returns the result.  If a sourceMapGenerator\n     * is provided, adds singleContents to the source map.\n     *\n     * @param {string} fileContents - The file contents to which to append singleContents\n     * @param {string} singleContents - The additional contents to append to fileContents\n     * @param {string} path - An absolute path of a file whose name to use in the source map.\n     * The file need not actually exist if the code in singleContents is generated.\n     * @param {{out: ?string, baseUrl: ?string}} config - The build configuration object.\n     * @param {?{_buildPath: ?string}} module - An object with module information.\n     * @param {?SourceMapGenerator} sourceMapGenerator - An instance of Mozilla's SourceMapGenerator,\n     * or null if no source map is being generated.\n     * @returns {string} fileContents with singleContents appended\n     */\n    function appendToFileContents(fileContents, singleContents, path, config, module, sourceMapGenerator) {\n        var refPath, sourceMapPath, resourcePath, pluginId, sourceMapLineNumber, lineCount, parts, i;\n        if (sourceMapGenerator) {\n            if (config.out) {\n                refPath = config.baseUrl;\n            } else if (module && module._buildPath) {\n                refPath = module._buildPath;\n            } else {\n                refPath = \"\";\n            }\n            parts = path.split('!');\n            if (parts.length === 1) {\n                //Not a plugin resource, fix the path\n                sourceMapPath = build.makeRelativeFilePath(refPath, path);\n            } else {\n                //Plugin resource. If it looks like just a plugin\n                //followed by a module ID, pull off the plugin\n                //and put it at the end of the name, otherwise\n                //just leave it alone.\n                pluginId = parts.shift();\n                resourcePath = parts.join('!');\n                if (resourceIsModuleIdRegExp.test(resourcePath)) {\n                    sourceMapPath = build.makeRelativeFilePath(refPath, require.toUrl(resourcePath)) +\n                                    '!' + pluginId;\n                } else {\n                    sourceMapPath = path;\n                }\n            }\n\n            sourceMapLineNumber = fileContents.split('\\n').length - 1;\n            lineCount = singleContents.split('\\n').length;\n            for (i = 1; i <= lineCount; i += 1) {\n                sourceMapGenerator.addMapping({\n                    generated: {\n                        line: sourceMapLineNumber + i,\n                        column: 0\n                    },\n                    original: {\n                        line: i,\n                        column: 0\n                    },\n                    source: sourceMapPath\n                });\n            }\n\n            //Store the content of the original in the source\n            //map since other transforms later like minification\n            //can mess up translating back to the original\n            //source.\n            sourceMapGenerator.setSourceContent(sourceMapPath, singleContents);\n        }\n        fileContents += singleContents;\n        return fileContents;\n    }\n\n    /**\n     * Main API entry point into the build. The args argument can either be\n     * an array of arguments (like the onese passed on a command-line),\n     * or it can be a JavaScript object that has the format of a build profile\n     * file.\n     *\n     * If it is an object, then in addition to the normal properties allowed in\n     * a build profile file, the object should contain one other property:\n     *\n     * The object could also contain a \"buildFile\" property, which is a string\n     * that is the file path to a build profile that contains the rest\n     * of the build profile directives.\n     *\n     * This function does not return a status, it should throw an error if\n     * there is a problem completing the build.\n     */\n    build = function (args) {\n        var buildFile, cmdConfig, errorMsg, errorStack, stackMatch, errorTree,\n            i, j, errorMod,\n            stackRegExp = /( {4}at[^\\n]+)\\n/,\n            standardIndent = '  ';\n\n        return prim().start(function () {\n            if (!args || lang.isArray(args)) {\n                if (!args || args.length < 1) {\n                    logger.error(\"build.js buildProfile.js\\n\" +\n                          \"where buildProfile.js is the name of the build file (see example.build.js for hints on how to make a build file).\");\n                    return undefined;\n                }\n\n                //Next args can include a build file path as well as other build args.\n                //build file path comes first. If it does not contain an = then it is\n                //a build file path. Otherwise, just all build args.\n                if (args[0].indexOf(\"=\") === -1) {\n                    buildFile = args[0];\n                    args.splice(0, 1);\n                }\n\n                //Remaining args are options to the build\n                cmdConfig = build.convertArrayToObject(args);\n                cmdConfig.buildFile = buildFile;\n            } else {\n                cmdConfig = args;\n            }\n\n            return build._run(cmdConfig);\n        }).then(null, function (e) {\n            var err;\n\n            errorMsg = e.toString();\n            errorTree = e.moduleTree;\n            stackMatch = stackRegExp.exec(errorMsg);\n\n            if (stackMatch) {\n                errorMsg += errorMsg.substring(0, stackMatch.index + stackMatch[0].length + 1);\n            }\n\n            //If a module tree that shows what module triggered the error,\n            //print it out.\n            if (errorTree && errorTree.length > 0) {\n                errorMsg += '\\nIn module tree:\\n';\n\n                for (i = errorTree.length - 1; i > -1; i--) {\n                    errorMod = errorTree[i];\n                    if (errorMod) {\n                        for (j = errorTree.length - i; j > -1; j--) {\n                            errorMsg += standardIndent;\n                        }\n                        errorMsg += errorMod + '\\n';\n                    }\n                }\n\n                logger.error(errorMsg);\n            }\n\n            errorStack = e.stack;\n\n            if (typeof args === 'string' && args.indexOf('stacktrace=true') !== -1) {\n                errorMsg += '\\n' + errorStack;\n            } else {\n                if (!stackMatch && errorStack) {\n                    //Just trim out the first \"at\" in the stack.\n                    stackMatch = stackRegExp.exec(errorStack);\n                    if (stackMatch) {\n                        errorMsg += '\\n' + stackMatch[0] || '';\n                    }\n                }\n            }\n\n            err = new Error(errorMsg);\n            err.originalError = e;\n            throw err;\n        });\n    };\n\n    build._run = function (cmdConfig) {\n        var buildPaths, fileName, fileNames,\n            paths, i,\n            baseConfig, config,\n            modules, srcPath, buildContext,\n            destPath, moduleMap, parentModuleMap, context,\n            resources, resource, plugin, fileContents,\n            pluginProcessed = {},\n            buildFileContents = \"\",\n            pluginCollector = {},\n            fs;\n\n        return prim().start(function () {\n            var prop;\n\n            //Can now run the patches to require.js to allow it to be used for\n            //build generation. Do it here instead of at the top of the module\n            //because we want normal require behavior to load the build tool\n            //then want to switch to build mode.\n\n            config = build.createConfig(cmdConfig);\n            paths = config.paths;\n            fs = config.env.fs;\n\n            requirePatch(config);\n\n\n            //Remove the previous build dir, in case it contains source transforms,\n            //like the ones done with onBuildRead and onBuildWrite.\n            if (config.dir && !config.keepBuildDir && fs.exists(config.dir)) {\n                fs.deleteFile(config.dir);\n            }\n\n            if (!config.out && !config.cssIn) {\n                //This is not just a one-off file build but a full build profile, with\n                //lots of files to process.\n\n                //First copy all the baseUrl content\n                fs.copyDir((config.appDir || config.baseUrl), config.dir, /\\w/, true);\n\n                //Adjust baseUrl if config.appDir is in play, and set up build output paths.\n                buildPaths = {};\n                if (config.appDir) {\n                    //All the paths should be inside the appDir, so just adjust\n                    //the paths to use the dirBaseUrl\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            buildPaths[prop] = paths[prop].replace(config.appDir, config.dir);\n                        }\n                    }\n                } else {\n                    //If no appDir, then make sure to copy the other paths to this directory.\n                    for (prop in paths) {\n                        if (hasProp(paths, prop)) {\n                            //Set up build path for each path prefix, but only do so\n                            //if the path falls out of the current baseUrl\n                            if (paths[prop].indexOf(config.baseUrl) === 0) {\n                                buildPaths[prop] = paths[prop].replace(config.baseUrl, config.dirBaseUrl);\n                            } else {\n                                buildPaths[prop] = paths[prop] === 'empty:' ? 'empty:' : prop;\n\n                                //Make sure source path is fully formed with baseUrl,\n                                //if it is a relative URL.\n                                srcPath = paths[prop];\n                                if (srcPath.indexOf('/') !== 0 && srcPath.indexOf(':') === -1) {\n                                    srcPath = config.baseUrl + srcPath;\n                                }\n\n                                destPath = config.dirBaseUrl + buildPaths[prop];\n\n                                //Skip empty: paths\n                                if (srcPath !== 'empty:') {\n                                    //If the srcPath is a directory, copy the whole directory.\n                                    if (fs.exists(srcPath) && fs.isDirectory(srcPath)) {\n                                        //Copy files to build area. Copy all files (the /\\w/ regexp)\n                                        fs.copyDir(srcPath, destPath, /\\w/, true);\n                                    } else {\n                                        //Try a .js extension\n                                        srcPath += '.js';\n                                        destPath += '.js';\n                                        fs.copyFile(srcPath, destPath);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            //Figure out source file location for each module layer. Do this by seeding require\n            //with source area configuration. This is needed so that later the module layers\n            //can be manually copied over to the source area, since the build may be\n            //require multiple times and the above copyDir call only copies newer files.\n            require({\n                baseUrl: config.baseUrl,\n                paths: paths,\n                packagePaths: config.packagePaths,\n                packages: config.packages\n            });\n            buildContext = require.s.contexts._;\n            modules = config.modules;\n\n            if (modules) {\n                modules.forEach(function (module) {\n                    if (module.name) {\n                        module._sourcePath = buildContext.nameToUrl(module.name);\n                        //If the module does not exist, and this is not a \"new\" module layer,\n                        //as indicated by a true \"create\" property on the module, and\n                        //it is not a plugin-loaded resource, and there is no\n                        //'rawText' containing the module's source then throw an error.\n                        if (!fs.exists(module._sourcePath) && !module.create &&\n                                module.name.indexOf('!') === -1 &&\n                                (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                            throw new Error(\"ERROR: module path does not exist: \" +\n                                            module._sourcePath + \" for module named: \" + module.name +\n                                            \". Path is relative to: \" + fs.absPath('.'));\n                        }\n                    }\n                });\n            }\n\n            if (config.out) {\n                //Just set up the _buildPath for the module layer.\n                require(config);\n                if (!config.cssIn) {\n                    config.modules[0]._buildPath = typeof config.out === 'function' ?\n                                                   'FUNCTION' : config.out;\n                }\n            } else if (!config.cssIn) {\n                //Now set up the config for require to use the build area, and calculate the\n                //build file locations. Pass along any config info too.\n                baseConfig = {\n                    baseUrl: config.dirBaseUrl,\n                    paths: buildPaths\n                };\n\n                lang.mixin(baseConfig, config);\n                require(baseConfig);\n\n                if (modules) {\n                    modules.forEach(function (module) {\n                        if (module.name) {\n                            module._buildPath = buildContext.nameToUrl(module.name, null);\n\n                            //If buildPath and sourcePath are the same, throw since this\n                            //would result in modifying source. This condition can happen\n                            //with some more tricky paths: config and appDir/baseUrl\n                            //setting, which is a sign of incorrect config.\n                            if (module._buildPath === module._sourcePath &&\n                                !config.allowSourceOverwrites) {\n                                throw new Error('Module ID \\'' + module.name  +\n                                                '\\' has a source path that is same as output path: ' +\n                                                module._sourcePath +\n                                                '. Stopping, config is malformed.');\n                            }\n\n                            // Copy the file, but only if it is not provided in rawText.\n                            if (!module.create && (!config.rawText || !lang.hasProp(config.rawText, module.name))) {\n                                fs.copyFile(module._sourcePath, module._buildPath);\n                            }\n                        }\n                    });\n                }\n            }\n\n            //Run CSS optimizations before doing JS module tracing, to allow\n            //things like text loader plugins loading CSS to get the optimized\n            //CSS.\n            if (config.optimizeCss && config.optimizeCss !== \"none\" && config.dir) {\n                buildFileContents += optimize.css(config.dir, config);\n            }\n        }).then(function() {\n            baseConfig = copyConfig(require.s.contexts._.config);\n        }).then(function () {\n            var actions = [];\n\n            if (modules) {\n                actions = modules.map(function (module, i) {\n                    return function () {\n                        //Save off buildPath to module index in a hash for quicker\n                        //lookup later.\n                        config._buildPathToModuleIndex[fs.normalize(module._buildPath)] = i;\n\n                        //Call require to calculate dependencies.\n                        return build.traceDependencies(module, config, baseConfig)\n                            .then(function (layer) {\n                                module.layer = layer;\n                            });\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            var actions;\n\n            if (modules) {\n                //Now build up shadow layers for anything that should be excluded.\n                //Do this after tracing dependencies for each module, in case one\n                //of those modules end up being one of the excluded values.\n                actions = modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            module.excludeLayers = [];\n                            return prim.serial(module.exclude.map(function (exclude, i) {\n                                return function () {\n                                    //See if it is already in the list of modules.\n                                    //If not trace dependencies for it.\n                                    var found = build.findBuildModule(exclude, modules);\n                                    if (found) {\n                                        module.excludeLayers[i] = found;\n                                    } else {\n                                        return build.traceDependencies({name: exclude}, config, baseConfig)\n                                            .then(function (layer) {\n                                                module.excludeLayers[i] = { layer: layer };\n                                            });\n                                    }\n                                };\n                            }));\n                        }\n                    };\n                });\n\n                return prim.serial(actions);\n            }\n        }).then(function () {\n            if (modules) {\n                return prim.serial(modules.map(function (module) {\n                    return function () {\n                        if (module.exclude) {\n                            //module.exclude is an array of module names. For each one,\n                            //get the nested dependencies for it via a matching entry\n                            //in the module.excludeLayers array.\n                            module.exclude.forEach(function (excludeModule, i) {\n                                var excludeLayer = module.excludeLayers[i].layer,\n                                    map = excludeLayer.buildFileToModule;\n                                excludeLayer.buildFilePaths.forEach(function(filePath){\n                                    build.removeModulePath(map[filePath], filePath, module.layer);\n                                });\n                            });\n                        }\n                        if (module.excludeShallow) {\n                            //module.excludeShallow is an array of module names.\n                            //shallow exclusions are just that module itself, and not\n                            //its nested dependencies.\n                            module.excludeShallow.forEach(function (excludeShallowModule) {\n                                var path = getOwn(module.layer.buildPathMap, excludeShallowModule);\n                                if (path) {\n                                    build.removeModulePath(excludeShallowModule, path, module.layer);\n                                }\n                            });\n                        }\n\n                        //Flatten them and collect the build output for each module.\n                        return build.flattenModule(module, module.layer, config).then(function (builtModule) {\n                            var finalText, baseName;\n                            //Save it to a temp file for now, in case there are other layers that\n                            //contain optimized content that should not be included in later\n                            //layer optimizations. See issue #56.\n                            if (module._buildPath === 'FUNCTION') {\n                                module._buildText = builtModule.text;\n                                module._buildSourceMap = builtModule.sourceMap;\n                            } else {\n                                finalText = builtModule.text;\n                                if (builtModule.sourceMap) {\n                                    baseName = module._buildPath.split('/');\n                                    baseName = baseName.pop();\n                                    finalText += '\\n//# sourceMappingURL=' + baseName + '.map';\n                                    fs.saveUtf8File(module._buildPath + '.map', builtModule.sourceMap);\n                                }\n                                fs.saveUtf8File(module._buildPath + '-temp', finalText);\n\n                            }\n                            buildFileContents += builtModule.buildText;\n                        });\n                    };\n                }));\n            }\n        }).then(function () {\n            var moduleName, outOrigSourceMap,\n                bundlesConfig = {},\n                bundlesConfigOutFile = config.bundlesConfigOutFile;\n\n            if (modules) {\n                //Now move the build layers to their final position.\n                modules.forEach(function (module) {\n                    var entryConfig,\n                        finalPath = module._buildPath;\n\n                    if (finalPath !== 'FUNCTION') {\n                        if (fs.exists(finalPath)) {\n                            fs.deleteFile(finalPath);\n                        }\n                        fs.renameFile(finalPath + '-temp', finalPath);\n\n                        //If bundles config should be written out, scan the\n                        //built file for module IDs. Favor doing this reparse\n                        //since tracking the IDs as the file is built has some\n                        //edge cases around files that had more than one ID in\n                        //them already, and likely loader plugin-written contents.\n                        if (bundlesConfigOutFile) {\n                            entryConfig = bundlesConfig[module.name] = [];\n                            var bundleContents = fs.readFile(finalPath);\n                            var excludeMap = {};\n                            excludeMap[module.name] = true;\n                            var parsedIds = parse.getAllNamedDefines(bundleContents, excludeMap);\n                            entryConfig.push.apply(entryConfig, parsedIds);\n                        }\n\n                        //And finally, if removeCombined is specified, remove\n                        //any of the files that were used in this layer.\n                        //Be sure not to remove other build layers.\n                        if (config.removeCombined && !config.out) {\n                            module.layer.buildFilePaths.forEach(function (path) {\n                                var isLayer = modules.some(function (mod) {\n                                        return mod._buildPath === path;\n                                    }),\n                                    relPath = build.makeRelativeFilePath(config.dir, path);\n\n                                if (fs.exists(path) &&\n                                    // not a build layer target\n                                    !isLayer &&\n                                    // not outside the build directory\n                                    relPath.indexOf('..') !== 0) {\n                                    fs.deleteFile(path);\n                                }\n                            });\n                        }\n                    }\n\n                    //Signal layer is done\n                    if (config.onModuleBundleComplete) {\n                        config.onModuleBundleComplete(module.onCompleteData);\n                    }\n                });\n\n                //Write out bundles config, if it is wanted.\n                if (bundlesConfigOutFile) {\n                    var text = fs.readFile(bundlesConfigOutFile);\n                    text = transform.modifyConfig(text, function (config) {\n                        if (!config.bundles) {\n                            config.bundles = {};\n                        }\n\n                        lang.eachProp(bundlesConfig, function (value, prop) {\n                            config.bundles[prop] = value;\n                        });\n\n                        return config;\n                    });\n\n                    fs.saveUtf8File(bundlesConfigOutFile, text);\n                }\n            }\n\n            //If removeCombined in play, remove any empty directories that\n            //may now exist because of its use\n            if (config.removeCombined && !config.out && config.dir) {\n                fs.deleteEmptyDirs(config.dir);\n            }\n\n            //Do other optimizations.\n            if (config.out && !config.cssIn) {\n                //Just need to worry about one JS file.\n                fileName = config.modules[0]._buildPath;\n                if (fileName === 'FUNCTION') {\n                    outOrigSourceMap = config.modules[0]._buildSourceMap;\n                    config._buildSourceMap = outOrigSourceMap;\n                    config.modules[0]._buildText = optimize.js((config.modules[0].name ||\n                                                                config.modules[0].include[0] ||\n                                                                fileName) + '.build.js',\n                                                               config.modules[0]._buildText,\n                                                               null,\n                                                               config);\n                    if (config._buildSourceMap && config._buildSourceMap !== outOrigSourceMap) {\n                        config.modules[0]._buildSourceMap = config._buildSourceMap;\n                        config._buildSourceMap = null;\n                    }\n                } else {\n                    optimize.jsFile(fileName, null, fileName, config);\n                }\n            } else if (!config.cssIn) {\n                //Normal optimizations across modules.\n\n                //JS optimizations.\n                fileNames = fs.getFilteredFileList(config.dir, /\\.js$/, true);\n                fileNames.forEach(function (fileName) {\n                    var cfg, override, moduleIndex;\n\n                    //Generate the module name from the config.dir root.\n                    moduleName = fileName.replace(config.dir, '');\n                    //Get rid of the extension\n                    moduleName = moduleName.substring(0, moduleName.length - 3);\n\n                    //If there is an override for a specific layer build module,\n                    //and this file is that module, mix in the override for use\n                    //by optimize.jsFile.\n                    moduleIndex = getOwn(config._buildPathToModuleIndex, fileName);\n                    //Normalize, since getOwn could have returned undefined\n                    moduleIndex = moduleIndex === 0 || moduleIndex > 0 ? moduleIndex : -1;\n\n                    //Try to avoid extra work if the other files do not need to\n                    //be read. Build layers should be processed at the very\n                    //least for optimization.\n                    if (moduleIndex > -1 || !config.skipDirOptimize ||\n                            config.normalizeDirDefines === \"all\" ||\n                            config.cjsTranslate) {\n                        //Convert the file to transport format, but without a name\n                        //inserted (by passing null for moduleName) since the files are\n                        //standalone, one module per file.\n                        fileContents = fs.readFile(fileName);\n\n\n                        //For builds, if wanting cjs translation, do it now, so that\n                        //the individual modules can be loaded cross domain via\n                        //plain script tags.\n                        if (config.cjsTranslate &&\n                            (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                            fileContents = commonJs.convert(fileName, fileContents);\n                        }\n\n                        if (moduleIndex === -1) {\n                            if (config.onBuildRead) {\n                                fileContents = config.onBuildRead(moduleName,\n                                                                  fileName,\n                                                                  fileContents);\n                            }\n\n                            //Only do transport normalization if this is not a build\n                            //layer (since it was already normalized) and if\n                            //normalizeDirDefines indicated all should be done.\n                            if (config.normalizeDirDefines === \"all\") {\n                                fileContents = build.toTransport(config.namespace,\n                                                             null,\n                                                             fileName,\n                                                             fileContents);\n                            }\n\n                            if (config.onBuildWrite) {\n                                fileContents = config.onBuildWrite(moduleName,\n                                                                   fileName,\n                                                                   fileContents);\n                            }\n                        }\n\n                        override = moduleIndex > -1 ?\n                                   config.modules[moduleIndex].override : null;\n                        if (override) {\n                            cfg = build.createOverrideConfig(config, override);\n                        } else {\n                            cfg = config;\n                        }\n\n                        if (moduleIndex > -1 || !config.skipDirOptimize) {\n                            optimize.jsFile(fileName, fileContents, fileName, cfg, pluginCollector);\n                        }\n                    }\n                });\n\n                //Normalize all the plugin resources.\n                context = require.s.contexts._;\n\n                for (moduleName in pluginCollector) {\n                    if (hasProp(pluginCollector, moduleName)) {\n                        parentModuleMap = context.makeModuleMap(moduleName);\n                        resources = pluginCollector[moduleName];\n                        for (i = 0; i < resources.length; i++) {\n                            resource = resources[i];\n                            moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            if (falseProp(context.plugins, moduleMap.prefix)) {\n                                //Set the value in context.plugins so it\n                                //will be evaluated as a full plugin.\n                                context.plugins[moduleMap.prefix] = true;\n\n                                //Do not bother if the plugin is not available.\n                                if (!fs.exists(require.toUrl(moduleMap.prefix + '.js'))) {\n                                    continue;\n                                }\n\n                                //Rely on the require in the build environment\n                                //to be synchronous\n                                context.require([moduleMap.prefix]);\n\n                                //Now that the plugin is loaded, redo the moduleMap\n                                //since the plugin will need to normalize part of the path.\n                                moduleMap = context.makeModuleMap(resource, parentModuleMap);\n                            }\n\n                            //Only bother with plugin resources that can be handled\n                            //processed by the plugin, via support of the writeFile\n                            //method.\n                            if (falseProp(pluginProcessed, moduleMap.id)) {\n                                //Only do the work if the plugin was really loaded.\n                                //Using an internal access because the file may\n                                //not really be loaded.\n                                plugin = getOwn(context.defined, moduleMap.prefix);\n                                if (plugin && plugin.writeFile) {\n                                    plugin.writeFile(\n                                        moduleMap.prefix,\n                                        moduleMap.name,\n                                        require,\n                                        makeWriteFile(\n                                            config.namespace\n                                        ),\n                                        context.config\n                                    );\n                                }\n\n                                pluginProcessed[moduleMap.id] = true;\n                            }\n                        }\n\n                    }\n                }\n\n                //console.log('PLUGIN COLLECTOR: ' + JSON.stringify(pluginCollector, null, \"  \"));\n\n\n                //All module layers are done, write out the build.txt file.\n                if (config.writeBuildTxt) {\n                    fs.saveUtf8File(config.dir + \"build.txt\", buildFileContents);\n                }\n            }\n\n            //If just have one CSS file to optimize, do that here.\n            if (config.cssIn) {\n                buildFileContents += optimize.cssFile(config.cssIn, config.out, config).buildText;\n            }\n\n            if (typeof config.out === 'function') {\n                config.out(config.modules[0]._buildText, config.modules[0]._buildSourceMap);\n            }\n\n            //Print out what was built into which layers.\n            if (buildFileContents) {\n                logger.info(buildFileContents);\n                return buildFileContents;\n            }\n\n            return '';\n        });\n    };\n\n    /**\n     * Converts command line args like \"paths.foo=../some/path\"\n     * result.paths = { foo: '../some/path' } where prop = paths,\n     * name = paths.foo and value = ../some/path, so it assumes the\n     * name=value splitting has already happened.\n     */\n    function stringDotToObj(result, name, value) {\n        var parts = name.split('.');\n\n        parts.forEach(function (prop, i) {\n            if (i === parts.length - 1) {\n                result[prop] = value;\n            } else {\n                if (falseProp(result, prop)) {\n                    result[prop] = {};\n                }\n                result = result[prop];\n            }\n\n        });\n    }\n\n    build.objProps = {\n        paths: true,\n        wrap: true,\n        pragmas: true,\n        pragmasOnSave: true,\n        has: true,\n        hasOnSave: true,\n        uglify: true,\n        uglify2: true,\n        closure: true,\n        map: true,\n        throwWhen: true,\n        rawText: true\n    };\n\n    build.hasDotPropMatch = function (prop) {\n        var dotProp,\n            index = prop.indexOf('.');\n\n        if (index !== -1) {\n            dotProp = prop.substring(0, index);\n            return hasProp(build.objProps, dotProp);\n        }\n        return false;\n    };\n\n    /**\n     * Converts an array that has String members of \"name=value\"\n     * into an object, where the properties on the object are the names in the array.\n     * Also converts the strings \"true\" and \"false\" to booleans for the values.\n     * member name/value pairs, and converts some comma-separated lists into\n     * arrays.\n     * @param {Array} ary\n     */\n    build.convertArrayToObject = function (ary) {\n        var result = {}, i, separatorIndex, prop, value,\n            needArray = {\n                \"include\": true,\n                \"exclude\": true,\n                \"excludeShallow\": true,\n                \"insertRequire\": true,\n                \"stubModules\": true,\n                \"deps\": true,\n                \"mainConfigFile\": true,\n                \"wrap.startFile\": true,\n                \"wrap.endFile\": true\n            };\n\n        for (i = 0; i < ary.length; i++) {\n            separatorI.ndex = ary[i].indexOf(\"=\");\n            if (separatorIndex === -1) {\n                throw \"Malformed name/value pair: [\" + ary[i] + \"]. Format should be name=value\";\n            }\n\n            value = ary[i].substring(separatorIndex + 1, ary[i].length);\n            if (value === \"true\") {\n                value = true;\n            } else if (value === \"false\") {\n                value = false;\n            }\n\n            prop = ary[i].substring(0, separatorIndex);\n\n            //Convert to array if necessary\n            if (getOwn(needArray, prop)) {\n                value = value.split(\",\");\n            }\n\n            if (build.hasDotPropMatch(prop)) {\n                stringDotToObj(result, prop, value);\n            } else {\n                result[prop] = value;\n            }\n        }\n        return result; //Object\n    };\n\n    build.makeAbsPath = function (path, absFilePath,fs) {\n        if (!absFilePath) {\n            return path;\n        }\n\n        //Add abspath if necessary. If path starts with a slash or has a colon,\n        //then already is an abolute path.\n        if (path.indexOf('/') !== 0 && path.indexOf(':') === -1) {\n            path = absFilePath +\n                   (absFilePath.charAt(absFilePath.length - 1) === '/' ? '' : '/') +\n                   path;\n            path = fs.normalize(path);\n        }\n        return path.replace(lang.backSlashRegExp, '/');\n    };\n\n    build.makeAbsObject = function (props, obj, absFilePath,fs) {\n        var i, prop;\n        if (obj) {\n            for (i = 0; i < props.length; i++) {\n                prop = props[i];\n                if (hasProp(obj, prop) && typeof obj[prop] === 'string') {\n                    obj[prop] = build.makeAbsPath(obj[prop], absFilePath,fs);\n                }\n            }\n        }\n    };\n\n    /**\n     * For any path in a possible config, make it absolute relative\n     * to the absFilePath passed in.\n     */\n    build.makeAbsConfig = function (config, absFilePath,fs) {\n        var props, prop, i;\n\n        props = [\"appDir\", \"dir\", \"baseUrl\"];\n        for (i = 0; i < props.length; i++) {\n            prop = props[i];\n\n            if (getOwn(config, prop)) {\n                //Add abspath if necessary, make sure these paths end in\n                //slashes\n                if (prop === \"baseUrl\") {\n                    config.originalBaseUrl = config.baseUrl;\n                    if (config.appDir) {\n                        //If baseUrl with an appDir, the baseUrl is relative to\n                        //the appDir, *not* the absFilePath. appDir and dir are\n                        //made absolute before baseUrl, so this will work.\n                        config.baseUrl = build.makeAbsPath(config.originalBaseUrl, config.appDir,fs);\n                    } else {\n                        //The dir output baseUrl is same as regular baseUrl, both\n                        //relative to the absFilePath.\n                        config.baseUrl = build.makeAbsPath(config[prop], absFilePath,fs);\n                    }\n                } else {\n                    config[prop] = build.makeAbsPath(config[prop], absFilePath,fs);\n                }\n\n                config[prop] = endsWithSlash(config[prop]);\n            }\n        }\n\n        build.makeAbsObject((config.out === \"stdout\" ? [\"cssIn\"] : [\"out\", \"cssIn\"]),\n                            config, absFilePath,fs);\n        build.makeAbsObject([\"startFile\", \"endFile\"], config.wrap, absFilePath,fs);\n        build.makeAbsObject([\"externExportsPath\"], config.closure, absFilePath,fs);\n    };\n\n    /**\n     * Creates a relative path to targetPath from refPath.\n     * Only deals with file paths, not folders. If folders,\n     * make sure paths end in a trailing '/'.\n     */\n    build.makeRelativeFilePath = function (refPath, targetPath,fs) {\n        var i, dotLength, finalParts, length, targetParts, targetName,\n            refParts = refPath.split('/'),\n            hasEndSlash = endsWithSlashRegExp.test(targetPath),\n            dotParts = [];\n\n        targetPath = fs.normalize(targetPath);\n        if (hasEndSlash && !endsWithSlashRegExp.test(targetPath)) {\n            targetPath += '/';\n        }\n        targetParts = targetPath.split('/');\n        //Pull off file name\n        targetName = targetParts.pop();\n\n        //Also pop off the ref file name to make the matches against\n        //targetParts equivalent.\n        refParts.pop();\n\n        length = refParts.length;\n\n        for (i = 0; i < length; i += 1) {\n            if (refParts[i] !== targetParts[i]) {\n                break;\n            }\n        }\n\n        //Now i is the index in which they diverge.\n        finalParts = targetParts.slice(i);\n\n        dotLength = length - i;\n        for (i = 0; i > -1 && i < dotLength; i += 1) {\n            dotParts.push('..');\n        }\n\n        return dotParts.join('/') + (dotParts.length ? '/' : '') +\n               finalParts.join('/') + (finalParts.length ? '/' : '') +\n               targetName;\n    };\n\n    build.nestedMix = {\n        paths: true,\n        has: true,\n        hasOnSave: true,\n        pragmas: true,\n        pragmasOnSave: true\n    };\n\n    /**\n     * Mixes additional source config into target config, and merges some\n     * nested config, like paths, correctly.\n     */\n    function mixConfig(target, source, skipArrays) {\n        var prop, value, isArray, targetValue;\n\n        for (prop in source) {\n            if (hasProp(source, prop)) {\n                //If the value of the property is a plain object, then\n                //allow a one-level-deep mixing of it.\n                value = source[prop];\n                isArray = lang.isArray(value);\n                if (typeof value === 'object' && value &&\n                        !isArray && !lang.isFunction(value) &&\n                        !lang.isRegExp(value)) {\n\n                    // TODO: need to generalize this work, maybe also reuse\n                    // the work done in requirejs configure, perhaps move to\n                    // just a deep copy/merge overall. However, given the\n                    // amount of observable change, wait for a dot release.\n                    // This change is in relation to #645\n                    if (prop === 'map') {\n                        if (!target.map) {\n                            target.map = {};\n                        }\n                        lang.deepMix(target.map, source.map);\n                    } else {\n                        target[prop] = lang.mixin({}, target[prop], value, true);\n                    }\n                } else if (isArray) {\n                    if (!skipArrays) {\n                        // Some config, like packages, are arrays. For those,\n                        // just merge the results.\n                        targetValue = target[prop];\n                        if (lang.isArray(targetValue)) {\n                            target[prop] = targetValue.concat(value);\n                        } else {\n                            target[prop] = value;\n                        }\n                    }\n                } else {\n                    target[prop] = value;\n                }\n            }\n        }\n\n        //Set up log level since it can affect if errors are thrown\n        //or caught and passed to errbacks while doing config setup.\n        if (lang.hasProp(target, 'logLevel')) {\n            logger.logLevel(target.logLevel);\n        }\n    }\n\n    /**\n     * Converts a wrap.startFile or endFile to be start/end as a string.\n     * the startFile/endFile values can be arrays.\n     */\n    function flattenWrapFile(config, keyName, absFilePath) {\n        var wrap = config.wrap,\n            keyFileName = keyName + 'File',\n            keyMapName = '__' + keyName + 'Map',\n            fs = config.env.fs;\n\n        if (typeof wrap[keyName] !== 'string' && wrap[keyFileName]) {\n            wrap[keyName] = '';\n            if (typeof wrap[keyFileName] === 'string') {\n                wrap[keyFileName] = [wrap[keyFileName]];\n            }\n            wrap[keyMapName] = [];\n            wrap[keyFileName].forEach(function (fileName) {\n                var absPath = build.makeAbsPath(fileName, absFilePath,fs),\n                    fileText = endsWithNewLine(fs.readFile(absPath));\n                wrap[keyMapName].push(function (fileContents, cfg, sourceMapGenerator) {\n                    return appendToFileContents(fileContents, fileText, absPath, cfg, null, sourceMapGenerator);\n                });\n                wrap[keyName] += fileText;\n            });\n        } else if (wrap[keyName] === null ||  wrap[keyName] === undefined) {\n            //Allow missing one, just set to empty string.\n            wrap[keyName] = '';\n        } else if (typeof wrap[keyName] === 'string') {\n            wrap[keyName] = endsWithNewLine(wrap[keyName]);\n            wrap[keyMapName] = [\n                function (fileContents, cfg, sourceMapGenerator) {\n                    var absPath = build.makeAbsPath(\"config-wrap-\" + keyName + \"-default.js\", absFilePath,fs);\n                    return appendToFileContents(fileContents, wrap[keyName], absPath, cfg, null, sourceMapGenerator);\n                }\n            ];\n        } else {\n            throw new Error('wrap.' + keyName + ' or wrap.' + keyFileName + ' malformed');\n        }\n    }\n\n    function normalizeWrapConfig(config, absFilePath) {\n        //Get any wrap text.\n        var fs = config.env.fs;\n        try {\n            if (config.wrap) {\n                if (config.wrap === true) {\n                    //Use default values.\n                    config.wrap = {\n                        start: '(function () {\\n',\n                        end: '}());',\n                        __startMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"(function () {\\n\",\n                                                            build.makeAbsPath(\"config-wrap-start-default.js\",\n                                                                              absFilePath,fs), cfg, null,\n                                                            sourceMapGenerator);\n                            }\n                        ],\n                        __endMap: [\n                            function (fileContents, cfg, sourceMapGenerator) {\n                                return appendToFileContents(fileContents, \"}());\",\n                                                            build.makeAbsPath(\"config-wrap-end-default.js\", absFilePath,fs),\n                                                            cfg, null, sourceMapGenerator);\n                            }\n                        ]\n                    };\n                } else {\n                    flattenWrapFile(config, 'start', absFilePath);\n                    flattenWrapFile(config, 'end', absFilePath);\n                }\n            }\n        } catch (wrapError) {\n            throw new Error('Malformed wrap config: ' + wrapError.toString());\n        }\n    }\n\n    /**\n     * Creates a config object for an optimization build.\n     * It will also read the build profile if it is available, to create\n     * the configuration.\n     *\n     * @param {Object} cfg config options that take priority\n     * over defaults and ones in the build file. These options could\n     * be from a command line, for instance.\n     *\n     * @param {Object} the created config object.\n     */\n    build.createConfig = function (cfg) {\n        /*jslint evil: true */\n        var fs = cfg.env.fs;\n\n        var buildFileContents, buildFileConfig, mainConfig,\n            mainConfigFile, mainConfigPath, buildFile, absFilePath,\n            config = {},\n            buildBaseConfig = makeBuildBaseConfig(fs);\n\n\n        //Make sure all paths are relative to current directory.\n\n        absFilePath = fs.absPath('.');\n        build.makeAbsConfig(cfg, absFilePath,fs);\n        build.makeAbsConfig(buildBaseConfig, absFilePath,fs);\n\n        lang.mixin(config, buildBaseConfig);\n        lang.mixin(config, cfg, true);\n\n\n        //Set up log level early since it can affect if errors are thrown\n        //or caught and passed to errbacks, even while constructing config.\n        if (lang.hasProp(config, 'logLevel')) {\n            logger.logLevel(config.logLevel);\n        }\n\n        if (config.buildFile) {\n            //A build file exists, load it to get more config.\n            buildFile = fs.absPath(config.buildFile);\n\n            //Find the build file, and make sure it exists, if this is a build\n            //that has a build profile, and not just command line args with an in=path\n            if (!fs.exists(buildFile)) {\n                throw new Error(\"ERROR: build file does not exist: \" + buildFile);\n            }\n\n            absFilePath = config.baseUrl = fs.absPath(fs.parent(buildFile));\n\n            //Load build file options.\n            buildFileContents = fs.readFile(buildFile);\n            try {\n                //Be a bit lenient in the file ending in a ; or ending with\n                //a //# sourceMappingUrl comment, mostly for compiled languages\n                //that create a config, like typescript.\n                buildFileContents = buildFileContents\n                                    .replace(/\\/\\/\\#[^\\n\\r]+[\\n\\r]*$/, '')\n                                    .trim()\n                                    .replace(/;$/, '');\n\n                buildFileConfig = eval(\"(\" + buildFileContents + \")\");\n                build.makeAbsConfig(buildFileConfig, absFilePath,fs);\n\n                //Mix in the config now so that items in mainConfigFile can\n                //be resolved relative to them if necessary, like if appDir\n                //is set here, but the baseUrl is in mainConfigFile. Will\n                //re-mix in the same build config later after mainConfigFile\n                //is processed, since build config should take priority.\n                mixConfig(config, buildFileConfig);\n            } catch (e) {\n                throw new Error(\"Build file \" + buildFile + \" is malformed: \" + e);\n            }\n        }\n\n        mainConfigFile = config.mainConfigFile || (buildFileConfig && buildFileConfig.mainConfigFile);\n        if (mainConfigFile) {\n            if (typeof mainConfigFile === 'string') {\n                mainConfigFile = [mainConfigFile];\n            }\n\n            mainConfigFile.forEach(function (configFile) {\n                configFile = build.makeAbsPath(configFile, absFilePath,fs);\n                if (!fs.exists(configFile)) {\n                    throw new Error(configFile + ' does not exist.');\n                }\n                try {\n                    mainConfig = parse.findConfig(fs.readFile(configFile)).config;\n                } catch (configError) {\n                    throw new Error('The config in mainConfigFile ' +\n                            configFile +\n                            ' cannot be used because it cannot be evaluated' +\n                            ' correctly while running in the optimizer. Try only' +\n                            ' using a config that is also valid JSON, or do not use' +\n                            ' mainConfigFile and instead copy the config values needed' +\n                            ' into a build file or command line arguments given to the optimizer.\\n' +\n                            'Source error from parsing: ' + configFile + ': ' + configError);\n                }\n                if (mainConfig) {\n                    mainConfigPath = configFile.substring(0, configFile.lastIndexOf('/'));\n\n                    //Add in some existing config, like appDir, since they can be\n                    //used inside the configFile -- paths and baseUrl are\n                    //relative to them.\n                    if (config.appDir && !mainConfig.appDir) {\n                        mainConfig.appDir = config.appDir;\n                    }\n\n                    //If no baseUrl, then use the directory holding the main config.\n                    if (!mainConfig.baseUrl) {\n                        mainConfig.baseUrl = mainConfigPath;\n                    }\n\n                    build.makeAbsConfig(mainConfig, mainConfigPath,fs);\n                    mixConfig(config, mainConfig);\n                }\n            });\n        }\n\n        //Mix in build file config, but only after mainConfig has been mixed in.\n        //Since this is a re-application, skip array merging.\n        if (buildFileConfig) {\n            mixConfig(config, buildFileConfig, true);\n        }\n\n        //Re-apply the override config values. Command line\n        //args should take precedence over build file values.\n        //Since this is a re-application, skip array merging.\n        mixConfig(config, cfg, true);\n\n        //Fix paths to full paths so that they can be adjusted consistently\n        //lately to be in the output area.\n        lang.eachProp(config.paths, function (value, prop) {\n            if (lang.isArray(value)) {\n                throw new Error('paths fallback not supported in optimizer. ' +\n                                'Please provide a build config path override ' +\n                                'for ' + prop);\n            }\n            config.paths[prop] = build.makeAbsPath(value, config.baseUrl,fs);\n        });\n\n        //Set final output dir\n        if (hasProp(config, \"baseUrl\")) {\n            if (config.appDir) {\n                if (!config.originalBaseUrl) {\n                    throw new Error('Please set a baseUrl in the build config');\n                }\n                config.dirBaseUrl = build.makeAbsPath(config.originalBaseUrl, config.dir,fs);\n            } else {\n                config.dirBaseUrl = config.dir || config.baseUrl;\n            }\n            //Make sure dirBaseUrl ends in a slash, since it is\n            //concatenated with other strings.\n            config.dirBaseUrl = endsWithSlash(config.dirBaseUrl);\n        }\n\n        if (config.bundlesConfigOutFile) {\n            if (!config.dir) {\n                throw new Error('bundlesConfigOutFile can only be used with optimizations ' +\n                                'that use \"dir\".');\n            }\n            config.bundlesConfigOutFile = build.makeAbsPath(config.bundlesConfigOutFile, config.dir,fs);\n        }\n\n        //If out=stdout, write output to STDOUT instead of a file.\n        ///if (config.out && config.out === 'stdout') {\n        ///    config.out = function (content) {\n        ///        var e = env.get();\n        ///        if (e === 'rhino') {\n        ///            var out = new java.io.PrintStream(java.lang.System.out, true, 'UTF-8');\n        ///            out.println(content);\n        ///        } else if (e === 'node') {\n        ///            process.stdout.write(content, 'utf8');\n        ///        } else {\n        ///            console.log(content);\n        ///        }\n        ///    };\n        ///}\n\n        //Check for errors in config\n        if (config.main) {\n            throw new Error('\"main\" passed as an option, but the ' +\n                            'supported option is called \"name\".');\n        }\n        if (config.out && !config.name && !config.modules && !config.include &&\n                !config.cssIn) {\n            throw new Error('Missing either a \"name\", \"include\" or \"modules\" ' +\n                            'option');\n        }\n        if (config.cssIn) {\n            if (config.dir || config.appDir) {\n                throw new Error('cssIn is only for the output of single file ' +\n                    'CSS optimizations and is not compatible with \"dir\" or \"appDir\" configuration.');\n            }\n            if (!config.out) {\n                throw new Error('\"out\" option missing.');\n            }\n        }\n        if (!config.cssIn && !config.baseUrl) {\n            //Just use the current directory as the baseUrl\n            config.baseUrl = './';\n        }\n        if (!config.out && !config.dir) {\n            throw new Error('Missing either an \"out\" or \"dir\" config value. ' +\n                            'If using \"appDir\" for a full project optimization, ' +\n                            'use \"dir\". If you want to optimize to one file, ' +\n                            'use \"out\".');\n        }\n        if (config.appDir && config.out) {\n            throw new Error('\"appDir\" is not compatible with \"out\". Use \"dir\" ' +\n                            'instead. appDir is used to copy whole projects, ' +\n                            'where \"out\" with \"baseUrl\" is used to just ' +\n                            'optimize to one file.');\n        }\n        if (config.out && config.dir) {\n            throw new Error('The \"out\" and \"dir\" options are incompatible.' +\n                            ' Use \"out\" if you are targeting a single file' +\n                            ' for optimization, and \"dir\" if you want the appDir' +\n                            ' or baseUrl directories optimized.');\n        }\n\n\n        if (config.dir) {\n            // Make sure the output dir is not set to a parent of the\n            // source dir or the same dir, as it will result in source\n            // code deletion.\n            if (!config.allowSourceOverwrites && (config.dir === config.baseUrl ||\n                config.dir === config.appDir ||\n                (config.baseUrl && build.makeRelativeFilePath(config.dir,\n                                           config.baseUrl,fs).indexOf('..') !== 0) ||\n                (config.appDir &&\n                    build.makeRelativeFilePath(config.dir, config.appDir,fs).indexOf('..') !== 0))) {\n                throw new Error('\"dir\" is set to a parent or same directory as' +\n                                ' \"appDir\" or \"baseUrl\". This can result in' +\n                                ' the deletion of source code. Stopping. If' +\n                                ' you want to allow possible overwriting of' +\n                                ' source code, set \"allowSourceOverwrites\"' +\n                                ' to true in the build config, but do so at' +\n                                ' your own risk. In that case, you may want' +\n                                ' to also set \"keepBuildDir\" to true.');\n            }\n        }\n\n        if (config.insertRequire && !lang.isArray(config.insertRequire)) {\n            throw new Error('insertRequire should be a list of module IDs' +\n                            ' to insert in to a require([]) call.');\n        }\n\n        //Support older configs with uglify2 settings, but now that uglify1 has\n        //been removed, just translate it to 'uglify' settings.\n        if (config.optimize === 'uglify2') {\n            config.optimize = 'uglify';\n        }\n        if (config.uglify2) {\n            config.uglify = config.uglify2;\n            delete config.uglify2;\n        }\n\n        if (config.generateSourceMaps) {\n            if (config.preserveLicenseComments && !(config.optimize === 'none' || config.optimize === 'uglify')) {\n                throw new Error('Cannot use preserveLicenseComments and ' +\n                    'generateSourceMaps together, unless optimize is set ' +\n                    'to \\'uglify\\'. Either explicitly set preserveLicenseComments ' +\n                    'to false (default is true) or turn off generateSourceMaps. ' +\n                    'If you want source maps with license comments, see: ' +\n                    'http://requirejs.org/docs/errors.html#sourcemapcomments');\n            } else if (config.optimize !== 'none' &&\n                       config.optimize !== 'closure' &&\n                       config.optimize !== 'uglify') {\n                //Allow optimize: none to pass, since it is useful when toggling\n                //minification on and off to debug something, and it implicitly\n                //works, since it does not need a source map.\n                throw new Error('optimize: \"' + config.optimize +\n                    '\" does not support generateSourceMaps.');\n            }\n        }\n\n        if ((config.name || config.include) && !config.modules) {\n            //Just need to build one file, but may be part of a whole appDir/\n            //baseUrl copy, but specified on the command line, so cannot do\n            //the modules array setup. So create a modules section in that\n            //case.\n            config.modules = [\n                {\n                    name: config.name,\n                    out: config.out,\n                    create: config.create,\n                    include: config.include,\n                    exclude: config.exclude,\n                    excludeShallow: config.excludeShallow,\n                    insertRequire: config.insertRequire,\n                    stubModules: config.stubModules\n                }\n            ];\n            delete config.stubModules;\n        } else if (config.modules && config.out) {\n            throw new Error('If the \"modules\" option is used, then there ' +\n                            'should be a \"dir\" option set and \"out\" should ' +\n                            'not be used since \"out\" is only for single file ' +\n                            'optimization output.');\n        } else if (config.modules && config.name) {\n            throw new Error('\"name\" and \"modules\" options are incompatible. ' +\n                            'Either use \"name\" if doing a single file ' +\n                            'optimization, or \"modules\" if you want to target ' +\n                            'more than one file for optimization.');\n        }\n\n        if (config.out && !config.cssIn) {\n            //Just one file to optimize.\n\n            //Does not have a build file, so set up some defaults.\n            //Optimizing CSS should not be allowed, unless explicitly\n            //asked for on command line. In that case the only task is\n            //to optimize a CSS file.\n            if (!cfg.optimizeCss) {\n                config.optimizeCss = \"none\";\n            }\n        }\n\n        //Normalize cssPrefix\n        if (config.cssPrefix) {\n            //Make sure cssPrefix ends in a slash\n            config.cssPrefix = endsWithSlash(config.cssPrefix);\n        } else {\n            config.cssPrefix = '';\n        }\n\n        //Cycle through modules and normalize\n        if (config.modules && config.modules.length) {\n            config.modules.forEach(function (mod) {\n                if (lang.isArray(mod) || typeof mod === 'string' || !mod) {\n                    throw new Error('modules config item is malformed: it should' +\n                                    ' be an object with a \\'name\\' property.');\n                }\n\n                //Combine any local stubModules with global values.\n                if (config.stubModules) {\n                    mod.stubModules = config.stubModules.concat(mod.stubModules || []);\n                }\n\n                //Create a hash lookup for the stubModules config to make lookup\n                //cheaper later.\n                if (mod.stubModules) {\n                    mod.stubModules._byName = {};\n                    mod.stubModules.forEach(function (id) {\n                        mod.stubModules._byName[id] = true;\n                    });\n                }\n\n                // Legacy command support, which allowed a single string ID\n                // for include.\n                if (typeof mod.include === 'string') {\n                    mod.include = [mod.include];\n                }\n\n                //Allow wrap config in overrides, but normalize it.\n                if (mod.override) {\n                    normalizeWrapConfig(mod.override, absFilePath);\n                }\n            });\n        }\n\n        normalizeWrapConfig(config, absFilePath);\n\n        //Do final input verification\n        if (config.context) {\n            throw new Error('The build argument \"context\" is not supported' +\n                            ' in a build. It should only be used in web' +\n                            ' pages.');\n        }\n\n        //Set up normalizeDirDefines. If not explicitly set, if optimize \"none\",\n        //set to \"skip\" otherwise set to \"all\".\n        if (!hasProp(config, 'normalizeDirDefines')) {\n            if (config.optimize === 'none' || config.skipDirOptimize) {\n                config.normalizeDirDefines = 'skip';\n            } else {\n                config.normalizeDirDefines = 'all';\n            }\n        }\n\n        //Set fs.fileExclusionRegExp if desired\n        if (hasProp(config, 'fileExclusionRegExp')) {\n            if (typeof config.fileExclusionRegExp === \"string\") {\n                fs.exclusionRegExp = new RegExp(config.fileExclusionRegExp);\n            } else {\n                fs.exclusionRegExp = config.fileExclusionRegExp;\n            }\n        } else if (hasProp(config, 'dirExclusionRegExp')) {\n            //Set fs.dirExclusionRegExp if desired, this is the old\n            //name for fileExclusionRegExp before 1.0.2. Support for backwards\n            //compatibility\n            fs.exclusionRegExp = config.dirExclusionRegExp;\n        }\n\n        //Track the deps, but in a different key, so that they are not loaded\n        //as part of config seeding before all config is in play (#648). Was\n        //going to merge this in with \"include\", but include is added after\n        //the \"name\" target. To preserve what r.js has done previously, make\n        //sure \"deps\" comes before the \"name\".\n        if (config.deps) {\n            config._depsInclude = config.deps;\n        }\n\n\n        //Remove things that may cause problems in the build.\n        //deps already merged above\n        delete config.deps;\n        delete config.jQuery;\n        delete config.enforceDefine;\n        delete config.urlArgs;\n\n        return config;\n    };\n\n    /**\n     * finds the module being built/optimized with the given moduleName,\n     * or returns null.\n     * @param {String} moduleName\n     * @param {Array} modules\n     * @returns {Object} the module object from the build profile, or null.\n     */\n    build.findBuildModule = function (moduleName, modules) {\n        var i, module;\n        for (i = 0; i < modules.length; i++) {\n            module = modules[i];\n            if (module.name === moduleName) {\n                return module;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Removes a module name and path from a layer, if it is supposed to be\n     * excluded from the layer.\n     * @param {String} moduleName the name of the module\n     * @param {String} path the file path for the module\n     * @param {Object} layer the layer to remove the module/path from\n     */\n    build.removeModulePath = function (module, path, layer) {\n        var index = layer.buildFilePaths.indexOf(path);\n        if (index !== -1) {\n            layer.buildFilePaths.splice(index, 1);\n        }\n    };\n\n    /**\n     * Uses the module build config object to trace the dependencies for the\n     * given module.\n     *\n     * @param {Object} module the module object from the build config info.\n     * @param {Object} config the build config object.\n     * @param {Object} [baseLoaderConfig] the base loader config to use for env resets.\n     *\n     * @returns {Object} layer information about what paths and modules should\n     * be in the flattened module.\n     */\n    build.traceDependencies = function (module, config, baseLoaderConfig) {\n        var include, override, layer, context, oldContext,\n            rawTextByIds,\n            syncChecks = {\n                rhino: true,\n                node: true,\n                xpconnect: true\n            },\n            deferred = prim();\n\n        //Reset some state set up in requirePatch.js, and clean up require's\n        //current context.\n        oldContext = require._buildReset();\n\n        //Grab the reset layer and context after the reset, but keep the\n        //old config to reuse in the new context.\n        layer = require._layer;\n        context = layer.context;\n\n        //Put back basic config, use a fresh object for it.\n        if (baseLoaderConfig) {\n            require(copyConfig(baseLoaderConfig));\n        }\n\n        logger.trace(\"\\nTracing dependencies for: \" + (module.name ||\n                     (typeof module.out === 'function' ? 'FUNCTION' : module.out)));\n        include = config._depsInclude ||  [];\n        include = include.concat(module.name && !module.create ? [module.name] : []);\n        if (module.include) {\n            include = include.concat(module.include);\n        }\n\n        //If there are overrides to basic config, set that up now.;\n        if (module.override) {\n            if (baseLoaderConfig) {\n                override = build.createOverrideConfig(baseLoaderConfig, module.override);\n            } else {\n                override = copyConfig(module.override);\n            }\n            require(override);\n        }\n\n        //Now, populate the rawText cache with any values explicitly passed in\n        //via config.\n        rawTextByIds = require.s.contexts._.config.rawText;\n        if (rawTextByIds) {\n            lang.eachProp(rawTextByIds, function (contents, id) {\n                var url = require.toUrl(id) + '.js';\n                require._cachedRawText[url] = contents;\n            });\n        }\n\n\n        //Configure the callbacks to be called.\n        deferred.reject.__requireJsBuild = true;\n\n        //Use a wrapping function so can check for errors.\n        function includeFinished(value) {\n            //If a sync build environment, check for errors here, instead of\n            //in the then callback below, since some errors, like two IDs pointed\n            //to same URL but only one anon ID will leave the loader in an\n            //unresolved state since a setTimeout cannot be used to check for\n            //timeout.\n            var hasError = false;\n            if (syncChecks[config.env.name]) {\n                try {\n                    build.checkForErrors(context, layer);\n                } catch (e) {\n                    hasError = true;\n                    deferred.reject(e);\n                }\n            }\n\n            if (!hasError) {\n                deferred.resolve(value);\n            }\n        }\n        includeFinished.__requireJsBuild = true;\n\n        //Figure out module layer dependencies by calling require to do the work.\n        require(include, includeFinished, deferred.reject);\n\n        // If a sync env, then with the \"two IDs to same anon module path\"\n        // issue, the require never completes, need to check for errors\n        // here.\n        if (syncChecks[config.env.name]) {\n            build.checkForErrors(context, layer);\n        }\n\n        return deferred.promise.then(function () {\n            //Reset config\n            if (module.override && baseLoaderConfig) {\n                require(copyConfig(baseLoaderConfig));\n            }\n\n            build.checkForErrors(context, layer);\n\n            return layer;\n        });\n    };\n\n    build.checkForErrors = function (context, layer) {\n        //Check to see if it all loaded. If not, then throw, and give\n        //a message on what is left.\n        var id, prop, mod, idParts, pluginId, pluginResources,\n            errMessage = '',\n            failedPluginMap = {},\n            failedPluginIds = [],\n            errIds = [],\n            errUrlMap = {},\n            errUrlConflicts = {},\n            hasErrUrl = false,\n            hasUndefined = false,\n            defined = context.defined,\n            registry = context.registry;\n\n        function populateErrUrlMap(id, errUrl, skipNew) {\n            // Loader plugins do not have an errUrl, so skip them.\n            if (!errUrl) {\n                return;\n            }\n\n            if (!skipNew) {\n                errIds.push(id);\n            }\n\n            if (errUrlMap[errUrl]) {\n                hasErrUrl = true;\n                //This error module has the same URL as another\n                //error module, could be misconfiguration.\n                if (!errUrlConflicts[errUrl]) {\n                    errUrlConflicts[errUrl] = [];\n                    //Store the original module that had the same URL.\n                    errUrlConflicts[errUrl].push(errUrlMap[errUrl]);\n                }\n                errUrlConflicts[errUrl].push(id);\n            } else if (!skipNew) {\n                errUrlMap[errUrl] = id;\n            }\n        }\n\n        for (id in registry) {\n            if (hasProp(registry, id) && id.indexOf('_@r') !== 0) {\n                hasUndefined = true;\n                mod = getOwn(registry, id);\n                idParts = id.split('!');\n                pluginId = idParts[0];\n\n                if (id.indexOf('_unnormalized') === -1 && mod && mod.enabled) {\n                    populateErrUrlMap(id, mod.map.url);\n                }\n\n                //Look for plugins that did not call load()\n                //But skip plugin IDs that were already inlined and called\n                //define() with a name.\n                if (!hasProp(layer.modulesWithNames, id) && idParts.length > 1) {\n                    if (falseProp(failedPluginMap, pluginId)) {\n                        failedPluginIds.push(pluginId);\n                    }\n                    pluginResources = failedPluginMap[pluginId];\n                    if (!pluginResources) {\n                        pluginResources = failedPluginMap[pluginId] = [];\n                    }\n                    pluginResources.push(id + (mod.error ? ': ' + mod.error : ''));\n                }\n            }\n        }\n\n        // If have some modules that are not defined/stuck in the registry,\n        // then check defined modules for URL overlap.\n        if (hasUndefined) {\n            for (id in defined) {\n                if (hasProp(defined, id) && id.indexOf('!') === -1) {\n                    populateErrUrlMap(id, require.toUrl(id) + '.js', true);\n                }\n            }\n        }\n\n        if (errIds.length || failedPluginIds.length) {\n            if (failedPluginIds.length) {\n                errMessage += 'Loader plugin' +\n                    (failedPluginIds.length === 1 ? '' : 's') +\n                    ' did not call ' +\n                    'the load callback in the build:\\n' +\n                    failedPluginIds.map(function (pluginId) {\n                        var pluginResources = failedPluginMap[pluginId];\n                        return pluginId + ':\\n  ' + pluginResources.join('\\n  ');\n                    }).join('\\n') + '\\n';\n            }\n            errMessage += 'Module loading did not complete for: ' + errIds.join(', ');\n\n            if (hasErrUrl) {\n                errMessage += '\\nThe following modules share the same URL. This ' +\n                              'could be a misconfiguration if that URL only has ' +\n                              'one anonymous module in it:';\n                for (prop in errUrlConflicts) {\n                    if (hasProp(errUrlConflicts, prop)) {\n                        errMessage += '\\n' + prop + ': ' +\n                                      errUrlConflicts[prop].join(', ');\n                    }\n                }\n            }\n            throw new Error(errMessage);\n        }\n    };\n\n    build.createOverrideConfig = function (config, override) {\n        var cfg = copyConfig(config),\n            oride = copyConfig(override);\n\n        lang.eachProp(oride, function (value, prop) {\n            if (hasProp(build.objProps, prop)) {\n                //An object property, merge keys. Start a new object\n                //so that source object in config does not get modified.\n                cfg[prop] = {};\n                lang.mixin(cfg[prop], config[prop], true);\n                lang.mixin(cfg[prop], override[prop], true);\n            } else {\n                cfg[prop] = override[prop];\n            }\n        });\n\n        return cfg;\n    };\n\n    /**\n     * Uses the module build config object to create an flattened version\n     * of the module, with deep dependencies included.\n     *\n     * @param {Object} module the module object from the build config info.\n     *\n     * @param {Object} layer the layer object returned from build.traceDependencies.\n     *\n     * @param {Object} the build config object.\n     *\n     * @returns {Object} with two properties: \"text\", the text of the flattened\n     * module, and \"buildText\", a string of text representing which files were\n     * included in the flattened module text.\n     */\n    build.flattenModule = function (module, layer, config) {\n        var fileContents, sourceMapGenerator,\n            sourceMapBase,\n            buildFileContents = '',\n            fs = config.env.fs;\n\n        return prim().start(function () {\n            var reqIndex, currContents, fileForSourceMap,\n                moduleName, shim, packageName,\n                parts, builder, writeApi,\n                namespace, namespaceWithDot, stubModulesByName,\n                context = layer.context,\n                onLayerEnds = [],\n                onLayerEndAdded = {},\n                pkgsMainMap = {};\n\n            //Use override settings, particularly for pragmas\n            //Do this before the var readings since it reads config values.\n            if (module.override) {\n                config = build.createOverrideConfig(config, module.override);\n            }\n\n            namespace = config.namespace || '';\n            namespaceWithDot = namespace ? namespace + '.' : '';\n            stubModulesByName = (module.stubModules && module.stubModules._byName) || {};\n\n            //Start build output for the module.\n            module.onCompleteData = {\n                name: module.name,\n                path: (config.dir ? module._buildPath.replace(config.dir, \"\") : module._buildPath),\n                included: []\n            };\n\n            buildFileContents += \"\\n\" +\n                                  module.onCompleteData.path +\n                                 \"\\n----------------\\n\";\n\n            //If there was an existing file with require in it, hoist to the top.\n            if (layer.existingRequireUrl) {\n                reqIndex = layer.buildFilePaths.indexOf(layer.existingRequireUrl);\n                if (reqIndex !== -1) {\n                    layer.buildFilePaths.splice(reqIndex, 1);\n                    layer.buildFilePaths.unshift(layer.existingRequireUrl);\n                }\n            }\n\n            if (config.generateSourceMaps) {\n                sourceMapBase = config.dir || config.baseUrl;\n                if (module._buildPath === 'FUNCTION') {\n                    fileForSourceMap = (module.name || module.include[0] || 'FUNCTION') + '.build.js';\n                } else if (config.out) {\n                    fileForSourceMap = module._buildPath.split('/').pop();\n                } else {\n                    fileForSourceMap = module._buildPath.replace(sourceMapBase, '');\n                }\n                sourceMapGenerator = new SourceMapGenerator({\n                    file: fileForSourceMap\n                });\n            }\n\n            //Create a reverse lookup for packages main module IDs to their package\n            //names, useful for knowing when to write out define() package main ID\n            //adapters.\n            lang.eachProp(layer.context.config.pkgs, function(value, prop) {\n                pkgsMainMap[value] = prop;\n            });\n\n            //Write the built module to disk, and build up the build output.\n            fileContents = \"\";\n            if (config.wrap && config.wrap.__startMap) {\n                config.wrap.__startMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n\n            return prim.serial(layer.buildFilePaths.map(function (path) {\n                return function () {\n                    var singleContents = '';\n\n                    moduleName = layer.buildFileToModule[path];\n\n                    //If the moduleName is a package main, then hold on to the\n                    //packageName in case an adapter needs to be written.\n                    packageName = getOwn(pkgsMainMap, moduleName);\n\n                    return prim().start(function () {\n                        //Figure out if the module is a result of a build plugin, and if so,\n                        //then delegate to that plugin.\n                        parts = context.makeModuleMap(moduleName);\n                        builder = parts.prefix && getOwn(context.defined, parts.prefix);\n                        if (builder) {\n                            if (builder.onLayerEnd && falseProp(onLayerEndAdded, parts.prefix)) {\n                                onLayerEnds.push(builder);\n                                onLayerEndAdded[parts.prefix] = true;\n                            }\n\n                            if (builder.write) {\n                                writeApi = function (input) {\n                                    singleContents += \"\\n\" + addSemiColon(input, config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n                                writeApi.asModule = function (moduleName, input) {\n                                    singleContents += \"\\n\" +\n                                        addSemiColon(build.toTransport(namespace, moduleName, path, input, layer, {\n                                            useSourceUrl: layer.context.config.useSourceUrl\n                                        }), config);\n                                    if (config.onBuildWrite) {\n                                        singleContents = config.onBuildWrite(moduleName, path, singleContents);\n                                    }\n                                };\n\n                                builder.write(parts.prefix, parts.name, writeApi, {\n                                    name: module.onCompleteData.name,\n                                    path: module.onCompleteData.path\n                                });\n                            }\n                            return;\n                        } else {\n                            return prim().start(function () {\n                                if (hasProp(stubModulesByName, moduleName)) {\n                                    //Just want to insert a simple module definition instead\n                                    //of the source module. Useful for plugins that inline\n                                    //all their resources.\n                                    if (hasProp(layer.context.plugins, moduleName)) {\n                                        //Slightly different content for plugins, to indicate\n                                        //that dynamic loading will not work.\n                                        return 'define({load: function(id){throw new Error(\"Dynamic load not allowed: \" + id);}});';\n                                    } else {\n                                        return 'define({});';\n                                    }\n                                } else {\n                                    return require._cacheReadAsync(path,undefined,fs);\n                                }\n                            }).then(function (text) {\n                                var hasPackageName;\n\n                                currContents = text;\n\n                                if (config.cjsTranslate &&\n                                    (!config.shim || !lang.hasProp(config.shim, moduleName))) {\n                                    currContents = commonJs.convert(path, currContents);\n                                }\n\n                                if (config.onBuildRead) {\n                                    currContents = config.onBuildRead(moduleName, path, currContents);\n                                }\n\n                                if (packageName) {\n                                    hasPackageName = (packageName === parse.getNamedDefine(currContents));\n                                }\n\n                                if (namespace) {\n                                    currContents = pragma.namespace(currContents, namespace);\n                                }\n\n                                currContents = build.toTransport(namespace, moduleName, path, currContents, layer, {\n                                    useSourceUrl: config.useSourceUrl\n                                });\n\n                                if (packageName && !hasPackageName) {\n                                    currContents = addSemiColon(currContents, config) + '\\n';\n                                    currContents += namespaceWithDot + \"define('\" +\n                                                    packageName + \"', ['\" + moduleName +\n                                                    \"'], function (main) { return main; });\\n\";\n                                }\n\n                                if (config.onBuildWrite) {\n                                    currContents = config.onBuildWrite(moduleName, path, currContents);\n                                }\n\n                                //Semicolon is for files that are not well formed when\n                                //concatenated with other content.\n                                singleContents += addSemiColon(currContents, config);\n                            });\n                        }\n                    }).then(function () {\n                        var shimDeps, shortPath = path.replace(config.dir, \"\");\n\n                        module.onCompleteData.included.push(shortPath);\n                        buildFileContents += shortPath + \"\\n\";\n\n                        //Some files may not have declared a require module, and if so,\n                        //put in a placeholder call so the require does not try to load them\n                        //after the module is processed.\n                        //If we have a name, but no defined module, then add in the placeholder.\n                        if (moduleName && falseProp(layer.modulesWithNames, moduleName) && !config.skipModuleInsertion) {\n                            shim = config.shim && (getOwn(config.shim, moduleName) || (packageName && getOwn(config.shim, packageName)));\n                            if (shim) {\n                                shimDeps = lang.isArray(shim) ? shim : shim.deps;\n                                if (config.wrapShim) {\n\n                                    singleContents = '(function(root) {\\n' +\n                                                     namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '[], ') +\n                                                    'function() {\\n' +\n                                                    '  return (function() {\\n' +\n                                                             singleContents +\n                                                             // Start with a \\n in case last line is a comment\n                                                             // in the singleContents, like a sourceURL comment.\n                                                             '\\n' + (shim.exportsFn ? shim.exportsFn() : '') +\n                                                             '\\n' +\n                                                    '  }).apply(root, arguments);\\n' +\n                                                    '});\\n' +\n                                                    '}(this));\\n';\n                                } else {\n                                    singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", ' +\n                                                     (shimDeps && shimDeps.length ?\n                                                            build.makeJsArrayString(shimDeps) + ', ' : '') +\n                                                     (shim.exportsFn ? shim.exportsFn() : 'function(){}') +\n                                                     ');\\n';\n                                }\n                            } else {\n                                singleContents += '\\n' + namespaceWithDot + 'define(\"' + moduleName + '\", function(){});\\n';\n                            }\n                        }\n\n                        //Add line break at end of file, instead of at beginning,\n                        //so source map line numbers stay correct, but still allow\n                        //for some space separation between files in case ASI issues\n                        //for concatenation would cause an error otherwise.\n                        singleContents += '\\n';\n\n                        //Add to the source map and to the final contents\n                        fileContents = appendToFileContents(fileContents, singleContents, path, config, module,\n                                                            sourceMapGenerator);\n                    });\n                };\n            })).then(function () {\n                if (onLayerEnds.length) {\n                    onLayerEnds.forEach(function (builder, index) {\n                        var path;\n                        if (typeof module.out === 'string') {\n                            path = module.out;\n                        } else if (typeof module._buildPath === 'string') {\n                            path = module._buildPath;\n                        }\n                        builder.onLayerEnd(function (input) {\n                            fileContents =\n                                appendToFileContents(fileContents, \"\\n\" + addSemiColon(input, config),\n                                                     'onLayerEnd' + index + '.js', config, module, sourceMapGenerator);\n                        }, {\n                            name: module.name,\n                            path: path\n                        });\n                    });\n                }\n\n                if (module.create) {\n                    //The ID is for a created layer. Write out\n                    //a module definition for it in case the\n                    //built file is used with enforceDefine\n                    //(#432)\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'define(\"' + module.name +\n                                                           '\", function(){});\\n', 'module-create.js', config, module,\n                                             sourceMapGenerator);\n                }\n\n                //Add a require at the end to kick start module execution, if that\n                //was desired. Usually this is only specified when using small shim\n                //loaders like almond.\n                if (module.insertRequire) {\n                    fileContents =\n                        appendToFileContents(fileContents, '\\n' + namespaceWithDot + 'require([\"' + module.insertRequire.join('\", \"') +\n                                                           '\"]);\\n', 'module-insertRequire.js', config, module,\n                                             sourceMapGenerator);\n                }\n            });\n        }).then(function () {\n            if (config.wrap && config.wrap.__endMap) {\n                config.wrap.__endMap.forEach(function (wrapFunction) {\n                    fileContents = wrapFunction(fileContents, config, sourceMapGenerator);\n                });\n            }\n            return {\n                text: fileContents,\n                buildText: buildFileContents,\n                sourceMap: sourceMapGenerator ?\n                              JSON.stringify(sourceMapGenerator.toJSON(), null, '  ') :\n                              undefined\n            };\n        });\n    };\n\n    //Converts an JS array of strings to a string representation.\n    //Not using JSON.stringify() for Rhino's sake.\n    build.makeJsArrayString = function (ary) {\n        return '[\"' + ary.map(function (item) {\n            //Escape any double quotes, backslashes\n            return lang.jsEscape(item);\n        }).join('\",\"') + '\"]';\n    };\n\n    build.toTransport = function (namespace, moduleName, path, contents, layer, options) {\n        var baseUrl = layer && layer.context.config.baseUrl;\n\n        function onFound(info) {\n            //Only mark this module as having a name if not a named module,\n            //or if a named module and the name matches expectations.\n            if (layer && (info.needsId || info.foundId === moduleName)) {\n                layer.modulesWithNames[moduleName] = true;\n            }\n        }\n\n        //Convert path to be a local one to the baseUrl, useful for\n        //useSourceUrl.\n        if (baseUrl) {\n            path = path.replace(baseUrl, '');\n        }\n\n        return transform.toTransport(namespace, moduleName, path, contents, onFound, options);\n    };\n\n    return require.build = build;\n});\n\ndefine('skylark-rjs/main',[\r\n    \"./rjs\",\r\n    \"./build\",\r\n    \"./lang\",\r\n    \"./prim\",\r\n    \"./logger\",\r\n    \"./parse\",\r\n    \"./optimize\",\r\n    \"./pragma\",\r\n    \"./transform\",\r\n    \"./requirePatch\",\r\n    \"./commonJs\",\r\n    \"./source-map\"\r\n],function (\r\n    rjs,\r\n    build,\r\n    lang,\r\n    prim,\r\n    logger,\r\n    parse,\r\n    optimize,\r\n    pragma,\r\n    transform,\r\n    requirePatch,\r\n    commonJs,\r\n    sourceMap,\r\n    createRjsApi\r\n\r\n) {\r\n    'use strict';\r\n\r\n    /*return {\r\n    \tbuild,\r\n    \tlang,\r\n    \tprim,\r\n    \tlogger,\r\n    \tparse,\r\n    \toptimize,\r\n    \tpragma,\r\n    \ttransform,\r\n    \trequirePatch,\r\n    \tcommonJs,\r\n    \tsourceMap,\r\n    }\r\n    */\r\n    return rjs;\r\n\t\r\n});\ndefine('skylark-rjs', ['skylark-rjs/main'], function (main) { return main; });\n\n"]}